<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2024-04-30T19:18:20.818411"><title>Java-3 | Notes</title><script type="application/json" id="virtual-toc-data">[{"id":"notes-java","level":0,"title":"notes.Java","anchor":"#notes-java"},{"id":"syntactic-sugar","level":0,"title":"语法糖 Syntactic sugar","anchor":"#syntactic-sugar"},{"id":"reflection","level":0,"title":"反射 reflection","anchor":"#reflection"},{"id":"api","level":0,"title":"编译器API","anchor":"#api"},{"id":"proxy","level":0,"title":"代理(Proxy):代替处理","anchor":"#proxy"},{"id":"aop-aspect-oriented-programming","level":0,"title":"AOP(Aspect Oriented Programming)","anchor":"#aop-aspect-oriented-programming"},{"id":"annotation","level":0,"title":"注解Annotation","anchor":"#annotation"},{"id":"nested-classes","level":0,"title":"嵌套类 Nested classes","anchor":"#nested-classes"},{"id":"lambda","level":0,"title":"Lambda表达式","anchor":"#lambda"},{"id":"stream","level":0,"title":"流 stream","anchor":"#stream"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b259/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Java-3 | Notes"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Notes Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/notes/0.1/java-3.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Java-3 | Notes"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/notes/0.1/java-3.html#webpage",
    "url": "writerside-documentation/notes/0.1/java-3.html",
    "name": "Java-3 | Notes",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentationnotes/#website",
    "url": "writerside-documentationnotes/",
    "name": "Notes Help"
}</script><!-- End Schema.org --></head><body data-id="Java-3" data-main-title="Java-3" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="README.md|Notes///java///notes///Java"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Notes 0.1 Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Java-3" id="Java-3.md">Java-3</h1><ul class="list _bullet" id="-i7x40f_13378"><li class="list__item" id="-i7x40f_13379"><p><span id="-i7x40f_13380">notes.Java</span></p><ul class="list _bullet" id="-i7x40f_13381"><li class="list__item" id="-i7x40f_13382"><p><span id="-i7x40f_13383">语法糖 Syntactic sugar</span></p><ul class="list _bullet" id="-i7x40f_13384"><li class="list__item" id="-i7x40f_13385"><p><span id="-i7x40f_13386">jdk版本</span></p></li><li class="list__item" id="-i7x40f_13387"><p><span id="-i7x40f_13388">for/for-each</span></p></li><li class="list__item" id="-i7x40f_13389"><p><span id="-i7x40f_13390">enum类型</span></p></li><li class="list__item" id="-i7x40f_13391"><p><span id="-i7x40f_13392">不定项参数</span></p></li><li class="list__item" id="-i7x40f_13393"><p><span id="-i7x40f_13394">静态导入</span></p></li><li class="list__item" id="-i7x40f_13395"><p><span id="-i7x40f_13396">自动装箱和拆箱</span></p></li><li class="list__item" id="-i7x40f_13397"><p><span id="-i7x40f_13398">多异常并列</span></p></li><li class="list__item" id="-i7x40f_13399"><p><span id="-i7x40f_13400">数字增强</span></p></li><li class="list__item" id="-i7x40f_13401"><p><span id="-i7x40f_13402">接口方法</span></p></li><li class="list__item" id="-i7x40f_13403"><p><span id="-i7x40f_13404">try-with-resource</span></p></li><li class="list__item" id="-i7x40f_13405"><p><span id="-i7x40f_13406">ResourceBundle文件加载</span></p></li><li class="list__item" id="-i7x40f_13407"><p><span id="-i7x40f_13408">var类型</span></p></li><li class="list__item" id="-i7x40f_13409"><p><span id="-i7x40f_13410">switch</span></p></li></ul></li><li class="list__item" id="-i7x40f_13411"><p><span id="-i7x40f_13412">反射 reflection</span></p></li><li class="list__item" id="-i7x40f_13413"><p><span id="-i7x40f_13414">编译器API</span></p><ul class="list _bullet" id="-i7x40f_13415"><li class="list__item" id="-i7x40f_13416"><p><span id="-i7x40f_13417">JavaCompiler</span></p></li></ul></li><li class="list__item" id="-i7x40f_13418"><p><span id="-i7x40f_13419">代理(Proxy):代替处理</span></p></li><li class="list__item" id="-i7x40f_13420"><p><span id="-i7x40f_13421">AOP(Aspect Oriented Programming)</span></p><ul class="list _bullet" id="-i7x40f_13422"><li class="list__item" id="-i7x40f_13423"><p><span id="-i7x40f_13424">面向切面编程</span></p></li></ul></li><li class="list__item" id="-i7x40f_13425"><p><span id="-i7x40f_13426">注解Annotation</span></p><ul class="list _bullet" id="-i7x40f_13427"><li class="list__item" id="-i7x40f_13428"><p><span id="-i7x40f_13429">自定义注解</span></p></li><li class="list__item" id="-i7x40f_13430"><p><span id="-i7x40f_13431">元注解</span></p></li></ul></li><li class="list__item" id="-i7x40f_13432"><p><span id="-i7x40f_13433">嵌套类 Nested classes</span></p></li><li class="list__item" id="-i7x40f_13434"><p><span id="-i7x40f_13435">Lambda表达式</span></p><ul class="list _bullet" id="-i7x40f_13436"><li class="list__item" id="-i7x40f_13437"><p><span id="-i7x40f_13438">函数式接口</span></p></li><li class="list__item" id="-i7x40f_13439"><p><span id="-i7x40f_13440">系统自带的函数式接口</span></p></li></ul></li></ul></li></ul><section class="chapter"><h2 id="notes-java" data-toc="notes-java">notes.Java</h2></section><section class="chapter"><h2 id="syntactic-sugar" data-toc="syntactic-sugar">语法糖 Syntactic sugar</h2><section class="chapter"><h3 id="jdk" data-toc="jdk">jdk版本</h3><ul class="list _bullet" id="-i7x40f_13441"><li class="list__item" id="-i7x40f_13442"><p>编译级别</p></li><li class="list__item" id="-i7x40f_13443"><p>兼容级别 </p><ul class="list _bullet" id="-i7x40f_13444"><li class="list__item" id="-i7x40f_13445"><p>编译后高版本可以运行低版本字节码</p></li><li class="list__item" id="-i7x40f_13446"><p>反之不行</p></li></ul></li></ul></section><section class="chapter"><h3 id="for-for-each" data-toc="for-for-each">for/for-each</h3><ul class="list _bullet" id="-i7x40f_13447"><li class="list__item" id="-i7x40f_13448"><p>for </p><ul class="list _bullet" id="-i7x40f_13449"><li class="list__item" id="-i7x40f_13450"><p><code class="code" id="-i7x40f_13451">for(int i=0;i&lt;nums.leng;i++)</code></p></li><li class="list__item" id="-i7x40f_13452"><p>可以删除元素</p></li></ul></li><li class="list__item" id="-i7x40f_13453"><p>for-each </p><ul class="list _bullet" id="-i7x40f_13454"><li class="list__item" id="-i7x40f_13455"><p><code class="code" id="-i7x40f_13456">for(String i:hs)</code></p></li><li class="list__item" id="-i7x40f_13457"><p>5.0开始存在</p></li><li class="list__item" id="-i7x40f_13458"><p>语法简洁</p></li><li class="list__item" id="-i7x40f_13459"><p>不能删除元素</p></li><li class="list__item" id="-i7x40f_13460"><p>只能正向遍历</p></li><li class="list__item" id="-i7x40f_13461"><p>不能同时遍历两个集合</p></li></ul></li></ul></section><section class="chapter"><h3 id="enum" data-toc="enum">enum类型</h3><ul class="list _bullet" id="-i7x40f_13462"><li class="list__item" id="-i7x40f_13463"><p>java5 推出</p></li><li class="list__item" id="-i7x40f_13464"><p>enum有多少个值就有几个实例对象</p></li><li class="list__item" id="-i7x40f_13465"><p>可以添加属性/构造函数/方法</p></li><li class="list__item" id="-i7x40f_13466"><p>构造函数只能是package-private(default)或者private,内部调用 enum类型 </p><ul class="list _bullet" id="-i7x40f_13467"><li class="list__item" id="-i7x40f_13468"><p>所有enum类型都是Enum的子类,也继承了相应方法</p></li><li class="list__item" id="-i7x40f_13469"><p>ordinal()返回枚举所在的索引位置,从0开始</p></li><li class="list__item" id="-i7x40f_13470"><p>compareTo()比较两个枚举值的索引位置大小</p></li><li class="list__item" id="-i7x40f_13471"><p>toString()返回枚举值的字符串标识</p></li><li class="list__item" id="-i7x40f_13472"><p>valueOf()将字符串初始化为枚举对象</p></li><li class="list__item" id="-i7x40f_13473"><p>values() 返回所有的枚举值</p></li></ul></li></ul><div class="code-block" data-lang="java">
package notes.Java.Java_Final.suger;

/**
 * @Description:
 * @author: Anhlaidh
 * @date: 2020-07-05 21:31
 */
public class testEnum {
    public static void main(String[] args) {
        Fruit a1 = Fruit.APPLE;
        System.out.println(&quot;Price is&quot; + a1.price);

        System.out.println(&quot;====================&quot;);
        Day d1 = Day.MONDAY;
        Day d2 = Enum.valueOf(Day.class, &quot;MONDAY&quot;);
        System.out.println(d1 == d2);
        Day d3 = Enum.valueOf(Day.class, &quot;TUESDAY&quot;);
        System.out.println(d1.compareTo(d3));

        //遍历
        for (Day item : Day.values()) {
            //输出索引值
            System.out.println(item.toString() + &quot;,&quot; + item.ordinal());
        }
    }

    enum Day {
        MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
    }

    enum Fruit {
        APPLE(10), ORANGE(8);
        private int price;

        Fruit(int price) {
            this.price = price;
        }

        public int getPrice() {
            return price;
        }
    }


}

</div></section><section class="chapter"><h3 id="-i7x40f_13475" data-toc="-i7x40f_13475">不定项参数</h3><ul class="list _bullet" id="-i7x40f_13476"><li class="list__item" id="-i7x40f_13477"><p>JDK5提供了不定参数(可变参数)功能 </p><ul class="list _bullet" id="-i7x40f_13478"><li class="list__item" id="-i7x40f_13479"><p>类型后面加3个点,入int.../double.../String...</p></li><li class="list__item" id="-i7x40f_13480"><p>可变参数,本质上是一个数组</p></li><li class="list__item" id="-i7x40f_13481"><p>一个方法只能由一个不定项参数,且位于参数列表的最后</p></li><li class="list__item" id="-i7x40f_13482"><p>重载的优先级规则1:固定参数的方法,比可变参数优先级更高</p></li><li class="list__item" id="-i7x40f_13483"><p>重载的优先级规则2:调用语句,同时与两个带可变参数的方法匹配,则报错</p></li></ul></li></ul><div class="code-block" data-lang="java">
package notes.Java.Java_Final.suger;

/**
 * @Description: 可变参数
 * @author: Anhlaidh
 * @date: 2020-07-05 21:46
 */
public class testVariableArgument {
    public static void main(String[] args) {
        print();
        print(&quot;aaa&quot;);
        print(&quot;aaa&quot;,&quot;bbb&quot;);
        print(&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;);

    }

    private static void print(String... args) {
        System.out.println(args.length);
        for (String arg : args) {
            System.out.println(arg);
        }
    }

    //当只有一个参数时,本方法优先级更高
    private static void print(String s) {
        System.out.println(&quot;优先级高的方法&quot;);
    }

    //错误:一个方法不可以有多个可变参数
//    public static void print(String... args, int... irgs) {
//
//    }
    //调用语句,同时与两个带可变参数的方法匹配,则报错
//    private static void print(String s1, String... args) {
//
//    }
}

</div></section><section class="chapter"><h3 id="-i7x40f_13485" data-toc="-i7x40f_13485">静态导入</h3><ul class="list _bullet" id="-i7x40f_13486"><li class="list__item" id="-i7x40f_13487"><p>import static</p></li><li class="list__item" id="-i7x40f_13488"><p>导入类中的静态方法 </p><ul class="list _bullet" id="-i7x40f_13489"><li class="list__item" id="-i7x40f_13490"><p>使用时可以直接写方法名,不写类名</p></li></ul></li><li class="list__item" id="-i7x40f_13491"><p>少用*</p></li><li class="list__item" id="-i7x40f_13492"><p>如果重名需要补充类名</p></li></ul></section><section class="chapter"><h3 id="-i7x40f_13493" data-toc="-i7x40f_13493">自动装箱和拆箱</h3><ul class="list _bullet" id="-i7x40f_13494"><li class="list__item" id="-i7x40f_13495"><p>JDK5开始引入,简化基本类型和对象转化的写法</p></li><li class="list__item" id="-i7x40f_13496"><p>Integer--int...</p></li><li class="list__item" id="-i7x40f_13497"><p>编译器的工作,不是jvm的工作</p></li><li class="list__item" id="-i7x40f_13498"><p><code class="code" id="-i7x40f_13499">==</code> :基本类型是内容相同,对象是指针是否相同</p></li><li class="list__item" id="-i7x40f_13500"><p>基本类型没有空值,对象有null</p></li><li class="list__item" id="-i7x40f_13501"><p>基础数据类型与封装类型进行 <code class="code" id="-i7x40f_13502">==</code>, <code class="code" id="-i7x40f_13503">+</code>, <code class="code" id="-i7x40f_13504">-</code>, <code class="code" id="-i7x40f_13505">*</code>, <code class="code" id="-i7x40f_13506">/</code>操作运算,会将封装类进行拆箱,对基础数据类型进行运算</p></li><li class="list__item" id="-i7x40f_13507"><p>谨慎使用多个非同类的数值类进行运算</p></li></ul><div class="code-block" data-lang="java">
package notes.Java.Java_Final.suger;

/**
 * @Description:
 * @author: Anhlaidh
 * @date: 2020-07-07 15:31
 */
public class testNumber {
    public static void main(String[] args) {
        Integer a1 = 1000;
        int a2 = 1000;
        Integer a3 = 2000;
        Long a4 = 2000L;
        long a5 = 2000L;
        System.out.println(a1 == a2);//拆箱再进行数值比较
        System.out.println(a3 == (a1 + a2));//拆箱再进行数值比较
        System.out.println(a4 == (a1 + a2));//拆箱再进行数值比较
        System.out.println(a5 == (a1 + a2));//拆箱再进行数值比较

        System.out.println(a3.equals(a1 + a2));//equals要求同类且内容相同
        System.out.println(a4.equals(a1 + a2));//equals要求同类且内容相同
        System.out.println(a4.equals((long)(a1 + a2)));//equals要求同类,且值相同
//        System.out.println(a3 == a4);//不同类型不能比较
    }
}

</div></section><section class="chapter"><h3 id="-i7x40f_13509" data-toc="-i7x40f_13509">多异常并列</h3><ul class="list _bullet" id="-i7x40f_13510"><li class="list__item" id="-i7x40f_13511"><p>多个异常用 <code class="code" id="-i7x40f_13512">|</code> 隔开</p></li><li class="list__item" id="-i7x40f_13513"><p>多个异常之间不能有直接/简介继承关系</p></li></ul></section><section class="chapter"><h3 id="-i7x40f_13514" data-toc="-i7x40f_13514">数字增强</h3><ul class="list _bullet" id="-i7x40f_13515"><li class="list__item" id="-i7x40f_13516"><p>数字可以二进制赋值 </p><ul class="list _bullet" id="-i7x40f_13517"><li class="list__item" id="-i7x40f_13518"><p>避免二进制计算</p></li><li class="list__item" id="-i7x40f_13519"><p>byte/short/int/long</p></li></ul></li><li class="list__item" id="-i7x40f_13520"><p>数值字面量中可以使用下划线 </p><ul class="list _bullet" id="-i7x40f_13521"><li class="list__item" id="-i7x40f_13522"><p>增加数字的可读性和纠错功能</p></li><li class="list__item" id="-i7x40f_13523"><p>short/int/long/float/double</p></li><li class="list__item" id="-i7x40f_13524"><p>下划线只能出现在数字中间</p></li></ul></li></ul><div class="code-block" data-lang="java">
package notes.Java.Java_Final.suger;

/**
 * @Description:
 * @author: Anhlaidh
 * @date: 2020-07-07 15:40
 */
public class testNumber2 {
    public static void main(String[] args) {
        test1();
        test2();

    }

    private static void test2() {
        long a1 = 9999999999L;
        long a2 = 9_999_999_999L;
        int a3 = 0b0111_1011_0001;//二进制0b开头
        int a4 = 02_014;//8进制,0开头
        int a5 = 123__45;//可以多个下划线
        int a6 = 0x7_B_1;//十六进制
        float a7 = 3.56_78f;//float
        double a8 = 1.3_45_67;//double

//        int b1 = 0b_123_4; _必须在数字之间
//        int b2 = 0123_4_;不能在末尾
//        int b3 = _123;不能在开头
//        int b4 = 0_ x_123;不能拆开0x
//        int b5 = 0x_51;_必须在数字之间
//        long b6 = 1000_L;_必须在数字之间
//        float b7 = 1.34f _;_不能在末尾
        
    }

    private static void test1() {
        byte a1 = (byte) 0b00100001;
        short a2 = (short) 0b001010100;
        int a3 = 0b0010101010;
        int a4 = 0b101;
        int a5 = 0B101;//B可以大小写
        long a6 = 0b1010101010010010010101010L;
        final int[] s1 = {0b101010, 0b101101, 0b1101111, 0b1111};
        System.out.println(a5);
        System.out.println(Integer.toBinaryString(a5));
    }
    
}

</div></section><section class="chapter"><h3 id="-i7x40f_13526" data-toc="-i7x40f_13526">接口方法</h3><ul class="list _bullet" id="-i7x40f_13527"><li class="list__item" id="-i7x40f_13528"><p id="-i7x40f_13529">java8 接口默认方法/静态方法(都带具体实现)</p></li><li class="list__item" id="-i7x40f_13530"><p id="-i7x40f_13531">默认方法</p><ul class="list _bullet" id="-i7x40f_13532"><li class="list__item" id="-i7x40f_13533"><p>规则 </p><ul class="list _bullet" id="-i7x40f_13534"><li class="list__item" id="-i7x40f_13535"><p>以default关键字标注,其他定义和普通函数一样</p></li><li class="list__item" id="-i7x40f_13536"><p>规则1:默认方法 不能重写 Object中的方法</p></li><li class="list__item" id="-i7x40f_13537"><p>规则2:实现类可以继承/重写父接口默认方法</p></li><li class="list__item" id="-i7x40f_13538"><p>规则3:接口可以继承/重写父接口的默认方法</p></li><li class="list__item" id="-i7x40f_13539"><p>规则4:当父类和父接口都有(同名同参数) 默认方法,子类继承父类的默认方法,这样可以兼容JDK7及以前的代码</p></li><li class="list__item" id="-i7x40f_13540"><p>规则5:子类实现了两个接口(均有同名同参数的默认方法),那么编译失败,必须在子类中重写这个default方法</p></li></ul></li></ul></li><li class="list__item" id="-i7x40f_13541"><p id="-i7x40f_13542">静态方法</p><ul class="list _bullet" id="-i7x40f_13543"><li class="list__item" id="-i7x40f_13544"><p>属于本接口,不属于子类/子接口</p></li><li class="list__item" id="-i7x40f_13545"><p>子类(子接口)没有继承该静态方法,只能通过所在的接口名来调用 -java9 私有方法</p></li><li class="list__item" id="-i7x40f_13546"><p>解决多个默认方法/静态方法的内容重复问题</p></li><li class="list__item" id="-i7x40f_13547"><p>私有方法属于本接口,只在本接口内使用,不属于子类/子接口</p></li><li class="list__item" id="-i7x40f_13548"><p>子类(子接口)没有继承该私有方法,也无法调用</p></li><li class="list__item" id="-i7x40f_13549"><p>静态私有方法可以被静态/默认方法调用,非静态私有方法被默认方法调用</p></li></ul></li><li class="list__item" id="-i7x40f_13550"><p id="-i7x40f_13551">接口,抽象类</p><ul class="list _bullet" id="-i7x40f_13552"><li class="list__item" id="-i7x40f_13553"><p>相同点 </p><ul class="list _bullet" id="-i7x40f_13554"><li class="list__item" id="-i7x40f_13555"><p>都是抽象的,都不能被实例化,即不能被new</p></li><li class="list__item" id="-i7x40f_13556"><p>都可以有实现方法</p></li><li class="list__item" id="-i7x40f_13557"><p>都可以不需要继承者实现所有方法</p></li></ul></li><li class="list__item" id="-i7x40f_13558"><p>不同点(java12之前) </p><ul class="list _bullet" id="-i7x40f_13559"><li class="list__item" id="-i7x40f_13560"><p>抽象类最多只能继承一个,接口可以实现多个</p></li><li class="list__item" id="-i7x40f_13561"><p>接口的变量默认是public static final,且必须有初值,子类不能修改,而抽象类的变量默认是default,子类可以继承修改</p></li><li class="list__item" id="-i7x40f_13562"><p>接口没有构造函数,抽象类有构造函数</p></li><li class="list__item" id="-i7x40f_13563"><p>接口没有main函数,抽象类可以有main函数</p></li><li class="list__item" id="-i7x40f_13564"><p>接口有public/default/private的方法,抽象类只有public/private/protected/不写关键字的(default)的方法</p></li></ul></li></ul></li></ul></section><section class="chapter"><h3 id="try-with-resource" data-toc="try-with-resource">try-with-resource</h3><ul class="list _bullet" id="-i7x40f_13565"><li class="list__item" id="-i7x40f_13566"><p>jdk7提供try-with-resource </p><ul class="list _bullet" id="-i7x40f_13567"><li class="list__item" id="-i7x40f_13568"><p>资源要求定义在try中,若已经定义在外面,则需要一个本地变量</p></li></ul></li><li class="list__item" id="-i7x40f_13569"><p>jdk9不在要求定义临时变量,可以直接使用外部资源变量</p></li><li class="list__item" id="-i7x40f_13570"><p>原理 </p><ul class="list _bullet" id="-i7x40f_13571"><li class="list__item" id="-i7x40f_13572"><p>资源对象必须实现AutoCloseable接口,即close方法,jdk自带</p></li></ul></li></ul><div class="code-block" data-lang="java">
package notes.Java.Java_Final.suger.testTryWithResource;

/**
 * @Description:
 * @author: Anhlaidh
 * @date: 2020-07-07 16:58
 */
public class test {
    public static void main(String[] args) {
        try (MyConnection connection = new MyConnection()) {
            connection.sendData();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}
class MyConnection implements AutoCloseable {
    public void sendData() throws Exception {
        System.out.println(&quot;Send Data...&quot;);
    }
    @Override
    public void close() throws Exception {
        System.out.println(&quot;Close...&quot;);
    }
}
</div></section><section class="chapter"><h3 id="resourcebundle" data-toc="resourcebundle">ResourceBundle文件加载</h3><ul class="list _bullet" id="-i7x40f_13574"><li class="list__item" id="-i7x40f_13575"><p>JDK9及以后,ResourceBundle默认以UTF-8方式加载</p></li></ul></section><section class="chapter"><h3 id="var" data-toc="var">var类型</h3><ul class="list _bullet" id="-i7x40f_13576"><li class="list__item" id="-i7x40f_13577"><p>java10推出var </p><ul class="list _bullet" id="-i7x40f_13578"><li class="list__item" id="-i7x40f_13579"><p>避免信息冗余</p></li><li class="list__item" id="-i7x40f_13580"><p>对齐了变量名</p></li><li class="list__item" id="-i7x40f_13581"><p>更容易阅读</p></li><li class="list__item" id="-i7x40f_13582"><p>本质上还是强类型语言,编译器负责推断类型,并写入字节码文件,因此推断后不能更改</p></li></ul></li><li class="list__item" id="-i7x40f_13583"><p>var的限制 </p><ul class="list _bullet" id="-i7x40f_13584"><li class="list__item" id="-i7x40f_13585"><p>可以用在局部变量中,非类成员变量</p></li><li class="list__item" id="-i7x40f_13586"><p>可以在for/for-each中</p></li><li class="list__item" id="-i7x40f_13587"><p>声明时必须初始化</p></li><li class="list__item" id="-i7x40f_13588"><p>不能用在方法(形式)参数和返回类型</p></li><li class="list__item" id="-i7x40f_13589"><p>大面积滥用会使代码整体阅读性变差</p></li><li class="list__item" id="-i7x40f_13590"><p>var 只在编译时起作用,没有在字节码中引入新的内容,也没有专门的jvm指令处理var</p></li></ul></li></ul></section><section class="chapter"><h3 id="switch" data-toc="switch">switch</h3><ul class="list _bullet" id="-i7x40f_13591"><li class="list__item" id="-i7x40f_13592"><p>支持的类型:byte/Byte,short/Short,int/Integer,char/Character,String(7.0),Enum(5.0)</p></li><li class="list__item" id="-i7x40f_13593"><p>仍不支持long/float/double</p></li><li class="list__item" id="-i7x40f_13594"><p>多分支合并</p></li></ul><div class="code-block" data-lang="java">
package notes.Java.Java_Final.suger;

import java.util.Scanner;

/**
 * @Description:
 * @author: Anhlaidh
 * @date: 2020-07-07 17:16
 */
public class testSwitch {
    public static void main(String[] args) {
//        test1();
        test2();
    }

    private static void test2() {
        Scanner scanner = new Scanner(System.in);
        int num= scanner.nextInt();
        int days = switch (num){
            case 1,3,5,7,8,10,12 -&gt; 31;
            case 4,6,9,11 -&gt; 30;
            default -&gt; 28;
        };
        System.out.println(days);
    }

    private static void test1() {
        Scanner scanner = new Scanner(System.in);
        String month = scanner.next();
        int result=-1;
        switch (month) {
            case &quot;Jan&quot;,&quot;Mar&quot;,&quot;May&quot;,&quot;July&quot;,&quot;Aug&quot;,&quot;Oct&quot;,&quot;Dec&quot; -&gt; result = 31;
            case &quot;Apr&quot;,&quot;June&quot;,&quot;Sep&quot;,&quot;Nov&quot; -&gt; result = 30;
            case &quot;Feb&quot; -&gt; result = 28;
            default -&gt; result = -1;


        }
        System.out.println(result);
    }
}


</div></section></section><section class="chapter"><h2 id="reflection" data-toc="reflection">反射 reflection</h2><ul class="list _bullet" id="-i7x40f_13596"><li class="list__item" id="-i7x40f_13597"><p>定义 </p><ul class="list _bullet" id="-i7x40f_13598"><li class="list__item" id="-i7x40f_13599"><p>程序可以访问,检测和修改它本身状态或行为的能力,即自描述和自控制</p></li><li class="list__item" id="-i7x40f_13600"><p>可以在运行时加载,探知,和使用编译期间完全未知的类</p></li><li class="list__item" id="-i7x40f_13601"><p>给java插上动态语言特性的翅膀,弥补强类型语言的不足</p></li><li class="list__item" id="-i7x40f_13602"><p>java.lan.reflect包,在java2存在,java5完善</p></li></ul></li><li class="list__item" id="-i7x40f_13603"><p>功能 </p><ul class="list _bullet" id="-i7x40f_13604"><li class="list__item" id="-i7x40f_13605"><p>在运行中分析类的能力</p></li><li class="list__item" id="-i7x40f_13606"><p>在运行中查看和操作对象 </p><ul class="list _bullet" id="-i7x40f_13607"><li class="list__item" id="-i7x40f_13608"><p>基于反射自由创建对象</p></li><li class="list__item" id="-i7x40f_13609"><p>反射构建出无法直接访问的类</p></li><li class="list__item" id="-i7x40f_13610"><p>set或者get到无法访问的成员变量</p></li><li class="list__item" id="-i7x40f_13611"><p>调用不可访问的方法</p></li></ul></li><li class="list__item" id="-i7x40f_13612"><p>实现通用的数组操作代码</p></li><li class="list__item" id="-i7x40f_13613"><p>类似函数指针的功能</p></li></ul></li><li class="list__item" id="-i7x40f_13614"><p>创建对象 </p><ol class="list _decimal" id="-i7x40f_13615" type="1"><li class="list__item" id="-i7x40f_13616"><p id="-i7x40f_13617">静态编码&amp;编译(new)</p></li><li class="list__item" id="-i7x40f_13618"><p id="-i7x40f_13619">克隆(clone()),继承Cloneable,速度快</p></li><li class="list__item" id="-i7x40f_13620"><p id="-i7x40f_13621">序列化serialization,反序列化deserialization继承Serializable接口</p><ul class="list _bullet" id="-i7x40f_13622"><li class="list__item" id="-i7x40f_13623"><div class="code-block" data-lang="java">
  package notes.Java.Java_Final.Reflect;

  import java.io.*;

  /**
   * @Description:
   * @author: Anhlaidh
   * @date: 2020-07-07 18:05
   */
  public class testSerialization {
      public static void main(String[] args) throws IOException, ClassNotFoundException {
          A obj1 = new A();
          ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;data.obj&quot;));
          out.writeObject(obj1);
          out.close();
          ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;data.obj&quot;));
          A obj2 = (A) in.readObject();
          in.close();
          obj2.hello();
      }

  }

  class A implements Serializable {
      private static final long serialVersionUID = 1L;

      public void hello() {
          System.out.println(&quot;hello from A&quot;);

      }

  }
</div></li></ul></li><li class="list__item" id="-i7x40f_13625"><p id="-i7x40f_13626">反射</p><div class="code-block" data-lang="java">
package notes.Java.Java_Final.Reflect;


import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

/**
 * @Description:
 * @author: Anhlaidh
 * @date: 2020-07-07 19:32
 */
public class testNewInstance {
    public static void main(String[] args) throws ClassNotFoundException, InvocationTargetException, IllegalAccessException, InstantiationException, NoSuchMethodException {
        Object obj1 = Class.forName(&quot;notes.Java.Java_Final.Reflect.A&quot;).newInstance();
        Method m = Class.forName(&quot;notes.Java.Java_Final.Reflect.A&quot;).getMethod(&quot;hello&quot;);
        m.invoke(obj1);//获取方法
        A obj2 = (A) Class.forName(&quot;notes.Java.Java_Final.Reflect.A&quot;).newInstance();
        Constructor&lt;A&gt; constructor = A.class.getConstructor();//构造函数
        A obj3 = constructor.newInstance();
        obj3.hello();

    }

}

</div></li></ol></li><li class="list__item" id="-i7x40f_13628"><p>内容 </p><ol class="list _decimal" id="-i7x40f_13629" type="1"><li class="list__item" id="-i7x40f_13630"><p>Class:类型标识 </p><ul class="list _bullet" id="-i7x40f_13631"><li class="list__item" id="-i7x40f_13632"><p>JVM为每个对象都保留其类型标识信息(Runtime Type Identification)</p></li><li class="list__item" id="-i7x40f_13633"><p>成员变量,方法,构造函数,修饰符,包,父类,父接口...</p></li><li class="list__item" id="-i7x40f_13634"><p>成员变量Field</p></li><li class="list__item" id="-i7x40f_13635"><p>方法Method</p></li><li class="list__item" id="-i7x40f_13636"><p>构造函数Constructor</p></li></ul></li></ol></li></ul></section><section class="chapter"><h2 id="api" data-toc="api">编译器API</h2><ul class="list _bullet" id="-i7x40f_13637"><li class="list__item" id="-i7x40f_13638"><p>对 .java文件即时编译</p></li><li class="list__item" id="-i7x40f_13639"><p>对字符串即时编译</p></li><li class="list__item" id="-i7x40f_13640"><p>监听在编译过程中产生的警告和错误</p></li><li class="list__item" id="-i7x40f_13641"><p>在代码中运行编译器(并非:Runtime命令调用javac命令)</p></li></ul><section class="chapter"><h3 id="javacompiler" data-toc="javacompiler">JavaCompiler</h3><ul class="list _bullet" id="-i7x40f_13642"><li class="list__item" id="-i7x40f_13643"><p id="-i7x40f_13644">1.6推出</p></li><li class="list__item" id="-i7x40f_13645"><p id="-i7x40f_13646">可用在程序文件中的Java编译器接口(代替javac.exe)</p></li><li class="list__item" id="-i7x40f_13647"><p id="-i7x40f_13648">在程序中编译java文件,产生class文件</p></li><li class="list__item" id="-i7x40f_13649"><p id="-i7x40f_13650">run方法(继承自java.tools.Tools):较简单,可以编译java源文件,生成class文件,但不能指定输出 路径,监控错误信息,调用后就在源码所在目录生成class文件</p></li><li class="list__item" id="-i7x40f_13651"><p id="-i7x40f_13652">getTask方法:更强大的功能,可以编译java源文件,包括在内存中的java文件(字符串),生成class文件</p></li><li class="list__item" id="-i7x40f_13653"><p id="-i7x40f_13654">编译文件:</p></li></ul><div class="code-block" data-lang="java">
package notes.Java.Java_Final.JavaCompiler;

import javax.tools.JavaCompiler;
import javax.tools.ToolProvider;
import java.io.ByteArrayOutputStream;
import java.nio.charset.Charset;

/**
 * @Description:
 * @author: Anhlaidh
 * @date: 2020-08-04 14:30
 */
public class SimpleJavaCompiler {
    public static void main(String[] args) {
//        successCompile();

        failCompile();
    }

    private static void failCompile() {
        ByteArrayOutputStream err = new ByteArrayOutputStream();
        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
        int result = compiler.run(null, null, err, &quot;./aaa.java&quot;);
        if (0 == result) {
            System.out.println(&quot;Success&quot;);
        } else {
            System.out.println(&quot;Fail&quot;);
            System.out.println(new String(err.toByteArray(), Charset.defaultCharset()) );
        }
    }


    private static void successCompile() {
        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
        /**
         * 第一个参数:输入流,null表示默认使用system.in
         * 第二个参数:输出流,null标识默认使用system.out
         * 第三个参数:错误流,null标识默认使用system.err
         * 第四个参数:String...需要编译的文件名
         * 返回值:0表示成功,其他错误
         */
        int result = compiler.run(null, null, null, &quot;G:\\Coding\\src\\main\\java\\notes.Java\\Java_Final\\API\\hello1.java&quot;,&quot;G:\\Coding\\src\\main\\java\\notes.Java\\Java_Final\\API\\hello2.java&quot;);

        System.out.println(0 == result ? &quot;Success&quot; : &quot;Fail&quot;);
    }
}

</div><ul class="list _bullet" id="-i7x40f_13656"><li class="list__item" id="-i7x40f_13657"><p>编译字符串</p></li></ul><div class="code-block" data-lang="java">
package notes.Java.Java_Final.JavaCompiler;

import javax.tools.*;
import java.io.File;
import java.lang.reflect.Method;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.charset.Charset;
import java.util.Arrays;

/**
 * @Description:
 * @author: Anhlaidh
 * @date: 2020-08-04 14:46
 */
public class JavaCompilerTask {
    public static void main(String[] args) {
        compilerJavaFromString();
//        System.out.println(&quot;hello world&quot;);
    }

    private static void compilerJavaFromString() {
        StringBuffer stringBuffer = new StringBuffer();
        String className = &quot;Hello&quot;;
        stringBuffer.append(&quot;public class &quot; + className + &quot;{&quot;);
        stringBuffer.append(&quot; public static void main(String[] args) {&quot;);
        stringBuffer.append(&quot; System.out.println(\&quot;hello world\&quot;);\n&quot;);
        stringBuffer.append(&quot;}\n&quot;);
        stringBuffer.append(&quot;}\n&quot;);


        Class&lt;?&gt; c = compiler(className, stringBuffer.toString());
        try {
            //生成对象
            Object obj = c.newInstance();
            Method m = c.getMethod(&quot;main&quot;, String[].class);
            m.invoke(obj, new Object[]{new String[]{}});

        } catch (Exception e) {
            e.printStackTrace();

        }

    }

    private static Class&lt;?&gt; compiler(String className, String javaCode) {
        JavaSourceFromString srcObject = new JavaSourceFromString(className, javaCode);
        System.out.println(srcObject.getCode());
        Iterable&lt;? extends JavaFileObject&gt; fileObjects = Arrays.asList(srcObject);

        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
        StandardJavaFileManager fileManager = compiler.getStandardFileManager(null, null, Charset.defaultCharset());
        DiagnosticCollector&lt;JavaFileObject&gt; diagnosticCollector = new DiagnosticCollector&lt;&gt;();
        //设置编译的输出目录,并包装在options中
        String flag = &quot;-d&quot;;
        String outDir = &quot;&quot;;
        try {
            URL resource = Thread.currentThread().getContextClassLoader().getResource(&quot;&quot;);
            File classpath = new File(resource.toURI());
            outDir = classpath.getAbsolutePath() + File.separator;
            System.out.println(outDir);
        } catch (URISyntaxException e) {
            e.printStackTrace();
        }
        Iterable&lt;String&gt; options = Arrays.asList(flag, outDir);
        /**
         * JavaCompiler.getTask方法:以future的任务形式(多线程)来执行编译任务
         * 第一个参数:额外输出流,null表示默认使用System.err
         * 第二个参数:文件管理器,null表示编译器默认方法来报告诊断信息
         * 第三个参数:诊断监听器,null表示使用编译器默认方法来报告诊断信息
         * 第四个参数:编译器参数,null表示无参数
         * 第五个参数:需要经过annotation处理的类名,null表示没有类需要annotation
         * 第六个参数,待编译的类
         */
        JavaCompiler.CompilationTask task = compiler.getTask(null, fileManager, diagnosticCollector, options, null, fileObjects);
        //等待编译结束
        boolean result = task.call();
        if (result == true) {

            try {
                return Class.forName(className);
            } catch (ClassNotFoundException e) {
                e.printStackTrace();
            }
        } else {
            for (Diagnostic diagnostic : diagnosticCollector.getDiagnostics()) {
                System.out.println(&quot;Error on line:&quot; + diagnostic.getLineNumber() + &quot;;URI&quot; + diagnostic.getSource().toString());
            }

        }
        return null;
    }

}

</div><ul class="list _bullet" id="-i7x40f_13659"><li class="list__item" id="-i7x40f_13660"><p>其中的JavaSourceFromString 类</p></li></ul><div class="code-block" data-lang="java">
package notes.Java.Java_Final.JavaCompiler;

import javax.tools.SimpleJavaFileObject;
import java.io.IOException;
import java.net.URI;

/**
 * @Description: A file object used to represent source coming from a string
 * @author: Anhlaidh
 * @date: 2020-08-04 14:57
 */
public class JavaSourceFromString extends SimpleJavaFileObject {
    private String code;
    public JavaSourceFromString(String name, String code) {
        super(URI.create(&quot;string:///&quot; + name.replace('.', '/') + Kind.SOURCE.extension),Kind.SOURCE);
        this.code = code;
    }

    @Override
    public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {
        return code;
    }

    public String getCode() {
        return code;
    }
}

</div><ul class="list _bullet" id="-i7x40f_13662"><li class="list__item" id="-i7x40f_13663"><p>notes.Java EE 的Jsp编译</p></li><li class="list__item" id="-i7x40f_13664"><p>在线编程观景</p></li><li class="list__item" id="-i7x40f_13665"><p>在线程序评判系统(OJ)</p></li><li class="list__item" id="-i7x40f_13666"><p>自动化的构建和测试工具</p></li></ul></section></section><section class="chapter"><h2 id="proxy" data-toc="proxy">代理(Proxy):代替处理</h2><ul class="list _bullet" id="-i7x40f_13667"><li class="list__item" id="-i7x40f_13668"><p>代理模式 </p><ul class="list _bullet" id="-i7x40f_13669"><li class="list__item" id="-i7x40f_13670"><p>外界不用直接访问目标对象,而是访问代理对象,由代理对象再调用目标对象</p></li><li class="list__item" id="-i7x40f_13671"><p>代理对象中可以添加监控和审查处理</p></li><li class="list__item" id="-i7x40f_13672"><p>静态代理 </p><ul class="list _bullet" id="-i7x40f_13673"><li class="list__item" id="-i7x40f_13674"><p>代理对象持有目标对象的句柄</p></li><li class="list__item" id="-i7x40f_13675"><p>所有调用目标对象的方法,都调用代理对象的方法</p></li><li class="list__item" id="-i7x40f_13676"><p>对每个方法,需要静态编码(理解简单,但代码繁琐)</p></li></ul></li><li class="list__item" id="-i7x40f_13677"><p>动态代理 </p><ul class="list _bullet" id="-i7x40f_13678"><li class="list__item" id="-i7x40f_13679"><p>对目标对象的方法每次被调用,进行动态拦截</p></li><li class="list__item" id="-i7x40f_13680"><p>方法重名会用第一个接口的方法</p></li></ul></li></ul></li><li class="list__item" id="-i7x40f_13681"><p>Main</p></li></ul><div class="code-block" data-lang="java">
package notes.Java.Java_Final.Proxy.test;

import java.lang.reflect.*;
import java.util.Arrays;

/**
 * @Description:
 * @author: Anhlaidh
 * @date: 2020-08-04 18:06
 */
public class MultipleInterfacesProxyTest {
    public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
        Cook cook = new CookImpl();
        ClassLoader cl = MultipleInterfacesProxyTest.class.getClassLoader();
        ProxyHandler handler = new ProxyHandler(cook);
        //生成代理类型
        Class&lt;?&gt; proxyClass = Proxy.getProxyClass(cl, new Class&lt;?&gt;[]{Cook.class, Driver.class});
        //生成代理对象
        Object proxy = proxyClass.getConstructor(new Class[]{InvocationHandler.class}).newInstance(new Object[]{handler});
        System.out.println(Proxy.isProxyClass(proxyClass));

        Proxy p = (Proxy) proxy;
        System.out.println(Proxy.getInvocationHandler(proxy).getClass().getName());
        System.out.println(&quot;proxy类型&quot; + proxyClass.getName());
        //代理对象都继承于java.lang.reflect.Proxy,但是获取父类是Object而不是Proxy
        Class father = proxyClass.getSuperclass();
        System.out.println(&quot;proxy的父类类型:&quot; + father.getName());
        Class[] cs = proxy.getClass().getInterfaces();
        for (Class c : cs) {

            System.out.println(&quot;proxy的父接口类型&quot; + c.getName());
        }
        System.out.println(&quot;===============&quot;);
        Method[] ms = proxy.getClass().getMethods();
        for (Method m : ms) {
            System.out.println(&quot;调用方法&quot; + m.getName() + &quot;参数为&quot; + Arrays.deepToString(m.getParameters()));
        }
        System.out.println(&quot;===============&quot;);
        Cook c = (Cook) proxy;
        c.doWork();
        Driver d = (Driver) proxy;
        d.doWork();

    }
}

</div><ul class="list _bullet" id="-i7x40f_13683"><li class="list__item" id="-i7x40f_13684"><p>Handler</p></li></ul><div class="code-block" data-lang="java">
package notes.Java.Java_Final.Proxy.test;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.util.Arrays;

/**
 * @Description:
 * @author: Anhlaidh
 * @date: 2020-08-04 18:03
 */
public class ProxyHandler implements InvocationHandler {
    private Cook cook;

    public ProxyHandler(Cook cook) {
        this.cook = cook;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println(&quot;proxy类型&quot; + proxy.getClass().getName());
        System.out.println(&quot;调用方法&quot; + method + &quot;;参数为&quot; + Arrays.deepToString(args));
        Object result = method.invoke(cook, args);
        return result;
    }
}

</div></section><section class="chapter"><h2 id="aop-aspect-oriented-programming" data-toc="aop-aspect-oriented-programming">AOP(Aspect Oriented Programming)</h2><ul class="list _bullet" id="-i7x40f_13686"><li class="list__item" id="-i7x40f_13687"><p>面向对象: 将需求功能划分为不同的,独立,分装良好的类,并让他们通过继承和多态实现相同和不同行为</p></li><li class="list__item" id="-i7x40f_13688"><p>面向切面: 将通用需求功能从众多类中分离出来,使得很多类共享一个行为,一旦发生变化,不必修改很多类,而只修改这个行为即可</p></li></ul><section class="chapter"><h3 id="-i7x40f_13689" data-toc="-i7x40f_13689">面向切面编程</h3><ul class="list _bullet" id="-i7x40f_13690"><li class="list__item" id="-i7x40f_13691"><p>一个概念/规范,没有限定语言</p></li><li class="list__item" id="-i7x40f_13692"><p>不是取代OOP编程,而是OOP的补充,和数据库的触发器有点相似</p></li><li class="list__item" id="-i7x40f_13693"><p>主要内容 </p><ul class="list _bullet" id="-i7x40f_13694"><li class="list__item" id="-i7x40f_13695"><p>Aspect:配置文件,包括一些Pointcut和响应的Advice</p></li><li class="list__item" id="-i7x40f_13696"><p>JointPoint:在程序中明确定义的点,如方法调用,对类成员访问等</p></li><li class="list__item" id="-i7x40f_13697"><p>PointCut: 一组JointPoint,可以哦通过逻辑关系/通配符/正则等组合起来,定义了响应advice将要发生的地方</p></li><li class="list__item" id="-i7x40f_13698"><p>Advice:定义了在pointcut处要发生的动作,通过before/after/around来关联</p></li><li class="list__item" id="-i7x40f_13699"><p>weaving:advice代码在具体jointPoint的关联方式</p></li></ul></li></ul></section></section><section class="chapter"><h2 id="annotation" data-toc="annotation">注解Annotation</h2><ul class="list _bullet" id="-i7x40f_13700"><li class="list__item" id="-i7x40f_13701"><p>JDK1.5引入</p></li><li class="list__item" id="-i7x40f_13702"><p>位于源码中(代码/注释/注解),使用其他工具进行处理的标签</p></li><li class="list__item" id="-i7x40f_13703"><p>注解用来修饰程序的元素,但不会对修饰的对象有直接的影响</p></li><li class="list__item" id="-i7x40f_13704"><p>只有通过某种配套的工具才会对注解信息进行访问和处理</p></li><li class="list__item" id="-i7x40f_13705"><p>主要用途 </p><ul class="list _bullet" id="-i7x40f_13706"><li class="list__item" id="-i7x40f_13707"><p>提供信息给编译器/IDE工具</p></li><li class="list__item" id="-i7x40f_13708"><p>可用于其他工具来产生额外的代码/配置文件等</p></li><li class="list__item" id="-i7x40f_13709"><p>有一些注解可在程序运行时访问,增加程序动态性</p></li></ul></li><li class="list__item" id="-i7x40f_13710"><p>@SuppressWarning </p><ul class="list _bullet" id="-i7x40f_13711"><li class="list__item" id="-i7x40f_13712"><p>不同jdk 不同,javac -X可查看</p></li></ul></li></ul><section class="chapter"><h3 id="-i7x40f_13713" data-toc="-i7x40f_13713">自定义注解</h3><ul class="list _bullet" id="-i7x40f_13714"><li class="list__item" id="-i7x40f_13715"><p>注解可以包括的类型 </p><ul class="list _bullet" id="-i7x40f_13716"><li class="list__item" id="-i7x40f_13717"><p>8种基本类型</p></li><li class="list__item" id="-i7x40f_13718"><p>String</p></li><li class="list__item" id="-i7x40f_13719"><p>Class</p></li><li class="list__item" id="-i7x40f_13720"><p>enum</p></li><li class="list__item" id="-i7x40f_13721"><p>注解类型</p></li><li class="list__item" id="-i7x40f_13722"><p>由前面类型组成的数组</p></li></ul></li></ul><div class="code-block" data-lang="java">
package notes.Java.Java_Final.Annotation;

public @interface BugReport {
    enum Status {UNCONFIRMED,CONFIRMED,FIXED, NOTABUG};

    boolean showStopper() default true;

    String assignedTo() default &quot;[notes]&quot;;

    Status status() default Status.UNCONFIRMED;

    String[] reportedBy();
}

</div><ul class="list _bullet" id="-i7x40f_13724"><li class="list__item" id="-i7x40f_13725"><p>注解使用的位置(@Target)</p></li><li class="list__item" id="-i7x40f_13726"><p>@Retention(RetentionPolicy.RUNTIME) 编译时也存在</p></li><li class="list__item" id="-i7x40f_13727"><p>自定义注解及其使用</p></li></ul><div class="code-block" data-lang="java">
package notes.Java.Java_Final.Annotation.Single;

import java.lang.reflect.Method;

/**
 * @Description:
 * @author: Anhlaidh 
 * @date: 2020-08-05 17:18
 */
public class Main {
    public static void main(String[] args) throws ClassNotFoundException {
        int passed = 0, failed = 0;
        String className = &quot;notes.Java.Java_Final.Annotation.Single.Foo&quot;;
        for (Method m : Class.forName(className).getMethods()) {
            if (m.isAnnotationPresent(SingleTest.class)) {
                System.out.println(m.getName());
                SingleTest st = m.getAnnotation(SingleTest.class);
                try {
                    m.invoke(null, st.value());
                    passed++;
                } catch (Throwable throwable) {
                    System.out.printf(&quot;Test %s failed %s %n&quot;, m, throwable.getCause().getMessage());
                    failed++;
                }
            }
        }
        System.out.printf(&quot;Success: %d ,Failed: %d %n&quot;, passed, failed);
    }
}

</div></section><section class="chapter"><h3 id="-i7x40f_13729" data-toc="-i7x40f_13729">元注解</h3><ul class="list _bullet" id="-i7x40f_13730"><li class="list__item" id="-i7x40f_13731"><p id="-i7x40f_13732">修饰注解的注解</p></li><li class="list__item" id="-i7x40f_13733"><p id="-i7x40f_13734">@Target 设置目标范围</p><ul class="list _bullet" id="-i7x40f_13735"><li class="list__item" id="-i7x40f_13736"><p>限定目标注解作用于什么位置@Target()</p></li><li class="list__item" id="-i7x40f_13737"><p>ElementType.ANNOTATION_TYPE(注:修饰注解)</p></li><li class="list__item" id="-i7x40f_13738"><p>ElementType.CONSTRUCTOR</p></li><li class="list__item" id="-i7x40f_13739"><p>ElementType.FIELD</p></li><li class="list__item" id="-i7x40f_13740"><p>ElementType.LOCAL_VARIABLE</p></li><li class="list__item" id="-i7x40f_13741"><p>ElementType.METHOD</p></li><li class="list__item" id="-i7x40f_13742"><p>ElementType.PACKAGE</p></li><li class="list__item" id="-i7x40f_13743"><p>ElementType.PARAMETER</p></li><li class="list__item" id="-i7x40f_13744"><p>ElementType.TYPE(注:任何类型,即上面的类型都可以修饰)</p></li></ul></li><li class="list__item" id="-i7x40f_13745"><p id="-i7x40f_13746">@Retention 设置保持性</p><ul class="list _bullet" id="-i7x40f_13747"><li class="list__item" id="-i7x40f_13748"><p>修饰其他注解的存在范围</p></li><li class="list__item" id="-i7x40f_13749"><p>Retention.SOURCE 注解仅存在源码,不在class文件</p></li><li class="list__item" id="-i7x40f_13750"><p>Retention.CLASS(默认的注解保留策略) 注解存在于.class文件,不能被JVM加载</p></li><li class="list__item" id="-i7x40f_13751"><p>Retention.RUNTIME这种策略下,注解可以被JVM运行时访问到,通常情况下,可以结合反射来做一些事情</p></li></ul></li><li class="list__item" id="-i7x40f_13752"><p id="-i7x40f_13753">@Inherited 注解继承</p><ul class="list _bullet" id="-i7x40f_13754"><li class="list__item" id="-i7x40f_13755"><p>让一个类和他的子类都包含某个注解</p></li><li class="list__item" id="-i7x40f_13756"><p>普通的注解没有继承功能</p></li></ul></li><li class="list__item" id="-i7x40f_13757"><p id="-i7x40f_13758">@Repeatable 此注解可以重复修饰</p><ul class="list _bullet" id="-i7x40f_13759"><li class="list__item" id="-i7x40f_13760"><p>自jdk1.8引入</p></li><li class="list__item" id="-i7x40f_13761"><p>表示被修饰的注解可以重复应用标注</p></li><li class="list__item" id="-i7x40f_13762"><p>需要定义注解和容器注解</p></li></ul></li><li class="list__item" id="-i7x40f_13763"><p id="-i7x40f_13764">@Document 文档</p><ul class="list _bullet" id="-i7x40f_13765"><li class="list__item" id="-i7x40f_13766"><p>指明这个注解可以被javadoc工具解析,形成帮助文档</p></li></ul></li><li class="list__item" id="-i7x40f_13767"><p id="-i7x40f_13768">RUNTIME注解调用路线</p><ol class="list _decimal" id="-i7x40f_13769" type="1"><li class="list__item" id="-i7x40f_13770"><p>Java为注解产生一个代理类</p></li><li class="list__item" id="-i7x40f_13771"><p>这个代理类包括一个AnnotationInvocationHandler成员变量</p></li><li class="list__item" id="-i7x40f_13772"><p>AnnotationInvocationHandler有个Map的成员变量,用来存储所有的注解的属性赋值</p></li><li class="list__item" id="-i7x40f_13773"><p>在程序中,调用注解接口的方法,将会被代理类接管,然后根据方法名字,到Map里拿到对应的Value并返回</p></li></ol></li></ul></section></section><section class="chapter"><h2 id="nested-classes" data-toc="nested-classes">嵌套类 Nested classes</h2><ul class="list _bullet" id="-i7x40f_13774"><li class="list__item" id="-i7x40f_13775"><p id="-i7x40f_13776">静态嵌套类: Static nested classes,即前面有static修饰符</p><ul class="list _bullet" id="-i7x40f_13777"><li class="list__item" id="-i7x40f_13778"><p>层级和包围类(enclosing class)的成员变量/方法一样</p></li><li class="list__item" id="-i7x40f_13779"><p>静态嵌套类可以定义静态和非静态成员</p></li><li class="list__item" id="-i7x40f_13780"><p>第三方需要通过外部包围类才可以访问到静态嵌套类 </p><ul class="list _bullet" id="-i7x40f_13781"><li class="list__item" id="-i7x40f_13782"><p><code class="code" id="-i7x40f_13783">Outer.Inner obj = new Outer.Inner();</code></p></li></ul></li></ul></li><li class="list__item" id="-i7x40f_13784"><p id="-i7x40f_13785">非静态嵌套类: Non-static nested classes ,又名内部类,Inner classes</p><ul class="list _bullet" id="-i7x40f_13786"><li class="list__item" id="-i7x40f_13787"><p>普通内部类(成员内部类) </p><ul class="list _bullet" id="-i7x40f_13788"><li class="list__item" id="-i7x40f_13789"><p>非static的类,定义在某个类的成员变量位置</p></li><li class="list__item" id="-i7x40f_13790"><p>定义后在类里面均可以使用</p></li><li class="list__item" id="-i7x40f_13791"><p>在第三方类中,需要先创建外部包围类实例,才能创建内部类的实例,不允许单独的普通内部类对象存在 </p><ul class="list _bullet" id="-i7x40f_13792"><li class="list__item" id="-i7x40f_13793"><p><code class="code" id="-i7x40f_13794">Outer.Inner obj = Outer.new Inner();</code></p></li></ul></li></ul></li><li class="list__item" id="-i7x40f_13795"><p>局部内部类(Local classes) </p><ul class="list _bullet" id="-i7x40f_13796"><li class="list__item" id="-i7x40f_13797"><p>定义在代码块中的非静态的类,如方法,for循环,if语句等</p></li><li class="list__item" id="-i7x40f_13798"><p>定义后,即可创建对象使用</p></li><li class="list__item" id="-i7x40f_13799"><p>只能活在这个代码块中,代码块结束后,外界无法使用该类</p></li></ul></li><li class="list__item" id="-i7x40f_13800"><p>匿名内部类(Anonymous class) </p><ul class="list _bullet" id="-i7x40f_13801"><li class="list__item" id="-i7x40f_13802"><p>没有类名的内部类,必须继承一个父类/实现一个父接口</p></li><li class="list__item" id="-i7x40f_13803"><p>在实例化以后,迅速转型为父类/父接口</p></li><li class="list__item" id="-i7x40f_13804"><p>这种类型的对象,只能new一个对象,之后以对象名字操作</p></li><li class="list__item" id="-i7x40f_13805"><p>可在普通语句和成员变量赋值时使用内部类</p></li></ul></li></ul></li><li class="list__item" id="-i7x40f_13806"><p id="-i7x40f_13807">为什么需要嵌套类</p><ul class="list _bullet" id="-i7x40f_13808"><li class="list__item" id="-i7x40f_13809"><p>不同的访问权限要求,更细粒度的访问控制</p></li><li class="list__item" id="-i7x40f_13810"><p>简介,避免过多的类定义</p></li><li class="list__item" id="-i7x40f_13811"><p>语言设计过于复杂,较难学习和使用</p></li></ul><div class="table-wrapper"><table class="wide" id="-i7x40f_13812"><thead><tr class="ijRowHead" id="-i7x40f_13813"><th id="-i7x40f_13814"></th><th id="-i7x40f_13815"><p>位置</p></th><th id="-i7x40f_13816"><p>名字(编译后的class文件)</p></th><th id="-i7x40f_13817"><p>作用范围</p></th><th id="-i7x40f_13818"><p>基本信息</p></th><th id="-i7x40f_13819"><p>嵌套类内部的内容</p></th><th id="-i7x40f_13820"><p>可访问的外部包围类的内容</p></th><th id="-i7x40f_13821"><p>和外部类的关系</p></th></tr></thead><tbody><tr id="-i7x40f_13822"><td id="-i7x40f_13823"><p>匿名内部类</p></td><td id="-i7x40f_13824"><p>成员变量或者成员方法内</p></td><td id="-i7x40f_13825"><p>外部类名+$+数字编号</p></td><td id="-i7x40f_13826"><p>跟随被复制变量的作用范围, </p><br><p> 外界无法访问</p></td><td id="-i7x40f_13828"><p>没有类名,没有构造函数</p><br><p> 没有static,private/default/protected/public修饰</p></td><td id="-i7x40f_13830"><p>不能带静态成员</p></td><td id="-i7x40f_13831"><p>访问外部的所有成员</p></td><td id="-i7x40f_13832"><p>在外部类对象内部</p></td></tr><tr id="-i7x40f_13833"><td id="-i7x40f_13834"><p>局部内部类</p></td><td id="-i7x40f_13835"><p>成员方法内</p></td><td id="-i7x40f_13836"><p>外部类名+$+序号+内部类名</p></td><td id="-i7x40f_13837"><p>所在的方法内</p><br><p> 外界无法访问</p></td><td id="-i7x40f_13839"><p>有类名,有构造函数</p><br><p> 没有static,private/default/protected/public修饰</p></td><td id="-i7x40f_13841"><p>不能带静态成员,除了常量</p></td><td id="-i7x40f_13842"><p>访问外部的所有成员</p></td><td id="-i7x40f_13843"><p>在外部类的对象内部</p></td></tr><tr id="-i7x40f_13844"><td id="-i7x40f_13845"><p>普通内部类</p></td><td id="-i7x40f_13846"><p>成员变量</p></td><td id="-i7x40f_13847"><p>外部类名+$+内部类名</p></td><td id="-i7x40f_13848"><p>包围类内可以访问, </p><br><p> 外界可以访问</p></td><td id="-i7x40f_13850"><p>有类名,有构造函数</p><br><p> 没有static,private/default/protected/public修饰</p></td><td id="-i7x40f_13852"><p>不能带静态成员,除了常量</p></td><td id="-i7x40f_13853"><p>访问外部的所有成员</p></td><td id="-i7x40f_13854"><p>外界可以new, </p><br><p> 但是必须依附于一个外部包围类对象</p></td></tr><tr id="-i7x40f_13856"><td id="-i7x40f_13857"><p>静态嵌套类</p></td><td id="-i7x40f_13858"><p>成员变量</p></td><td id="-i7x40f_13859"><p>外部类名+$+内部类名</p></td><td id="-i7x40f_13860"><p>包围类内部可以访问, </p><br><p> 外界可以访问</p></td><td id="-i7x40f_13862"><p>有类名,有构造函数</p><br><p> 有static,private/default/protected/public修饰</p></td><td id="-i7x40f_13864"><p>可以定义静态成员变量和方法</p></td><td id="-i7x40f_13865"><p>访问外部的所有静态成员</p></td><td id="-i7x40f_13866"><p>可以new,可独立进行工作</p></td></tr></tbody></table></div></li><li class="list__item" id="-i7x40f_13867"><p id="-i7x40f_13868">变量遮蔽:Shadowing</p><ul class="list _bullet" id="-i7x40f_13869"><li class="list__item" id="-i7x40f_13870"><p>嵌套类变量和外部包围类的变量重名 </p><ul class="list _bullet" id="-i7x40f_13871"><li class="list__item" id="-i7x40f_13872"><p>以离得近作为优先原则</p></li><li class="list__item" id="-i7x40f_13873"><p>优先级高的变量回遮蔽优先级低的变量</p></li><li class="list__item" id="-i7x40f_13874"><p>外部包围类.this.变量名,可以访问到外部包围类的成员变量</p></li><li class="list__item" id="-i7x40f_13875"><p>静态嵌套类不能访问非静态变量</p></li><li class="list__item" id="-i7x40f_13876"><p>Java7及以前,匿名内部类和局部内部类只能访问外部包围类的final成员变量</p></li><li class="list__item" id="-i7x40f_13877"><p>Java8及以后,匿名内部类和局部内部类可以访问外部包围类的final成员变量和 事实意义上的final变量(effectively final,一个变量定值后,再也没有改过值)</p></li></ul></li></ul></li></ul></section><section class="chapter"><h2 id="lambda" data-toc="lambda">Lambda表达式</h2><ul class="list _bullet" id="-i7x40f_13878"><li class="list__item" id="-i7x40f_13879"><p>参数,箭头,一个表达式</p></li><li class="list__item" id="-i7x40f_13880"><p>参数,箭头,{多个语句}</p></li><li class="list__item" id="-i7x40f_13881"><p>类似于匿名方法,一个没有名字的方法</p></li><li class="list__item" id="-i7x40f_13882"><p>参数,箭头,表达式语句</p></li><li class="list__item" id="-i7x40f_13883"><p>可以忽略写参数类型</p></li><li class="list__item" id="-i7x40f_13884"><p>坚决不声明返回值类型</p></li><li class="list__item" id="-i7x40f_13885"><p>没有public/protected/private/static/final等修饰符</p></li><li class="list__item" id="-i7x40f_13886"><p>单句表达式,将直接返回值,不用大括号</p></li><li class="list__item" id="-i7x40f_13887"><p>带return语句,算多句,必须用大括号</p></li></ul><section class="chapter"><h3 id="-i7x40f_13888" data-toc="-i7x40f_13888">函数式接口</h3><ul class="list _bullet" id="-i7x40f_13889"><li class="list__item" id="-i7x40f_13890"><p>是一个接口,符合Java接口的定义</p></li><li class="list__item" id="-i7x40f_13891"><p>只包含一个抽象方法的接口</p></li><li class="list__item" id="-i7x40f_13892"><p>可以包含其他的default方法,static方法,private方法</p></li><li class="list__item" id="-i7x40f_13893"><p>由于只有一个未实现的方法,所以Lambda表达式可以自动填上这个尚未实现的方法</p></li><li class="list__item" id="-i7x40f_13894"><p>采用Lambda表达式,可以自动创建出一个(伪)嵌套类的对象(没有实际嵌套类class文件产生),然后使用, 比真正嵌套类更加轻量,更加简洁高效</p></li></ul><div class="code-block" data-lang="java">
package notes.Java.Java_Final.Lambda;
@FunctionalInterface
//标记为函数式接口
public interface StringChecker {
    public boolean test(String s);
}

</div><div class="code-block" data-lang="java">
package notes.Java.Java_Final.Lambda;

/**
 * @Description:
 * @author: Anhlaidh
 * @date: 2020-08-06 21:38
 */
public class Main {
    public static void main(String[] args) {
        String[] s = new String[]{&quot;aaa&quot;, &quot;bbbb&quot;, &quot;cccccc&quot;};
        StringChecker eventLength = s1 -&gt; {
            if (s1.length() % 2 == 0) {
                return true;
            }
            return false;
        };

        for (String p : s) {
            if (eventLength.test(p)) {
                System.out.println(p);

            }
        }
    }

}

</div></section><section class="chapter"><h3 id="-i7x40f_13897" data-toc="-i7x40f_13897">系统自带的函数式接口</h3><div class="table-wrapper"><table class="wide" id="-i7x40f_13898"><thead><tr class="ijRowHead" id="-i7x40f_13899"><th id="-i7x40f_13900"><p>接口</p></th><th id="-i7x40f_13901"><p>参数</p></th><th id="-i7x40f_13902"><p>返回值</p></th><th id="-i7x40f_13903"><p>实例</p></th></tr></thead><tbody><tr id="-i7x40f_13904"><td id="-i7x40f_13905"><p>Predicate</p></td><td id="-i7x40f_13907"><p>T</p></td><td id="-i7x40f_13908"><p>Boolean</p></td><td id="-i7x40f_13909"><p>接收一个参数,返回一个boolean</p></td></tr><tr id="-i7x40f_13910"><td id="-i7x40f_13911"><p>Consumer</p></td><td id="-i7x40f_13913"><p>T</p></td><td id="-i7x40f_13914"><p>void</p></td><td id="-i7x40f_13915"><p>接受一个参数,无返回</p></td></tr><tr id="-i7x40f_13916"><td id="-i7x40f_13917"><p>Function&lt;T,R&gt;</p></td><td id="-i7x40f_13918"><p>T</p></td><td id="-i7x40f_13919"><p>R</p></td><td id="-i7x40f_13920"><p>接受一个参数,返回一个值</p></td></tr><tr id="-i7x40f_13921"><td id="-i7x40f_13922"><p>Supplier</p></td><td id="-i7x40f_13924"><p>None</p></td><td id="-i7x40f_13925"><p>T</p></td><td id="-i7x40f_13926"><p>数据工厂</p></td></tr></tbody></table></div></section><section class="chapter"><h3 id="-i7x40f_13927" data-toc="-i7x40f_13927">方法引用</h3><ul class="list _bullet" id="-i7x40f_13928"><li class="list__item" id="-i7x40f_13929"><p>Class::staticMethod</p></li></ul><div class="code-block" data-lang="java">
package notes.Java.Java_Final.Lambda;

/**
 * @Description:
 * @author: Anhlaidh
 * @date: 2020-08-06 22:26
 */
public class method {
    public static void main(String[] args) {
        double a = -3.5;
        double b = worker(Math::abs, a);
        System.out.println(b);
        double c = worker(Math::floor, a);
        System.out.println(c);
        double d = worker((num -&gt; (num % 10)), a);
        System.out.println(d);

    }

    public static double worker(NumFunction nf, double num) {
        return nf.calculate(num);
    }
}

</div><ul class="list _bullet" id="-i7x40f_13931"><li class="list__item" id="-i7x40f_13932"><p>Class::instanceMethod </p><ul class="list _bullet" id="-i7x40f_13933"><li class="list__item" id="-i7x40f_13934"><p>第一个参数将变成方法的执行体</p></li><li class="list__item" id="-i7x40f_13935"><p>String::compareToIgnoreCase等价于(x,y)-&gt;x.compareToIgnoreCase(y)</p></li><li class="list__item" id="-i7x40f_13936"><div class="code-block" data-lang="none">
    String[] planets = new String[]{&quot;DDD&quot;,&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;};
    Arrays.sort(planets, String::compareToIgnoreCase);
    System.out.println(Arrays.toString(planets));
</div></li></ul></li><li class="list__item" id="-i7x40f_13938"><p>object::instanceMethod </p><ul class="list _bullet" id="-i7x40f_13939"><li class="list__item" id="-i7x40f_13940"><p>支持this::instanceMethod</p></li><li class="list__item" id="-i7x40f_13941"><p>支持super::instanceMethod</p></li></ul></li><li class="list__item" id="-i7x40f_13942"><p>Class::new,调用某类构造函数,支持单个对象构建</p></li><li class="list__item" id="-i7x40f_13943"><p>Class[]::new,调用某类构造函数,支持数组对象构建</p></li><li class="list__item" id="-i7x40f_13944"><p>应用</p></li></ul><div class="code-block" data-lang="java">
package notes.Java.Java_Final.Lambda;

import java.util.ArrayList;
import java.util.Arrays;

/**
 * @Description:
 * @author: Anhlaidh
 * @date: 2020-08-07 15:06
 */
public class testIterable {
    public static void main(String[] args) {
        String[] p = new String[]{&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;};
        ArrayList&lt;String&gt; pList = new ArrayList&lt;String&gt;(Arrays.asList(p));
        for (String s : pList) {
            System.out.println(s);
        }
        pList.forEach(System.out::println);

    }
}

</div></section></section><section class="chapter"><h2 id="stream" data-toc="stream">流 stream</h2><ul class="list _bullet" id="-i7x40f_13946"><li class="list__item" id="-i7x40f_13947"><p>sequence of elements:一个流对外提供一个接口,可以访问到一串特定的数据,流不存储元素,但是可以根据需要进行计算转化</p></li><li class="list__item" id="-i7x40f_13948"><p>source:数据来源,如数据结构,数组,文件等</p></li><li class="list__item" id="-i7x40f_13949"><p>aggregate operation:聚合操作,流支持像SQL操作或者其他函数式语言的操作 如filter/map/reduce/find/match/sorted等</p></li><li class="list__item" id="-i7x40f_13950"><p>Stream流 </p><ul class="list _bullet" id="-i7x40f_13951"><li class="list__item" id="-i7x40f_13952"><p>pipelining:很多流操作也是返回一个流</p></li><li class="list__item" id="-i7x40f_13953"><p>Internal Iteration:流操作进行迭代,用户感知不到循环遍历</p></li></ul></li></ul><section class="chapter"><h3 id="-i7x40f_13954" data-toc="-i7x40f_13954">流的工作流程</h3><ol class="list _decimal" id="-i7x40f_13955" type="1"><li class="list__item" id="-i7x40f_13956"><p>流的创建 </p><ul class="list _bullet" id="-i7x40f_13957"><li class="list__item" id="-i7x40f_13958"><p>Collection接口的stream方法</p></li><li class="list__item" id="-i7x40f_13959"><p>Arrays.stream(数组)</p></li><li class="list__item" id="-i7x40f_13960"><p>Stream.of()</p></li><li class="list__item" id="-i7x40f_13961"><p>empty() 空流</p></li><li class="list__item" id="-i7x40f_13962"></li></ul></li><li class="list__item" id="-i7x40f_13963"><p>流的转换,将流转换为其他流的中间操作,可包括多个步骤(惰性操作)</p></li><li class="list__item" id="-i7x40f_13964"><p>流的计算结果,这个操作会强制执行之前的惰性操作,这个步骤以后,流就再也不用了</p></li></ol></section></section><div class="last-modified">Last modified: 30 四月 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="java-2.html" class="navigation-links__prev">Java-2</a><a href="jvm-2.html" class="navigation-links__next">JVM</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b259/app.js"></script></body></html>