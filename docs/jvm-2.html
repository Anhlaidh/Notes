<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2024-04-30T19:18:20.902449"><title>JVM | Notes</title><script type="application/json" id="virtual-toc-data">[{"id":"-3fhklu_2525","level":0,"title":"概念","anchor":"#-3fhklu_2525"},{"id":"class-file-format","level":0,"title":"Class File Format","anchor":"#class-file-format"},{"id":"class-loading-linking-initializing","level":0,"title":"Class Loading Linking Initializing","anchor":"#class-loading-linking-initializing"},{"id":"jmm-java-memory-model","level":0,"title":"JMM java memory model","anchor":"#jmm-java-memory-model"},{"id":"jvm-runtime-data-area-jvm-instructions","level":0,"title":"JVM Runtime Data Area \u0026\u0026 JVM Instructions","anchor":"#jvm-runtime-data-area-jvm-instructions"},{"id":"garbage-collector-gc-tuning","level":0,"title":"Garbage Collector \u0026\u0026 GC tuning","anchor":"#garbage-collector-gc-tuning"},{"id":"gc","level":0,"title":"GC 调优","anchor":"#gc"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b259/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="JVM | Notes"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Notes Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/notes/0.1/jvm-2.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="JVM | Notes"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/notes/0.1/jvm-2.html#webpage",
    "url": "writerside-documentation/notes/0.1/jvm-2.html",
    "name": "JVM | Notes",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentationnotes/#website",
    "url": "writerside-documentationnotes/",
    "name": "Notes Help"
}</script><!-- End Schema.org --></head><body data-id="JVM-2" data-main-title="JVM" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="README.md|Notes///java///notes///Java"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Notes 0.1 Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="JVM-2" id="JVM-2.md">JVM</h1><section class="chapter"><h2 id="-3fhklu_2525" data-toc="-3fhklu_2525">概念</h2><ul class="list _bullet" id="-3fhklu_2526"><li class="list__item" id="-3fhklu_2527"><p>jvm跟java无关 </p><ul class="list _bullet" id="-3fhklu_2528"><li class="list__item" id="-3fhklu_2529"><p>任何语言-&gt;class-&gt;JVM</p></li></ul></li><li class="list__item" id="-3fhklu_2530"><p>jvm是一种规范</p></li><li class="list__item" id="-3fhklu_2531"><p>虚构出来的计算机 </p><ul class="list _bullet" id="-3fhklu_2532"><li class="list__item" id="-3fhklu_2533"><p>字节码指令集(汇编语言)</p></li><li class="list__item" id="-3fhklu_2534"><p>内存管理:栈 堆 方法区等</p></li></ul></li><li class="list__item" id="-3fhklu_2535"><p>常见的JVM实现 </p><ul class="list _bullet" id="-3fhklu_2536"><li class="list__item" id="-3fhklu_2537"><p>Hotspot </p><ul class="list _bullet" id="-3fhklu_2538"><li class="list__item" id="-3fhklu_2539"><p>Oracle官方,做实验用的jvm</p></li></ul></li><li class="list__item" id="-3fhklu_2540"><p>Jrockit </p><ul class="list _bullet" id="-3fhklu_2541"><li class="list__item" id="-3fhklu_2542"><p>BEA,最快jvm</p></li><li class="list__item" id="-3fhklu_2543"><p>被Oracle收购,合并于hotspot</p></li></ul></li><li class="list__item" id="-3fhklu_2544"><p>TaoBaoVM </p><ul class="list _bullet" id="-3fhklu_2545"><li class="list__item" id="-3fhklu_2546"><p>hotspot深度定制版</p></li></ul></li><li class="list__item" id="-3fhklu_2547"><p>LiquidVM </p><ul class="list _bullet" id="-3fhklu_2548"><li class="list__item" id="-3fhklu_2549"><p>直接针对硬件</p></li></ul></li><li class="list__item" id="-3fhklu_2550"><p>azul zing </p><ul class="list _bullet" id="-3fhklu_2551"><li class="list__item" id="-3fhklu_2552"><p>垃圾回收的业界标杆</p></li></ul></li><li class="list__item" id="-3fhklu_2553"><p>J9 -IBM</p></li><li class="list__item" id="-3fhklu_2554"><p>Microsoft VM</p></li></ul></li><li class="list__item" id="-3fhklu_2555"><p>JDK JRE JVM </p><ul class="list _bullet" id="-3fhklu_2556"><li class="list__item" id="-3fhklu_2557"><p>JDK = jre + development kit</p></li><li class="list__item" id="-3fhklu_2558"><p>JRE = jvm + core lib</p></li><li class="list__item" id="-3fhklu_2559"><p>JVM</p></li></ul></li></ul></section><section class="chapter"><h2 id="class-file-format" data-toc="class-file-format">Class File Format</h2><ul class="list _bullet" id="-3fhklu_2560"><li class="list__item" id="-3fhklu_2561"><p id="-3fhklu_2562">二进制字节流</p></li><li class="list__item" id="-3fhklu_2563"><p id="-3fhklu_2564">数据类型 u1 u2 u4 u8 和_info</p></li><li class="list__item" id="-3fhklu_2565"><p id="-3fhklu_2566">前八个16进制-&gt;magic version</p></li><li class="list__item" id="-3fhklu_2567"><p id="-3fhklu_2568">然后八个16进制-&gt;minor version</p></li><li class="list__item" id="-3fhklu_2569"><p id="-3fhklu_2570">然后四个16进制(2个字节)-&gt; constant_pool_count</p><ul class="list _bullet" id="-3fhklu_2571"><li class="list__item" id="-3fhklu_2572"><p>常量池</p></li></ul></li><li class="list__item" id="-3fhklu_2573"><p id="-3fhklu_2574">紧接constant_pool *</p><ul class="list _bullet" id="-3fhklu_2575"><li class="list__item" id="-3fhklu_2576"><p>长度为constant_pool_count-1的表,从1开始,保留0</p></li></ul></li><li class="list__item" id="-3fhklu_2577"><p id="-3fhklu_2578">access_flags 定义类的那一排所代表的,例如public,final,implement,annotation</p></li><li class="list__item" id="-3fhklu_2579"><p id="-3fhklu_2580">this_class</p><ul class="list _bullet" id="-3fhklu_2581"><li class="list__item" id="-3fhklu_2582"><p>当前class文件</p></li></ul></li><li class="list__item" id="-3fhklu_2583"><p id="-3fhklu_2584">super_class</p></li><li class="list__item" id="-3fhklu_2585"><p id="-3fhklu_2586">interfaces_count</p></li><li class="list__item" id="-3fhklu_2587"><p id="-3fhklu_2588">interfaces</p></li><li class="list__item" id="-3fhklu_2589"><p id="-3fhklu_2590">fields_count</p></li><li class="list__item" id="-3fhklu_2591"><p id="-3fhklu_2592">fields</p></li><li class="list__item" id="-3fhklu_2593"><p id="-3fhklu_2594">methods_count</p></li><li class="list__item" id="-3fhklu_2595"><p id="-3fhklu_2596">methods</p><ul class="list _bullet" id="-3fhklu_2597"><li class="list__item" id="-3fhklu_2598"><p>access_flags</p></li><li class="list__item" id="-3fhklu_2599"><p>name_index u2</p></li><li class="list__item" id="-3fhklu_2600"><p>descriptor_index u2</p></li><li class="list__item" id="-3fhklu_2601"><p>attributes_count</p></li><li class="list__item" id="-3fhklu_2602"><p>attributes</p></li></ul></li><li class="list__item" id="-3fhklu_2603"><p id="-3fhklu_2604">attributes_count -u2</p></li><li class="list__item" id="-3fhklu_2605"><p id="-3fhklu_2606">attributes</p><ul class="list _bullet" id="-3fhklu_2607"><li class="list__item" id="-3fhklu_2608"><p>code</p></li></ul></li></ul><figure id="-3fhklu_2609"><img alt="Class file" src="images/class_file.png" title="Class file" width="1302" height="667"></figure></section><section class="chapter"><h2 id="class-loading-linking-initializing" data-toc="class-loading-linking-initializing">Class Loading Linking Initializing</h2><section class="chapter"><h3 id="loading" data-toc="loading">loading</h3><ul class="list _bullet" id="-3fhklu_2610"><li class="list__item" id="-3fhklu_2611"><p>加载过程</p></li></ul><ol class="list _decimal" id="-3fhklu_2612" type="1"><li class="list__item" id="-3fhklu_2613"><p>Loading</p></li><li class="list__item" id="-3fhklu_2614"><p>Linking </p><ol class="list _decimal" id="-3fhklu_2615" type="1"><li class="list__item" id="-3fhklu_2616"><p>verification</p></li><li class="list__item" id="-3fhklu_2617"><p>preparation </p><ul class="list _bullet" id="-3fhklu_2618"><li class="list__item" id="-3fhklu_2619"><p>静态变量设初值,不是赋值</p></li></ul></li><li class="list__item" id="-3fhklu_2620"><p>resolution</p></li></ol></li><li class="list__item" id="-3fhklu_2621"><p>initializing</p></li></ol><ul class="list _bullet" id="-3fhklu_2622"><li class="list__item" id="-3fhklu_2623"><p>class在内存中的位置 </p><ul class="list _bullet" id="-3fhklu_2624"><li class="list__item" id="-3fhklu_2625"><p>根据虚拟机来不同考虑 </p><ul class="list _bullet" id="-3fhklu_2626"><li class="list__item" id="-3fhklu_2627"><p>应该是metaspace</p></li></ul></li></ul></li><li class="list__item" id="-3fhklu_2628"><p>类加载器 </p><ul class="list _bullet" id="-3fhklu_2629"><li class="list__item" id="-3fhklu_2630"><p>JVM是按需动态加载,采用双亲委派机制 为了安全 </p><ul class="list _bullet" id="-3fhklu_2631"><li class="list__item" id="-3fhklu_2632"><p>java.lang.String被自定义loader,打包后发给客户,用户输密码,密码发回来</p></li></ul></li><li class="list__item" id="-3fhklu_2633"><p>父加载器 </p><ul class="list _bullet" id="-3fhklu_2634"><li class="list__item" id="-3fhklu_2635"><p>父加载器不是&quot;类加载器的加载器&quot;类加载器都是bootstrap加载器加载的</p></li></ul></li><li class="list__item" id="-3fhklu_2636"><p>双亲委派是一个孩子向父亲方向,然后父亲向孩子方向的双亲委派过程</p></li><li class="list__item" id="-3fhklu_2637"><p>层次 </p><ul class="list _bullet" id="-3fhklu_2638"><li class="list__item" id="-3fhklu_2639"><p>bootStrap </p><ul class="list _bullet" id="-3fhklu_2640"><li class="list__item" id="-3fhklu_2641"><p>加载lib/rt.jar charset.jar核心类,c++实现</p></li></ul></li><li class="list__item" id="-3fhklu_2642"><p>Extension </p><ul class="list _bullet" id="-3fhklu_2643"><li class="list__item" id="-3fhklu_2644"><p>加载扩展jar包,jre/lib/ext/*.jar,或由-Djava.ext.dirs指定</p></li></ul></li><li class="list__item" id="-3fhklu_2645"><p>App </p><ul class="list _bullet" id="-3fhklu_2646"><li class="list__item" id="-3fhklu_2647"><p>加载classpath指定内容</p></li></ul></li><li class="list__item" id="-3fhklu_2648"><p>CustomClassLoader </p><ul class="list _bullet" id="-3fhklu_2649"><li class="list__item" id="-3fhklu_2650"><p>自定义ClassLoader</p></li></ul></li></ul></li><li class="list__item" id="-3fhklu_2651"><p>自底向上检查该类是否已经加载parent方向</p></li><li class="list__item" id="-3fhklu_2652"><p>如何打破双亲委派 </p><ol class="list _decimal" id="-3fhklu_2653" type="1"><li class="list__item" id="-3fhklu_2654"><p>如何打破:重写loadClass() </p><ul class="list _bullet" id="-3fhklu_2655"><li class="list__item" id="-3fhklu_2656"><p>tomcat是重写loadClass为先自己加载,没有则找父加载器 -&gt;热加载 每次都重新new</p></li></ul></li><li class="list__item" id="-3fhklu_2657"><p>何时打破过 </p><ul class="list _bullet" id="-3fhklu_2658"><li class="list__item" id="-3fhklu_2659"><p>jdk1.2之前,自定义ClassLoader都必须重写loadClass</p></li><li class="list__item" id="-3fhklu_2660"><p>ThreadContextClassLoader可以实现基础类调用实现类代码,通过thread.setContextClassLoader指定</p></li><li class="list__item" id="-3fhklu_2661"><p>热启动,热部署 </p><ul class="list _bullet" id="-3fhklu_2662"><li class="list__item" id="-3fhklu_2663"><p>tomcat都有自己的模块指定classloader</p></li></ul></li></ul></li></ol></li></ul></li><li class="list__item" id="-3fhklu_2664"><p>class加载生成两部分 </p><ol class="list _decimal" id="-3fhklu_2665" type="1"><li class="list__item" id="-3fhklu_2666"><p>二进制存入内存(在meta space中,指的是method area,1.8之前叫PermanentGeneration)</p></li><li class="list__item" id="-3fhklu_2667"><p>生成一个class,指向二进制内存,来读取解析二进制,反射</p></li></ol></li><li class="list__item" id="-3fhklu_2668"><p>ClassLoader源码 </p><ul class="list _bullet" id="-3fhklu_2669"><li class="list__item" id="-3fhklu_2670"><p>findClass 自己找</p></li><li class="list__item" id="-3fhklu_2671"><p>loadClass 方法过程 </p><ol class="list _decimal" id="-3fhklu_2672" type="1"><li class="list__item" id="-3fhklu_2673"><p>cache里面找</p></li><li class="list__item" id="-3fhklu_2674"><p>parent.loadClass 父类找,递归找</p></li><li class="list__item" id="-3fhklu_2675"><p>findClass 自己的findclass</p></li></ol></li><li class="list__item" id="-3fhklu_2676"><p>如果是AppClassLoader首先会执行URLClassLoader的findClass方法</p></li><li class="list__item" id="-3fhklu_2677"><p>模板模式,留钩子函数,findClass</p></li></ul></li></ul><section class="chapter"><h4 id="lazy-loading" data-toc="lazy-loading">lazy loading</h4><ul class="list _bullet" id="-3fhklu_2678"><li class="list__item" id="-3fhklu_2679"><p id="-3fhklu_2680">严格来说应该叫lazyInitializing</p></li><li class="list__item" id="-3fhklu_2681"><p id="-3fhklu_2682">JVM规范并没有规定何时加载</p></li><li class="list__item" id="-3fhklu_2683"><p id="-3fhklu_2684">但是严格规定了什么时候必须初始化</p><ul class="list _bullet" id="-3fhklu_2685"><li class="list__item" id="-3fhklu_2686"><p>new getstatic putstatic invokestatic指令,访问final变量除外</p></li><li class="list__item" id="-3fhklu_2687"><p>java.lan.reflect对类进行反射调用时</p></li><li class="list__item" id="-3fhklu_2688"><p>初始化子类的时候,父类首先初始化</p></li><li class="list__item" id="-3fhklu_2689"><p>虚拟机启动时,被执行的主类必须初始化</p></li><li class="list__item" id="-3fhklu_2690"><p>动态语言支持java.lang.invoke.MethodHandle解析的结果为REF_getstatic REF_putstatic REF_invokestatic的方法句柄时 该类必须初始化</p></li></ul></li><li class="list__item" id="-3fhklu_2691"><p id="-3fhklu_2692">读取final 值不加载类</p></li></ul></section><section class="chapter"><h4 id="-3fhklu_2693" data-toc="-3fhklu_2693">编译</h4><ul class="list _bullet" id="-3fhklu_2694"><li class="list__item" id="-3fhklu_2695"><p>混合模式 -Xmixed </p><ul class="list _bullet" id="-3fhklu_2696"><li class="list__item" id="-3fhklu_2697"><p>解释器</p></li><li class="list__item" id="-3fhklu_2698"><p>JIT(Just in Time compiler)</p></li><li class="list__item" id="-3fhklu_2699"><p>混合使用解释器+热点代码编译</p></li><li class="list__item" id="-3fhklu_2700"><p>起始阶段采用解释执行</p></li><li class="list__item" id="-3fhklu_2701"><p>热点代码检测 </p><ul class="list _bullet" id="-3fhklu_2702"><li class="list__item" id="-3fhklu_2703"><p>多次调用的方法(方法计数器:检测方法执行频率)</p></li><li class="list__item" id="-3fhklu_2704"><p>多次调用的循环(循环计数器:检测循环执行频率)</p></li><li class="list__item" id="-3fhklu_2705"><p>进行编译</p></li></ul></li></ul></li><li class="list__item" id="-3fhklu_2706"><p>-Xmixed 默认混合模式开始解释执行,启动速度较快,对热点代码实行检测和编译</p></li><li class="list__item" id="-3fhklu_2707"><p>-Xint Xint 使用解释模式,启动很快执行稍慢</p></li><li class="list__item" id="-3fhklu_2708"><p>-Xcomp Xcomp使用纯编译模式,执行很快,启动很慢 </p><ul class="list _bullet" id="-3fhklu_2709"><li class="list__item" id="-3fhklu_2710"><p>exe,elf</p></li></ul></li></ul></section></section><section class="chapter"><h3 id="linking" data-toc="linking">Linking</h3><ol class="list _decimal" id="-3fhklu_2711" type="1"><li class="list__item" id="-3fhklu_2712"><p>Verification </p><ul class="list _bullet" id="-3fhklu_2713"><li class="list__item" id="-3fhklu_2714"><p>验证文件是否符合jvm规定</p></li></ul></li><li class="list__item" id="-3fhklu_2715"><p>Preparation </p><ul class="list _bullet" id="-3fhklu_2716"><li class="list__item" id="-3fhklu_2717"><p>静态成员变量赋默认值</p></li></ul></li><li class="list__item" id="-3fhklu_2718"><p>Resolution </p><ul class="list _bullet" id="-3fhklu_2719"><li class="list__item" id="-3fhklu_2720"><p>将类,方法,属性等引用解析为直接引用 常量池中的各种符号引用解析为指针,偏移量等内存地址的直接引用</p></li></ul></li></ol><ul class="list _bullet" id="-3fhklu_2721"><li class="list__item" id="-3fhklu_2722"><p>总结 </p><ol class="list _decimal" id="-3fhklu_2723" type="1"><li class="list__item" id="-3fhklu_2724"><p>load-默认值-初始值</p></li><li class="list__item" id="-3fhklu_2725"><p>new-申请内存-默认值-初始值</p></li></ol></li></ul></section><section class="chapter"><h3 id="initializing" data-toc="initializing">initializing</h3></section></section><section class="chapter"><h2 id="jmm-java-memory-model" data-toc="jmm-java-memory-model">JMM java memory model</h2><ul class="list _bullet" id="-3fhklu_2726"><li class="list__item" id="-3fhklu_2727"><p>内存一致性 </p><ul class="list _bullet" id="-3fhklu_2728"><li class="list__item" id="-3fhklu_2729"><p>硬件层一致性 </p><ul class="list _bullet" id="-3fhklu_2730"><li class="list__item" id="-3fhklu_2731"><p id="-3fhklu_2732">busLock 总线锁 -&gt;老cpu</p></li><li class="list__item" id="-3fhklu_2733"><p id="-3fhklu_2734">MESI 等各种各样的一致性协议(MSI,MESI,MOSI,Synapse,Firefly Dragon)</p><ul class="list _bullet" id="-3fhklu_2735"><li class="list__item" id="-3fhklu_2736"><p>缓存锁</p></li><li class="list__item" id="-3fhklu_2737"><p>有些无法被缓存的数据或者跨越多个缓存行的数据依然必须使用总线锁</p></li><li class="list__item" id="-3fhklu_2738"><p>缓存行(cache line) 缓存的单位,一般为64字节 512位 </p><ul class="list _bullet" id="-3fhklu_2739"><li class="list__item" id="-3fhklu_2740"><p>伪共享 </p><ul class="list _bullet" id="-3fhklu_2741"><li class="list__item" id="-3fhklu_2742"><p>位于同一缓存行的两个不同数据,被两个cpu锁定,产生互相影响的伪共享问题 -&gt; <code class="code" id="-3fhklu_2743">JUC/falseSharing</code></p></li></ul></li><li class="list__item" id="-3fhklu_2744"><p>缓存行对齐 -&gt; 能够提高效率 </p><ul class="list _bullet" id="-3fhklu_2745"><li class="list__item" id="-3fhklu_2746"><p>甚至disruptor中就有相关操作 </p><ul class="list _bullet" id="-3fhklu_2747"><li class="list__item" id="-3fhklu_2748"><p>在cursor前后各填充了七个long来对其缓存行来提高效率</p></li></ul></li></ul></li></ul></li></ul></li><li class="list__item" id="-3fhklu_2749"><p id="-3fhklu_2750">MESI -&gt;缓存锁</p><ul class="list _bullet" id="-3fhklu_2751"><li class="list__item" id="-3fhklu_2752"><p>Modified 修改加标记,m</p></li><li class="list__item" id="-3fhklu_2753"><p>Exclusive 独享标记,e</p></li><li class="list__item" id="-3fhklu_2754"><p>shared 同时在读 ,s</p></li><li class="list__item" id="-3fhklu_2755"><p>Invalid 被别人改过了 i</p></li></ul></li><li class="list__item" id="-3fhklu_2756"><p id="-3fhklu_2757">目前数据一致性是缓存锁+总线锁</p></li></ul></li></ul></li><li class="list__item" id="-3fhklu_2758"><p>指令排序 </p><figure id="-3fhklu_2759"><img alt="Jmm" src="images/jmm.png" title="Jmm" width="507" height="546"></figure><ul class="list _bullet" id="-3fhklu_2760"><li class="list__item" id="-3fhklu_2761"><p>cpu类似内部多线程,查看没有依赖关系会乱序执行</p></li><li class="list__item" id="-3fhklu_2762"><p>乱序读合并写 <code class="code" id="-3fhklu_2763">JUC/029_WriteCombining</code>-&gt;四个超快缓存 ,四个字节</p></li><li class="list__item" id="-3fhklu_2764"><p>乱序执行JUC/jmm/Disorder</p></li></ul></li><li class="list__item" id="-3fhklu_2765"><p>保证不乱序 </p><ul class="list _bullet" id="-3fhklu_2766"><li class="list__item" id="-3fhklu_2767"><p>cpu级别内存屏障 </p><ul class="list _bullet" id="-3fhklu_2768"><li class="list__item" id="-3fhklu_2769"><p>intel 硬件内存屏障,实实在在存在的 </p><ul class="list _bullet" id="-3fhklu_2770"><li class="list__item" id="-3fhklu_2771"><p>sfence : 在sfence指令前的写操作当必须在sfence指令后的写操作前完成</p></li><li class="list__item" id="-3fhklu_2772"><p>lfence : 在lfence指令前的读操作当必须在lfence指令后的读操作前完成</p></li><li class="list__item" id="-3fhklu_2773"><p>mfence : 在mfence指令前的读写操作必须在mfence指令后的读写操作前完成</p></li><li class="list__item" id="-3fhklu_2774"><p>原子指令:例如x86上的&quot;lock&quot;,指令是一个Full Barrier,执行时会锁住内存子系统来确保执行顺序,甚至跨越 多个CPU,Software Locks通常使用了内存屏障或原子指令来实现变量可见性和保存程序顺序</p></li></ul></li><li class="list__item" id="-3fhklu_2775"><p>JVM级别(JSR133),依赖于硬件内存屏障 规范 </p><ul class="list _bullet" id="-3fhklu_2776"><li class="list__item" id="-3fhklu_2777"><p>LoadLoad屏障</p></li><li class="list__item" id="-3fhklu_2778"><p>StoreStore屏障</p></li><li class="list__item" id="-3fhklu_2779"><p>LoadStore屏障</p></li><li class="list__item" id="-3fhklu_2780"><p>StoreLoad屏障</p></li></ul></li></ul></li></ul></li><li class="list__item" id="-3fhklu_2781"><p>volatile </p><ul class="list _bullet" id="-3fhklu_2782"><li class="list__item" id="-3fhklu_2783"><p>java-&gt;class </p><ul class="list _bullet" id="-3fhklu_2784"><li class="list__item" id="-3fhklu_2785"><p>标记ACCESS_FLAG volatile</p></li></ul></li><li class="list__item" id="-3fhklu_2786"><p>jvm </p><ul class="list _bullet" id="-3fhklu_2787"><li class="list__item" id="-3fhklu_2788"><p>写操作 </p><ol class="list _decimal" id="-3fhklu_2789" type="1"><li class="list__item" id="-3fhklu_2790"><p>StoreStoreBarrier</p></li><li class="list__item" id="-3fhklu_2791"><p>volatile</p></li><li class="list__item" id="-3fhklu_2792"><p>StoreLoadBarrier</p></li></ol></li><li class="list__item" id="-3fhklu_2793"><p>读操作 </p><ol class="list _decimal" id="-3fhklu_2794" type="1"><li class="list__item" id="-3fhklu_2795"><p>LoadLoadBarrier</p></li><li class="list__item" id="-3fhklu_2796"><p>volatile</p></li><li class="list__item" id="-3fhklu_2797"><p>LoadStoreBarrier</p></li></ol></li></ul></li><li class="list__item" id="-3fhklu_2798"><p>os </p><ul class="list _bullet" id="-3fhklu_2799"><li class="list__item" id="-3fhklu_2800"><p>hsdis -hotspot dis assembler</p></li><li class="list__item" id="-3fhklu_2801"><p>Windows lock指令实现</p></li></ul></li></ul></li><li class="list__item" id="-3fhklu_2802"><p>synchronized </p><ul class="list _bullet" id="-3fhklu_2803"><li class="list__item" id="-3fhklu_2804"><p>java-&gt;class </p><ul class="list _bullet" id="-3fhklu_2805"><li class="list__item" id="-3fhklu_2806"><p>ACC_SYNCHRONIZED -代码块 </p><ol class="list _decimal" id="-3fhklu_2807" type="1"><li class="list__item" id="-3fhklu_2808"><p>monitor enter</p></li><li class="list__item" id="-3fhklu_2809"><p>代码块</p></li><li class="list__item" id="-3fhklu_2810"><p>monitor exit</p></li><li class="list__item" id="-3fhklu_2811"><p>monitor exit</p></li></ol><ul class="list _bullet" id="-3fhklu_2812"><li class="list__item" id="-3fhklu_2813"><p>可能出异常,所以一个enter对应两个exit</p></li></ul></li></ul></li><li class="list__item" id="-3fhklu_2814"><p>jvm </p><ul class="list _bullet" id="-3fhklu_2815"><li class="list__item" id="-3fhklu_2816"><p>c和c++调用了系统提供的同步机制</p></li></ul></li><li class="list__item" id="-3fhklu_2817"><p>os </p><ul class="list _bullet" id="-3fhklu_2818"><li class="list__item" id="-3fhklu_2819"><p>lock cmpchg/xx</p></li></ul></li></ul></li></ul><section class="chapter"><h3 id="-3fhklu_2820" data-toc="-3fhklu_2820">面试题</h3><ul class="list _bullet" id="-3fhklu_2821"><li class="list__item" id="-3fhklu_2822"><p>关于对象</p></li></ul><ol class="list _decimal" id="-3fhklu_2823" type="1"><li class="list__item" id="-3fhklu_2824"><p id="-3fhklu_2825">解释一下对象的创建过程</p><ol class="list _decimal" id="-3fhklu_2826" type="1"><li class="list__item" id="-3fhklu_2827"><p>class loading:类加载</p></li><li class="list__item" id="-3fhklu_2828"><p>class linking(verification preparation resolution) </p><ol class="list _decimal" id="-3fhklu_2829" type="1"><li class="list__item" id="-3fhklu_2830"><p>verification:校验文件是否为class</p></li><li class="list__item" id="-3fhklu_2831"><p>preparation: 静态变量设默认值</p></li><li class="list__item" id="-3fhklu_2832"><p>resolution :解析</p></li></ol></li><li class="list__item" id="-3fhklu_2833"><p>class initialization: 初始化,执行静态语句块</p></li><li class="list__item" id="-3fhklu_2834"><p>申请对象内存</p></li><li class="list__item" id="-3fhklu_2835"><p>成员变量赋默认值</p></li><li class="list__item" id="-3fhklu_2836"><p>调用构造方法</p><ol class="list _decimal" id="-3fhklu_2838" type="1"><li class="list__item" id="-3fhklu_2839"><p>成员变量顺序赋初始值</p></li><li class="list__item" id="-3fhklu_2840"><p>执行构造方法语句 </p><ol class="list _decimal" id="-3fhklu_2841" type="1"><li class="list__item" id="-3fhklu_2842"><p>super</p></li></ol></li></ol></li></ol></li><li class="list__item" id="-3fhklu_2843"><p id="-3fhklu_2844">对象在内存中的存储布局</p><ul class="list _bullet" id="-3fhklu_2845"><li class="list__item" id="-3fhklu_2846"><p>观察虚拟机配置 </p><ul class="list _bullet" id="-3fhklu_2847"><li class="list__item" id="-3fhklu_2848"><p>java -XX:+PrintCommandLineFlags -version</p></li></ul></li><li class="list__item" id="-3fhklu_2849"><p>普通对象 </p><ol class="list _decimal" id="-3fhklu_2850" type="1"><li class="list__item" id="-3fhklu_2851"><p>对象头: markword 8</p></li><li class="list__item" id="-3fhklu_2852"><p>ClassPointer指针: -XX:+UseCompressedClassPointers为四个字节,不开启为8字节</p></li><li class="list__item" id="-3fhklu_2853"><p>实例数据 </p><ol class="list _decimal" id="-3fhklu_2854" type="1"><li class="list__item" id="-3fhklu_2855"><p>引用类型: -XX:+UseCompressOops为四字节,不开启为8字节 Oops Ordinary Object Pointers 成员变量的指针</p></li></ol></li><li class="list__item" id="-3fhklu_2856"><p>padding对齐,8的倍数</p></li></ol></li><li class="list__item" id="-3fhklu_2857"><p>数组对象 </p><ol class="list _decimal" id="-3fhklu_2858" type="1"><li class="list__item" id="-3fhklu_2859"><p>对象头:markword 8</p></li><li class="list__item" id="-3fhklu_2860"><p>ClassPointer 指针同上</p></li><li class="list__item" id="-3fhklu_2861"><p>数组长度:4字节</p></li><li class="list__item" id="-3fhklu_2862"><p>数组数据</p></li><li class="list__item" id="-3fhklu_2863"><p>对齐8的倍数</p></li></ol></li><li class="list__item" id="-3fhklu_2864"><p>ObjectSizeAgent</p></li><li class="list__item" id="-3fhklu_2865"><p>HotSpot开启内存压缩的规则(64位) </p><ol class="list _decimal" id="-3fhklu_2866" type="1"><li class="list__item" id="-3fhklu_2867"><p>4g以下直接砍掉高32位</p></li><li class="list__item" id="-3fhklu_2868"><p>4g-32g,默认开启内存压缩ClassPointer Oops</p></li><li class="list__item" id="-3fhklu_2869"><p>32G,压缩无效,使用64位,内存不是越大越好</p></li></ol></li></ul></li><li class="list__item" id="-3fhklu_2870"><p id="-3fhklu_2871">对象头具体包括什么</p><ol class="list _decimal" id="-3fhklu_2872" type="1"><li class="list__item" id="-3fhklu_2873"><p>偏向锁</p></li><li class="list__item" id="-3fhklu_2874"><p>锁</p></li><li class="list__item" id="-3fhklu_2875"><p>HashCode </p><ul class="list _bullet" id="-3fhklu_2876"><li class="list__item" id="-3fhklu_2877"><p>31位hashcode-&gt;System.identityHashCode(...) --&gt;64位机子,32位的25位</p></li><li class="list__item" id="-3fhklu_2878"><p>按原始内容机选hashcode,重写过的hashcode方法计算的结果不会存在这里</p></li></ul></li><li class="list__item" id="-3fhklu_2879"><p>分代年龄-&gt;4bit,最大15</p></li></ol><ul class="list _bullet" id="-3fhklu_2880"><li class="list__item" id="-3fhklu_2881"><figure id="-3fhklu_2882"><img alt="Object head" src="images/ObjectHead.png" title="Object head" width="976" height="654"></figure></li></ul></li><li class="list__item" id="-3fhklu_2883"><p id="-3fhklu_2884">对象怎么定位</p><ul class="list _bullet" id="-3fhklu_2885"><li class="list__item" id="-3fhklu_2886"><p>句柄池 -&gt; gc算法方便(三色算法) </p><ul class="list _bullet" id="-3fhklu_2887"><li class="list__item" id="-3fhklu_2888"><p>两个指针 </p><ol class="list _decimal" id="-3fhklu_2889" type="1"><li class="list__item" id="-3fhklu_2890"><p>数据类型指针 T.class</p></li><li class="list__item" id="-3fhklu_2891"><p>实例数据指针</p></li></ol></li></ul></li><li class="list__item" id="-3fhklu_2892"><p>直接指针 -&gt;hotspot </p><ul class="list _bullet" id="-3fhklu_2893"><li class="list__item" id="-3fhklu_2894"><p>一个指针 </p><ul class="list _bullet" id="-3fhklu_2895"><li class="list__item" id="-3fhklu_2896"><p>指向实例数据</p></li><li class="list__item" id="-3fhklu_2897"><p>实例数据指向数据类型</p></li></ul></li></ul></li></ul></li><li class="list__item" id="-3fhklu_2898"><p id="-3fhklu_2899">对象怎么分配</p><ul class="list _bullet" id="-3fhklu_2900"><li class="list__item" id="-3fhklu_2901"><p>GC相关内容</p></li></ul></li><li class="list__item" id="-3fhklu_2902"><p id="-3fhklu_2903">Object o = new Object 在内存中占用多少字节</p></li></ol></section></section><section class="chapter"><h2 id="jvm-runtime-data-area-jvm-instructions" data-toc="jvm-runtime-data-area-jvm-instructions">JVM Runtime Data Area &amp;&amp; JVM Instructions</h2><section class="chapter"><h3 id="jvm-runtime-data-area" data-toc="jvm-runtime-data-area">JVM Runtime Data Area</h3><ul class="list _bullet" id="-3fhklu_2904"><li class="list__item" id="-3fhklu_2905"><p>PC program count 线程私有 </p><ul class="list _bullet" id="-3fhklu_2906"><li class="list__item" id="-3fhklu_2907"><p id="-3fhklu_2908">存放指令位置</p></li><li class="list__item" id="-3fhklu_2909"><p id="-3fhklu_2910">虚拟机的运行,类似于这样的循环</p><div class="code-block" data-lang="none">
while(not end)
{
取PC中的位置,找到对应位置指令
执行指令
PC++
}
</div></li></ul></li><li class="list__item" id="-3fhklu_2912"><p>Heap</p></li><li class="list__item" id="-3fhklu_2913"><p>Stack </p><ul class="list _bullet" id="-3fhklu_2914"><li class="list__item" id="-3fhklu_2915"><p>JVM stack *** 线程私有 </p><ul class="list _bullet" id="-3fhklu_2916"><li class="list__item" id="-3fhklu_2917"><p>Frame - 每个方法对应一个栈帧 </p><ol class="list _decimal" id="-3fhklu_2918" type="1"><li class="list__item" id="-3fhklu_2919"><p>Local Variables 局部变量表</p></li><li class="list__item" id="-3fhklu_2920"><p>Operand Stack 操作数栈 </p><ul class="list _bullet" id="-3fhklu_2921"><li class="list__item" id="-3fhklu_2922"><p>对于long的处理(store and load),多数虚拟机的实现都是原子的jls17.7,没必要volatile</p></li></ul></li><li class="list__item" id="-3fhklu_2923"><p>dynamic linking 动态链接 </p><ul class="list _bullet" id="-3fhklu_2924"><li class="list__item" id="-3fhklu_2925"><p>jvms 2.6.3</p></li><li class="list__item" id="-3fhklu_2926"><p>a()调用了b(),去constant_pool找b()的链接-&gt;动态链接</p></li></ul></li><li class="list__item" id="-3fhklu_2927"><p>return address </p><ul class="list _bullet" id="-3fhklu_2928"><li class="list__item" id="-3fhklu_2929"><p>a()调用b(),返回值放的位置以及继续的地址</p></li></ul></li></ol></li></ul></li><li class="list__item" id="-3fhklu_2930"><p>native method stack 线程私有</p></li></ul></li><li class="list__item" id="-3fhklu_2931"><p>method area *** 逻辑概念 </p><ul class="list _bullet" id="-3fhklu_2932"><li class="list__item" id="-3fhklu_2933"><p id="-3fhklu_2934">具体实现</p><ol class="list _decimal" id="-3fhklu_2935" type="1"><li class="list__item" id="-3fhklu_2936"><p>perm Space (&lt;1.8)</p></li></ol><ul class="list _bullet" id="-3fhklu_2937"><li class="list__item" id="-3fhklu_2938"><p>字符串常量位于PermSpace</p></li><li class="list__item" id="-3fhklu_2939"><p>FGC不会清理</p></li></ul><div class="code-block" data-lang="none">
for(;;) I i =C::n //Method Area  -&gt;OOM,1.8之后不会OOM
</div><ul class="list _bullet" id="-3fhklu_2941"><li class="list__item" id="-3fhklu_2942"><p>大小启动时指定,不能变</p></li></ul><ol class="list _decimal" id="-3fhklu_2943" type="1" start="2"><li class="list__item" id="-3fhklu_2944"><p>meta space(&gt;=1.8)</p></li></ol><ul class="list _bullet" id="-3fhklu_2945"><li class="list__item" id="-3fhklu_2946"><p>字符串常量位于堆</p></li><li class="list__item" id="-3fhklu_2947"><p>会触发FGC清理</p></li><li class="list__item" id="-3fhklu_2948"><p>不设定的话最大就是物理内存</p></li></ul></li></ul></li><li class="list__item" id="-3fhklu_2949"><p>Direct Memory </p><ul class="list _bullet" id="-3fhklu_2950"><li class="list__item" id="-3fhklu_2951"><p>JVM直接访问内存空间的内存,不用再复制到jvm</p></li><li class="list__item" id="-3fhklu_2952"><p>nio,提高效率,实现zero copy</p></li></ul></li></ul></section><section class="chapter"><h3 id="jvm-instructions" data-toc="jvm-instructions">JVM Instructions</h3><ul class="list _bullet" id="-3fhklu_2953"><li class="list__item" id="-3fhklu_2954"><p>store</p></li><li class="list__item" id="-3fhklu_2955"><p>load</p></li><li class="list__item" id="-3fhklu_2956"><p>pop</p></li><li class="list__item" id="-3fhklu_2957"><p>add</p></li><li class="list__item" id="-3fhklu_2958"><p>mul ...</p></li><li class="list__item" id="-3fhklu_2959"><p>invoke </p><ol class="list _decimal" id="-3fhklu_2960" type="1"><li class="list__item" id="-3fhklu_2961"><p>invokeStatic </p><ul class="list _bullet" id="-3fhklu_2962"><li class="list__item" id="-3fhklu_2963"><p>调用静态方法</p></li></ul></li><li class="list__item" id="-3fhklu_2964"><p>invokeVirtual </p><ul class="list _bullet" id="-3fhklu_2965"><li class="list__item" id="-3fhklu_2966"><p>自带多态</p></li><li class="list__item" id="-3fhklu_2967"><p>final方法</p></li></ul></li><li class="list__item" id="-3fhklu_2968"><p>invokeInterface</p></li><li class="list__item" id="-3fhklu_2969"><p>invokeSpecial </p><ul class="list _bullet" id="-3fhklu_2970"><li class="list__item" id="-3fhklu_2971"><p>可以直接定位的 </p><ul class="list _bullet" id="-3fhklu_2972"><li class="list__item" id="-3fhklu_2973"><p>private 方法,init</p></li></ul></li></ul></li><li class="list__item" id="-3fhklu_2974"><p>invokeDynamic </p><ul class="list _bullet" id="-3fhklu_2975"><li class="list__item" id="-3fhklu_2976"><p>JVM最难指令</p></li><li class="list__item" id="-3fhklu_2977"><p>lambda表达式</p></li><li class="list__item" id="-3fhklu_2978"><p>反射</p></li><li class="list__item" id="-3fhklu_2979"><p>其他动态语言,scala,kotlin,CGLib ASM动态产生的class会用到的指令</p></li></ul></li></ol></li></ul></section></section><section class="chapter"><h2 id="garbage-collector-gc-tuning" data-toc="garbage-collector-gc-tuning">Garbage Collector &amp;&amp; GC tuning</h2><ul class="list _bullet" id="-3fhklu_2980"><li class="list__item" id="-3fhklu_2981"><p>垃圾 -&gt; 孤儿</p></li></ul><section class="chapter"><h3 id="how-to-find-a-garbage" data-toc="how-to-find-a-garbage">how to find a garbage</h3><ul class="list _bullet" id="-3fhklu_2982"><li class="list__item" id="-3fhklu_2983"><p>reference count 引用计数 python </p><ul class="list _bullet" id="-3fhklu_2984"><li class="list__item" id="-3fhklu_2985"><p>循环引用不能解决</p></li></ul></li><li class="list__item" id="-3fhklu_2986"><p>root Searching 根可达算法 java </p><ul class="list _bullet" id="-3fhklu_2987"><li class="list__item" id="-3fhklu_2988"><p>根对象 </p><ol class="list _decimal" id="-3fhklu_2989" type="1"><li class="list__item" id="-3fhklu_2990"><p>线程栈变量</p></li><li class="list__item" id="-3fhklu_2991"><p>静态变量</p></li><li class="list__item" id="-3fhklu_2992"><p>常量池</p></li><li class="list__item" id="-3fhklu_2993"><p>JNI指针 -&gt;native</p></li></ol></li></ul></li></ul></section><section class="chapter"><h3 id="gc-algorithms" data-toc="gc-algorithms">GC Algorithms</h3><ul class="list _bullet" id="-3fhklu_2994"><li class="list__item" id="-3fhklu_2995"><p>Mark-Sweep(标记清除) </p><figure id="-3fhklu_2996"><img alt="Mark sweep" src="images/Mark-Sweep.png" title="Mark sweep" width="988" height="660"></figure><ul class="list _bullet" id="-3fhklu_2997"><li class="list__item" id="-3fhklu_2998"><p>算法相对简单</p></li><li class="list__item" id="-3fhklu_2999"><p>存活对象比较多的情况下效率较高</p></li><li class="list__item" id="-3fhklu_3000"><p>两遍扫描,效率偏低</p></li><li class="list__item" id="-3fhklu_3001"><p>容易产生碎片</p></li></ul></li><li class="list__item" id="-3fhklu_3002"><p>Copying(拷贝) </p><figure id="-3fhklu_3003"><img alt="Copying" src="images/Copying.png" title="Copying" width="985" height="583"></figure><ul class="list _bullet" id="-3fhklu_3004"><li class="list__item" id="-3fhklu_3005"><p>适用于存活对象较少的情况,只扫描一次,效率高,没有碎片</p></li><li class="list__item" id="-3fhklu_3006"><p>空间浪费</p></li><li class="list__item" id="-3fhklu_3007"><p>移动复制对象,需要调整对象引用</p></li></ul></li><li class="list__item" id="-3fhklu_3008"><p>Mark-Compact(标记压缩) <img alt="mark compact" src="${primarySource}" class="inline-icon-" title="mark compact" id="-3fhklu_3009"></p><ul class="list _bullet" id="-3fhklu_3010"><li class="list__item" id="-3fhklu_3011"><p>不会产生碎片,方便对象分配</p></li><li class="list__item" id="-3fhklu_3012"><p>不会产生内存减半</p></li><li class="list__item" id="-3fhklu_3013"><p>扫描两次</p></li><li class="list__item" id="-3fhklu_3014"><p>需要移动对象,效率偏低</p></li></ul></li></ul></section><section class="chapter"><h3 id="-3fhklu_3015" data-toc="-3fhklu_3015">堆内存逻辑分区(不适用部分带垃圾收集器)</h3><ul class="list _bullet" id="-3fhklu_3016"><li class="list__item" id="-3fhklu_3017"><p>部分垃圾回收器使用的模型 </p><ul class="list _bullet" id="-3fhklu_3018"><li class="list__item" id="-3fhklu_3019"><p>除了Epsilon ZGC Shenandoah之外的GC都是使用逻辑分代模型</p></li><li class="list__item" id="-3fhklu_3020"><p>G1是逻辑分代,物理不分代</p></li><li class="list__item" id="-3fhklu_3021"><p>除此之外,不仅逻辑分代,而且物理分代 </p><figure id="-3fhklu_3022"><img alt="Heap memery" src="images/heapMemery.png" title="Heap memery" width="1458" height="645"></figure></li></ul></li><li class="list__item" id="-3fhklu_3023"><p>内存分配 </p><ul class="list _bullet" id="-3fhklu_3024"><li class="list__item" id="-3fhklu_3025"><p><a href="https://ke.qq.com/webcourse/index.html#cid=398381&amp;term_id=100475149&amp;taid=4067286785070125&amp;type=1024&amp;vid=5285890796770442292" id="-3fhklu_3026" data-external="true" rel="noopener noreferrer">方法区,永久区,元空间...</a> 30:00</p></li></ul><ol class="list _decimal" id="-3fhklu_3027" type="1"><li class="list__item" id="-3fhklu_3028"><p>栈上分配 </p><ul class="list _bullet" id="-3fhklu_3029"><li class="list__item" id="-3fhklu_3030"><p>线程私有对象</p></li><li class="list__item" id="-3fhklu_3031"><p>无逃逸</p></li><li class="list__item" id="-3fhklu_3032"><p>支持标量替换</p></li><li class="list__item" id="-3fhklu_3033"><p>无需调整</p></li></ul></li><li class="list__item" id="-3fhklu_3034"><p>线程本地分配TLAB(Thread Local Allocation Buffer) </p><ul class="list _bullet" id="-3fhklu_3035"><li class="list__item" id="-3fhklu_3036"><p>占用eden,默认1%</p></li><li class="list__item" id="-3fhklu_3037"><p>多线程的时候不用竞争eden就可以申请空间,提高效率</p></li><li class="list__item" id="-3fhklu_3038"><p>小对象</p></li><li class="list__item" id="-3fhklu_3039"><p>无需调整</p></li></ul></li><li class="list__item" id="-3fhklu_3040"><p>老年代 </p><ul class="list _bullet" id="-3fhklu_3041"><li class="list__item" id="-3fhklu_3042"><p>大对象</p></li></ul></li><li class="list__item" id="-3fhklu_3043"><p>eden</p></li></ol></li><li class="list__item" id="-3fhklu_3044"><p>对象何时进入老年代 </p><ol class="list _decimal" id="-3fhklu_3045" type="1"><li class="list__item" id="-3fhklu_3046"><p>超过 <code class="code" id="-3fhklu_3047">XX:MaxTenuringThreshold</code> 指定次数(YGC) </p><ul class="list _bullet" id="-3fhklu_3048"><li class="list__item" id="-3fhklu_3049"><p>Parallel Scavenge 15</p></li><li class="list__item" id="-3fhklu_3050"><p>CMS 6</p></li><li class="list__item" id="-3fhklu_3051"><p>G1 15 git config --global http.proxy 'socks5://127.0.0.1:1080' git config --global https.proxy 'socks5://127.0.0.1:1080'</p></li></ul></li><li class="list__item" id="-3fhklu_3052"><p>动态年龄 </p><ul class="list _bullet" id="-3fhklu_3053"><li class="list__item" id="-3fhklu_3054"><p>s1 -&gt;s2超过50%</p></li><li class="list__item" id="-3fhklu_3055"><p>把年龄最大的放入O </p><figure id="-3fhklu_3056"><img alt="Object birth" src="images/ObjectBirth.png" title="Object birth" width="1691" height="690"></figure></li></ul></li></ol></li><li class="list__item" id="-3fhklu_3057"><p>分配担保 </p><ul class="list _bullet" id="-3fhklu_3058"><li class="list__item" id="-3fhklu_3059"><p>YGC期间 survivor区空间不够了 空间担保直接进入老年代</p></li></ul></li></ul></section><section class="chapter"><h3 id="-3fhklu_3060" data-toc="-3fhklu_3060">垃圾回收器</h3><figure id="-3fhklu_3061"><img alt="Garbage collectors" src="images/garbageCollectors.png" title="Garbage collectors" width="1672" height="626"></figure><ul class="list _bullet" id="-3fhklu_3062"><li class="list__item" id="-3fhklu_3063"><p>Serial </p><ul class="list _bullet" id="-3fhklu_3064"><li class="list__item" id="-3fhklu_3065"><p>stw</p></li><li class="list__item" id="-3fhklu_3066"><p>mark-sweep-compact ?</p></li><li class="list__item" id="-3fhklu_3067"><p>safe point 完成必要的事情</p></li><li class="list__item" id="-3fhklu_3068"><p>老gc,处理空间小,大了则stw时间特别长</p></li></ul></li><li class="list__item" id="-3fhklu_3069"><p>SerialOld 老年代 </p><ul class="list _bullet" id="-3fhklu_3070"><li class="list__item" id="-3fhklu_3071"><p>stw</p></li><li class="list__item" id="-3fhklu_3072"><p>mark-sweep-compact 标记压缩</p></li><li class="list__item" id="-3fhklu_3073"><p>single GC thread</p></li></ul></li><li class="list__item" id="-3fhklu_3074"><p>Parallel Scavenge </p><ul class="list _bullet" id="-3fhklu_3075"><li class="list__item" id="-3fhklu_3076"><p>stw</p></li><li class="list__item" id="-3fhklu_3077"><p>copying</p></li><li class="list__item" id="-3fhklu_3078"><p>multiple GC</p></li></ul></li><li class="list__item" id="-3fhklu_3079"><p>Parallel old </p><ul class="list _bullet" id="-3fhklu_3080"><li class="list__item" id="-3fhklu_3081"><p>stw</p></li><li class="list__item" id="-3fhklu_3082"><p>compacting</p></li><li class="list__item" id="-3fhklu_3083"><p>multiple GC</p></li></ul></li><li class="list__item" id="-3fhklu_3084"><p>Parallel new </p><ul class="list _bullet" id="-3fhklu_3085"><li class="list__item" id="-3fhklu_3086"><p>stw</p></li><li class="list__item" id="-3fhklu_3087"><p>copying</p></li><li class="list__item" id="-3fhklu_3088"><p>multiple gc</p></li><li class="list__item" id="-3fhklu_3089"><p>加强版PS,配合CMS用的变种 </p><ul class="list _bullet" id="-3fhklu_3090"><li class="list__item" id="-3fhklu_3091"><p>PN:响应时间优先</p></li><li class="list__item" id="-3fhklu_3092"><p>PS:吞吐量优先</p></li></ul></li></ul></li><li class="list__item" id="-3fhklu_3093"><p>G1(10ms) </p><ul class="list _bullet" id="-3fhklu_3094"><li class="list__item" id="-3fhklu_3095"><p>算法:三色标记+SATB</p></li></ul></li><li class="list__item" id="-3fhklu_3096"><p>ZGC(1ms) PK C++ </p><ul class="list _bullet" id="-3fhklu_3097"><li class="list__item" id="-3fhklu_3098"><p>算法:ColoredPointers+写屏障</p></li></ul></li><li class="list__item" id="-3fhklu_3099"><p>Shenandoah </p><ul class="list _bullet" id="-3fhklu_3100"><li class="list__item" id="-3fhklu_3101"><p>算法:ColoredPointer+读屏障</p></li></ul></li><li class="list__item" id="-3fhklu_3102"><p>Epsilon</p></li><li class="list__item" id="-3fhklu_3103"><p>默认回收器,PS+Parallel Old</p></li></ul><section class="chapter"><h4 id="cms" data-toc="cms">CMS</h4><ul class="list _bullet" id="-3fhklu_3104"><li class="list__item" id="-3fhklu_3105"><p>concurrent mark sweep</p></li><li class="list__item" id="-3fhklu_3106"><p>老年代垃圾回收器</p></li><li class="list__item" id="-3fhklu_3107"><p>phases </p><ol class="list _decimal" id="-3fhklu_3108" type="1"><li class="list__item" id="-3fhklu_3109"><p>initial mark</p></li><li class="list__item" id="-3fhklu_3110"><p>concurrent mark</p></li><li class="list__item" id="-3fhklu_3111"><p>remark</p></li><li class="list__item" id="-3fhklu_3112"><p>concurrent sweep </p><figure id="-3fhklu_3113"><img alt="Phases" src="images/phases.png" title="Phases" width="1133" height="479"></figure></li></ol></li><li class="list__item" id="-3fhklu_3114"><p>问题 </p><ol class="list _decimal" id="-3fhklu_3115" type="1"><li class="list__item" id="-3fhklu_3116"><p>MemoryFragmentation 内存碎片化 </p><ul class="list _bullet" id="-3fhklu_3117"><li class="list__item" id="-3fhklu_3118"><p>搬出Serial Old来慢慢压缩空间</p></li><li class="list__item" id="-3fhklu_3119"><p>-XX:CMSFUllGCsBeforeCompaction</p></li></ul></li><li class="list__item" id="-3fhklu_3120"><p>Floating Garbage </p><ul class="list _bullet" id="-3fhklu_3121"><li class="list__item" id="-3fhklu_3122"><p>PromotionFailed</p></li><li class="list__item" id="-3fhklu_3123"><p>Concurrent Mode Failure -XX:CMSInitiatingOccupancyFraction 92% </p><ul class="list _bullet" id="-3fhklu_3124"><li class="list__item" id="-3fhklu_3125"><p>降低这个值,让cms保持老年代足够空间</p></li></ul></li><li class="list__item" id="-3fhklu_3126"><p>SeriaOld</p></li></ul></li></ol></li><li class="list__item" id="-3fhklu_3127"><p>垃圾收集器跟内存大小的关系 </p><ol class="list _decimal" id="-3fhklu_3128" type="1"><li class="list__item" id="-3fhklu_3129"><p>Serial 几十m</p></li><li class="list__item" id="-3fhklu_3130"><p>PS 上百m到几个g</p></li><li class="list__item" id="-3fhklu_3131"><p>CMS 几个g到十几个g</p></li><li class="list__item" id="-3fhklu_3132"><p>g1 上百g</p></li><li class="list__item" id="-3fhklu_3133"><p>ZGC 4T</p></li></ol></li></ul><section class="chapter"><h5 id="-3fhklu_3134" data-toc="-3fhklu_3134">三色扫描算法</h5></section></section></section></section><section class="chapter"><h2 id="gc" data-toc="gc">GC 调优</h2><ul class="list _bullet" id="-3fhklu_3135"><li class="list__item" id="-3fhklu_3136"><p>吞吐量: 用户代码时间/(用户代码执行时间+垃圾回收时间) 干正事的比例</p></li><li class="list__item" id="-3fhklu_3137"><p>响应时间 : STW越短,响应时间越好</p></li><li class="list__item" id="-3fhklu_3138"><p>所谓调优: 首先确定追求什么,吞吐量优先还是响应时间优先还是在满足一定响应时间的情况下,要求达到多少吞吐量</p></li></ul><section class="chapter"><h3 id="-3fhklu_3139" data-toc="-3fhklu_3139">命令</h3></section><section class="chapter"><h3 id="log" data-toc="log">Log</h3><ul class="list _bullet" id="-3fhklu_3140"><li class="list__item" id="-3fhklu_3141"><p id="-3fhklu_3142"><code class="code" id="-3fhklu_3143">java -X ms5M -Xmx5M -XX:+PrintCommandLineFlags -XX:+PrintGCDetails com.mashibing.jvm.c5_gc.T01_HelloGC</code></p><ul class="list _bullet" id="-3fhklu_3144"><li class="list__item" id="-3fhklu_3145"><figure id="-3fhklu_3146"><img alt="Ddc71b77" src="images/ddc71b77.png" title="Ddc71b77" width="924" height="202"></figure></li></ul></li><li class="list__item" id="-3fhklu_3147"><figure id="-3fhklu_3148"><img alt="Yf gc" src="images/yfGC.png" title="Yf gc" width="585" height="143"></figure></li><li class="list__item" id="-3fhklu_3149"><figure id="-3fhklu_3150"><img alt="Msbygc" src="images/msbygc.png" title="Msbygc" width="1055" height="535"></figure></li><li class="list__item" id="-3fhklu_3151"><figure id="-3fhklu_3152"><img alt="Heap dump" src="images/heapDump.png" title="Heap dump" width="1078" height="550"></figure></li><li class="list__item" id="-3fhklu_3153"><p id="-3fhklu_3154">total= eden+1个survivor</p></li></ul></section></section><div class="last-modified">Last modified: 30 四月 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="java-3.html" class="navigation-links__prev">Java-3</a><a href="网络.html" class="navigation-links__next">IO</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b259/app.js"></script></body></html>