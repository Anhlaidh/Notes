# Note
## 基本概念
### 进程 线程 纤程(quasar)
- Java线程,详见Java笔记
    - 补充,可以有lambda表达式写法
    - 三种启动线程方式
        1. Thread
        2. Runnable
        3. Executors.newCachedThread(本质也是调用上两个)
    - sleep ,睡眠多少秒,其他线程可以运行
    - yield,加入等待队列,有可能立马还是自己
    - join , 调用另一个线程,保证顺序
    - interrupt , 抛出异常,处理catch
- 锁
    - synchronized 
        - 可重入锁
        - synchronized(this) - > synchronized void m() ,锁的是T.class
        -保证原子性和可见性 
        - 底层实现
            - 锁升级
                1. 偏向锁 标记线程
                2. 自旋锁 自旋十次 消耗cpu,用户态
                3. 重量级锁 - OS,os等待队列,不占cpu,但要跟os交互,内核态
                - 执行时间长,线程数多用系统锁
                - 执行时间段(加锁代码),线程数少,用自旋锁
    - dirty read
        - 锁写不锁读
    - 异常会释放锁
    
    - LongAdder
         - 分段锁(CAS操作)
## 其他锁分类
### 可重入锁
- synchronized
    - 锁进程调用锁进程
- ReentrantLock lock 新型锁
    - cas
    - 手动上锁解锁
    - try lock
        - `lock.tryLock(5,TimeUnit.SECONDS)` 
    - lock.lockInterruptibly()
        - 通过打断来加锁
    - 公平锁
        - `new ReentrantLock(true)`
        - 尽可能公平
        - 进入等待队列之前会检查队列里有没有人
- CountDownLatch 新型锁
    - cas
    - 计数,到了,放开wait
- CyclicBarrier
    - 人满发车
    - 限流

- Phaser
    - 过滤
    - 重写onAdvance(int phase,int registeredParties) 栅栏推到自动调用
        - phase为阶段数
        - registerParties 推到栅栏需要的数量
    - phaser.arriveAndAwaitAdvance() 到达并执行
    - phaser.arriveAndDeregister() 到达不执行
- ReadWriteLock
    - 共享锁
    - 排他锁
    - ReadLock read = new ReentrantLock().ReadLock()
    - WriteLock Write = new ReentrantLock().WriteLock()
- Semaphore
    - 允许几个线程同时进行
    - 类似红绿灯
    - new Semaphore(1)
    - s.acquire(),获得锁,将数量减一,归零则停住
    - s.release() 归还
    - 限流,最多允许多少线程在运行
- Exchanger 交换器

- AQS(核心)
