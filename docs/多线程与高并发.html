<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2024-04-30T19:18:20.873824"><title>Table of Contents | Notes</title><script type="application/json" id="virtual-toc-data">[{"id":"note","level":0,"title":"Note","anchor":"#note"},{"id":"-ievj07_2343","level":0,"title":"基本概念","anchor":"#-ievj07_2343"},{"id":"-ievj07_2370","level":0,"title":"锁","anchor":"#-ievj07_2370"},{"id":"juc","level":0,"title":"各种JUC同步锁","anchor":"#juc"},{"id":"-ievj07_2498","level":0,"title":"面试题","anchor":"#-ievj07_2498"},{"id":"aqs-locksupport-aqs","level":0,"title":"AQS源码分析(以上除了LockSupport全是基于AQS)","anchor":"#aqs-locksupport-aqs"},{"id":"threadlocal","level":0,"title":"ThreadLocal","anchor":"#threadlocal"},{"id":"-ievj07_2582","level":0,"title":"容器","anchor":"#-ievj07_2582"},{"id":"executor","level":0,"title":"Executor","anchor":"#executor"},{"id":"jmh","level":0,"title":"JMH","anchor":"#jmh"},{"id":"disruptor","level":0,"title":"Disruptor","anchor":"#disruptor"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b259/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Table of Contents | Notes"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Notes Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/notes/0.1/多线程与高并发.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Table of Contents | Notes"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/notes/0.1/多线程与高并发.html#webpage",
    "url": "writerside-documentation/notes/0.1/多线程与高并发.html",
    "name": "Table of Contents | Notes",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentationnotes/#website",
    "url": "writerside-documentationnotes/",
    "name": "Notes Help"
}</script><!-- End Schema.org --></head><body data-id="多线程与高并发" data-main-title="Table of Contents" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="README.md|Notes///java///notes///高并发"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Notes 0.1 Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="多线程与高并发" id="多线程与高并发.md">Table of Contents</h1><ul class="list _bullet" id="-ievj07_2257"><li class="list__item" id="-ievj07_2258"><p><span id="-ievj07_2259">Note</span></p><ul class="list _bullet" id="-ievj07_2260"><li class="list__item" id="-ievj07_2261"><p><span id="-ievj07_2262">基本概念</span></p><ul class="list _bullet" id="-ievj07_2263"><li class="list__item" id="-ievj07_2264"><p><span id="-ievj07_2265">进程 线程 纤程(quasar)</span></p></li></ul></li><li class="list__item" id="-ievj07_2266"><p><span id="-ievj07_2267">锁</span></p><ul class="list _bullet" id="-ievj07_2268"><li class="list__item" id="-ievj07_2269"><p><span id="-ievj07_2270">常见锁</span></p><ul class="list _bullet" id="-ievj07_2271"><li class="list__item" id="-ievj07_2272"><p><span id="-ievj07_2273">synchronized</span></p></li><li class="list__item" id="-ievj07_2274"><p><span id="-ievj07_2275">Lock</span></p></li><li class="list__item" id="-ievj07_2276"><p><span id="-ievj07_2277">volatile(可变的)</span></p></li><li class="list__item" id="-ievj07_2278"><p><span id="-ievj07_2279">AtomicXXX</span></p></li><li class="list__item" id="-ievj07_2280"><p><span id="-ievj07_2281">LongAdder</span></p></li></ul></li></ul></li><li class="list__item" id="-ievj07_2282"><p><span id="-ievj07_2283">各种JUC同步锁</span></p><ul class="list _bullet" id="-ievj07_2284"><li class="list__item" id="-ievj07_2285"><p><span id="-ievj07_2286">synchronized</span></p></li><li class="list__item" id="-ievj07_2287"><p><span id="-ievj07_2288">ReentrantLock lock 新型锁</span></p></li><li class="list__item" id="-ievj07_2289"><p><span id="-ievj07_2290">CountDownLatch 新型锁</span></p></li><li class="list__item" id="-ievj07_2291"><p><span id="-ievj07_2292">CyclicBarrier</span></p></li><li class="list__item" id="-ievj07_2293"><p><span id="-ievj07_2294">Phaser</span></p></li><li class="list__item" id="-ievj07_2295"><p><span id="-ievj07_2296">ReadWriteLock -StampedLock</span></p></li><li class="list__item" id="-ievj07_2297"><p><span id="-ievj07_2298">Semaphore</span></p></li><li class="list__item" id="-ievj07_2299"><p><span id="-ievj07_2300">Exchanger 交换器</span></p></li><li class="list__item" id="-ievj07_2301"><p><span id="-ievj07_2302">LockSupport</span></p></li></ul></li><li class="list__item" id="-ievj07_2303"><p><span id="-ievj07_2304">面试题</span></p></li><li class="list__item" id="-ievj07_2305"><p><span id="-ievj07_2306">AQS源码分析(以上除了LockSupport全是基于AQS)</span></p><ul class="list _bullet" id="-ievj07_2307"><li class="list__item" id="-ievj07_2308"><p><span id="-ievj07_2309">源码阅读原则</span></p></li><li class="list__item" id="-ievj07_2310"><p><span id="-ievj07_2311">AQS 核心</span></p></li><li class="list__item" id="-ievj07_2312"><p><span id="-ievj07_2313">VarHandle</span></p></li></ul></li><li class="list__item" id="-ievj07_2314"><p><span id="-ievj07_2315">ThreadLocal</span></p><ul class="list _bullet" id="-ievj07_2316"><li class="list__item" id="-ievj07_2317"><p><span id="-ievj07_2318">java引用</span></p></li></ul></li><li class="list__item" id="-ievj07_2319"><p><span id="-ievj07_2320">容器</span></p><ul class="list _bullet" id="-ievj07_2321"><li class="list__item" id="-ievj07_2322"><p><span id="-ievj07_2323">Collection</span></p></li><li class="list__item" id="-ievj07_2324"><p><span id="-ievj07_2325">Map</span></p><ul class="list _bullet" id="-ievj07_2326"><li class="list__item" id="-ievj07_2327"><p><span id="-ievj07_2328">Concurrent容器</span></p></li><li class="list__item" id="-ievj07_2329"><p><span id="-ievj07_2330">Queue</span></p><ul class="list _bullet" id="-ievj07_2331"><li class="list__item" id="-ievj07_2332"><p><span id="-ievj07_2333">BlockingQueue</span></p><ul class="list _bullet" id="-ievj07_2334"><li class="list__item" id="-ievj07_2335"><p><span id="-ievj07_2336">PriorityQueue 优先级队列</span></p></li><li class="list__item" id="-ievj07_2337"><p><span id="-ievj07_2338">DelayQueue</span></p></li><li class="list__item" id="-ievj07_2339"><p><span id="-ievj07_2340">SynchronusQueue</span></p></li><li class="list__item" id="-ievj07_2341"><p><span id="-ievj07_2342">TransferQueue</span></p></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><section class="chapter"><h2 id="note" data-toc="note">Note</h2></section><section class="chapter"><h2 id="-ievj07_2343" data-toc="-ievj07_2343">基本概念</h2><section class="chapter"><h3 id="quasar" data-toc="quasar">进程 线程 纤程(quasar)</h3><ul class="list _bullet" id="-ievj07_2344"><li class="list__item" id="-ievj07_2345"><p><a href="https://github.com/Anhlaidh/Notes/blob/master/src/main/java/notes//Java/Java-2.md#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86" id="-ievj07_2346" data-external="true" rel="noopener noreferrer">Java线程,详见Java笔记</a></p><ul class="list _bullet" id="-ievj07_2347"><li class="list__item" id="-ievj07_2348"><p>补充,可以有lambda表达式写法</p></li><li class="list__item" id="-ievj07_2349"><p>三种启动线程方式 </p><ol class="list _decimal" id="-ievj07_2350" type="1"><li class="list__item" id="-ievj07_2351"><p>Thread</p></li><li class="list__item" id="-ievj07_2352"><p>Runnable</p></li><li class="list__item" id="-ievj07_2353"><p>Executors.newCachedThread(本质也是调用上两个)</p></li></ol></li><li class="list__item" id="-ievj07_2354"><p>sleep ,睡眠多少秒,其他线程可以运行</p></li><li class="list__item" id="-ievj07_2355"><p>yield,加入等待队列,有可能立马还是自己</p></li><li class="list__item" id="-ievj07_2356"><p>join , 调用另一个线程,保证顺序</p></li><li class="list__item" id="-ievj07_2357"><p>interrupt , 抛出异常,处理catch</p></li></ul></li><li class="list__item" id="-ievj07_2358"><p>生命周期 </p><ul class="list _bullet" id="-ievj07_2359"><li class="list__item" id="-ievj07_2360"><p id="-ievj07_2361">新建：就是刚使用new方法，new出来的线程；</p></li><li class="list__item" id="-ievj07_2362"><p id="-ievj07_2363">就绪：就是调用的线程的start()方法后，这时候线程处于等待CPU分配资源阶段，谁先抢的CPU资源，谁开始执行;</p></li><li class="list__item" id="-ievj07_2364"><p id="-ievj07_2365">运行：当就绪的线程被调度并获得CPU资源时，便进入运行状态，run方法定义了线程的操作和功能;</p></li><li class="list__item" id="-ievj07_2366"><p id="-ievj07_2367">阻塞：在运行状态的时候，可能因为某些原因导致运行状态的线程变成了阻塞状态，比如sleep()、wait()之后线程就处于了阻塞状态，这个时候需要其他机制将处于阻塞状态的线程唤醒，比如调用notify或者notifyAll()方法。唤醒的线程不会立刻执行run方法，它们要再次等待CPU分配资源进入运行状态;</p></li><li class="list__item" id="-ievj07_2368"><p id="-ievj07_2369">销毁：如果线程正常执行完毕后或线程被提前强制性的终止或出现异常导致结束，那么线程就要被销毁，释放资源;</p></li></ul></li></ul></section></section><section class="chapter"><h2 id="-ievj07_2370" data-toc="-ievj07_2370">锁</h2><section class="chapter"><h3 id="-ievj07_2371" data-toc="-ievj07_2371">常见锁</h3><section class="chapter"><h4 id="synchronized" data-toc="synchronized">synchronized</h4><ul class="list _bullet" id="-ievj07_2372"><li class="list__item" id="-ievj07_2373"><p>可重入锁</p></li><li class="list__item" id="-ievj07_2374"><p>synchronized(this) - &gt; synchronized void m() ,static synchronized锁的是T.class -保证原子性和可见性</p></li><li class="list__item" id="-ievj07_2375"><p>底层实现 </p><ul class="list _bullet" id="-ievj07_2376"><li class="list__item" id="-ievj07_2377"><p>锁升级 </p><ol class="list _decimal" id="-ievj07_2378" type="1"><li class="list__item" id="-ievj07_2379"><p>偏向锁 标记线程</p></li><li class="list__item" id="-ievj07_2380"><p>自旋锁 自旋十次 消耗cpu,用户态</p></li><li class="list__item" id="-ievj07_2381"><p>重量级锁 - OS,os等待队列,不占cpu,但要跟os交互,内核态</p></li></ol><ul class="list _bullet" id="-ievj07_2382"><li class="list__item" id="-ievj07_2383"><p>执行时间长,线程数多用系统锁</p></li><li class="list__item" id="-ievj07_2384"><p>执行时间段(加锁代码),线程数少,用自旋锁</p></li></ul></li></ul></li><li class="list__item" id="-ievj07_2385"><p>不能阻止指令重排序</p></li><li class="list__item" id="-ievj07_2386"><p>异常会释放锁</p></li></ul></section><section class="chapter"><h4 id="lock" data-toc="lock">Lock</h4></section><section class="chapter"><h4 id="volatile" data-toc="volatile">volatile(可变的)</h4><ul class="list _bullet" id="-ievj07_2387"><li class="list__item" id="-ievj07_2388"><p id="-ievj07_2389">保证线程可见性</p><ul class="list _bullet" id="-ievj07_2390"><li class="list__item" id="-ievj07_2391"><p>MESI</p></li><li class="list__item" id="-ievj07_2392"><p>缓存一致性协议</p></li></ul></li><li class="list__item" id="-ievj07_2393"><p id="-ievj07_2394">禁止指令重排序</p><ul class="list _bullet" id="-ievj07_2395"><li class="list__item" id="-ievj07_2396"><p>DCL单例</p></li><li class="list__item" id="-ievj07_2397"><p>Double Check Lock</p></li><li class="list__item" id="-ievj07_2398"><p>Mgr06.java</p></li><li class="list__item" id="-ievj07_2399"><p>loadfence原语指令</p></li><li class="list__item" id="-ievj07_2400"><p>storefence原语指令</p></li></ul></li><li class="list__item" id="-ievj07_2401"><p id="-ievj07_2402">不能保证原子性</p></li><li class="list__item" id="-ievj07_2403"><p id="-ievj07_2404">dirty read</p><ul class="list _bullet" id="-ievj07_2405"><li class="list__item" id="-ievj07_2406"><p>锁写不锁读</p></li></ul></li><li class="list__item" id="-ievj07_2407"><p id="-ievj07_2408">优化,粗化,细化</p></li></ul></section><section class="chapter"><h4 id="atomicxxx" data-toc="atomicxxx">AtomicXXX</h4><ul class="list _bullet" id="-ievj07_2409"><li class="list__item" id="-ievj07_2410"><p>CAS(无锁优化 自选) compare and set/swap (乐观锁) </p><ul class="list _bullet" id="-ievj07_2411"><li class="list__item" id="-ievj07_2412"><p id="-ievj07_2413">cas(V,Expected,NewValue)</p><aside class="prompt" data-type="tip" data-title="" id="-ievj07_2414"><p id="-ievj07_2415">if V==E<br> V=New otherwise try again or fail</p></aside></li><li class="list__item" id="-ievj07_2417"><p id="-ievj07_2418">cpu原语支持</p></li><li class="list__item" id="-ievj07_2419"><p id="-ievj07_2420">ABA问题</p><ul class="list _bullet" id="-ievj07_2421"><li class="list__item" id="-ievj07_2422"><p>基础类型无所谓</p></li><li class="list__item" id="-ievj07_2423"><p>引用类型,女朋友符合,中间经历了别的...</p></li></ul><ol class="list _decimal" id="-ievj07_2424" type="1"><li class="list__item" id="-ievj07_2425"><p>不管</p></li><li class="list__item" id="-ievj07_2426"><p>加版本号,检查版本号</p></li></ol></li><li class="list__item" id="-ievj07_2427"><p id="-ievj07_2428">Unsafe类=c c++指针</p><ul class="list _bullet" id="-ievj07_2429"><li class="list__item" id="-ievj07_2430"><p>直接操作内存 </p><ul class="list _bullet" id="-ievj07_2431"><li class="list__item" id="-ievj07_2432"><p>allocateMemory putXXX freeMemory pageSize</p></li></ul></li><li class="list__item" id="-ievj07_2433"><p>直接生成实例 </p><ul class="list _bullet" id="-ievj07_2434"><li class="list__item" id="-ievj07_2435"><p>allocateInstance</p></li></ul></li><li class="list__item" id="-ievj07_2436"><p>直接操作类或者实例变量 </p><ul class="list _bullet" id="-ievj07_2437"><li class="list__item" id="-ievj07_2438"><p>objectFiledOffset</p></li><li class="list__item" id="-ievj07_2439"><p>getInt</p></li><li class="list__item" id="-ievj07_2440"><p>getObject</p></li></ul></li><li class="list__item" id="-ievj07_2441"><p>CAS相关操作 </p><ul class="list _bullet" id="-ievj07_2442"><li class="list__item" id="-ievj07_2443"><p>weakCompareAndSetObject int Long</p></li></ul></li></ul></li></ul></li></ul></section><section class="chapter"><h4 id="longadder" data-toc="longadder">LongAdder</h4><ul class="list _bullet" id="-ievj07_2444"><li class="list__item" id="-ievj07_2445"><p>分段锁(CAS操作)</p></li><li class="list__item" id="-ievj07_2446"><p>分段式锁</p></li></ul></section></section></section><section class="chapter"><h2 id="juc" data-toc="juc">各种JUC同步锁</h2><section class="chapter"><h3 id="synchronized" data-toc="synchronized">synchronized</h3><ul class="list _bullet" id="-ievj07_2447"><li class="list__item" id="-ievj07_2448"><p>锁进程调用锁进程</p></li><li class="list__item" id="-ievj07_2449"><p>notify() 不释放锁</p></li></ul></section><section class="chapter"><h3 id="reentrantlock-lock" data-toc="reentrantlock-lock">ReentrantLock lock 新型锁</h3><ul class="list _bullet" id="-ievj07_2450"><li class="list__item" id="-ievj07_2451"><p>cas</p></li><li class="list__item" id="-ievj07_2452"><p>手动上锁解锁</p></li><li class="list__item" id="-ievj07_2453"><p>try lock </p><ul class="list _bullet" id="-ievj07_2454"><li class="list__item" id="-ievj07_2455"><p><code class="code" id="-ievj07_2456">lock.tryLock(5,TimeUnit.SECONDS)</code></p></li></ul></li><li class="list__item" id="-ievj07_2457"><p>lock.lockInterruptibly() </p><ul class="list _bullet" id="-ievj07_2458"><li class="list__item" id="-ievj07_2459"><p>通过打断来加锁</p></li></ul></li><li class="list__item" id="-ievj07_2460"><p>公平锁 </p><ul class="list _bullet" id="-ievj07_2461"><li class="list__item" id="-ievj07_2462"><p><code class="code" id="-ievj07_2463">new ReentrantLock(true)</code></p></li><li class="list__item" id="-ievj07_2464"><p>尽可能公平</p></li><li class="list__item" id="-ievj07_2465"><p>进入等待队列之前会检查队列里有没有人</p></li></ul></li><li class="list__item" id="-ievj07_2466"><p>可以有各种等待队列</p></li></ul></section><section class="chapter"><h3 id="countdownlatch" data-toc="countdownlatch">CountDownLatch 新型锁</h3><ul class="list _bullet" id="-ievj07_2467"><li class="list__item" id="-ievj07_2468"><p>cas</p></li><li class="list__item" id="-ievj07_2469"><p>计数,到了,放开wait</p></li><li class="list__item" id="-ievj07_2470"><p>await()</p></li><li class="list__item" id="-ievj07_2471"><p>CountDown()</p></li></ul></section><section class="chapter"><h3 id="cyclicbarrier" data-toc="cyclicbarrier">CyclicBarrier</h3><ul class="list _bullet" id="-ievj07_2472"><li class="list__item" id="-ievj07_2473"><p>人满发车</p></li><li class="list__item" id="-ievj07_2474"><p>限流</p></li></ul></section><section class="chapter"><h3 id="phaser" data-toc="phaser">Phaser</h3><ul class="list _bullet" id="-ievj07_2475"><li class="list__item" id="-ievj07_2476"><p>过滤</p></li><li class="list__item" id="-ievj07_2477"><p>重写onAdvance(int phase,int registeredParties) 栅栏推到自动调用 </p><ul class="list _bullet" id="-ievj07_2478"><li class="list__item" id="-ievj07_2479"><p>phase为阶段数</p></li><li class="list__item" id="-ievj07_2480"><p>registerParties 推到栅栏需要的数量</p></li></ul></li><li class="list__item" id="-ievj07_2481"><p>phaser.arriveAndAwaitAdvance() 到达并执行</p></li><li class="list__item" id="-ievj07_2482"><p>phaser.arriveAndDeregister() 到达不执行</p></li></ul></section><section class="chapter"><h3 id="readwritelock-stampedlock" data-toc="readwritelock-stampedlock">ReadWriteLock -StampedLock</h3><ul class="list _bullet" id="-ievj07_2483"><li class="list__item" id="-ievj07_2484"><p>共享锁</p></li><li class="list__item" id="-ievj07_2485"><p>排他锁</p></li><li class="list__item" id="-ievj07_2486"><p>ReadLock read = new ReentrantLock().ReadLock()</p></li><li class="list__item" id="-ievj07_2487"><p>WriteLock Write = new ReentrantLock().WriteLock()</p></li></ul></section><section class="chapter"><h3 id="semaphore" data-toc="semaphore">Semaphore</h3><ul class="list _bullet" id="-ievj07_2488"><li class="list__item" id="-ievj07_2489"><p>允许几个线程同时进行</p></li><li class="list__item" id="-ievj07_2490"><p>类似红绿灯</p></li><li class="list__item" id="-ievj07_2491"><p>new Semaphore(1)</p></li><li class="list__item" id="-ievj07_2492"><p>s.acquire(),获得锁,将数量减一,归零则停住</p></li><li class="list__item" id="-ievj07_2493"><p>s.release() 归还</p></li><li class="list__item" id="-ievj07_2494"><p>限流,最多允许多少线程在运行</p></li></ul></section><section class="chapter"><h3 id="exchanger" data-toc="exchanger">Exchanger 交换器</h3></section><section class="chapter"><h3 id="locksupport" data-toc="locksupport">LockSupport</h3><ul class="list _bullet" id="-ievj07_2495"><li class="list__item" id="-ievj07_2496"><p>LockSupport.park(),当前线程阻塞</p></li><li class="list__item" id="-ievj07_2497"><p>(与锁定线程同时执行)LockSupport.unpark(线程对象名) 相当于在wait()前面调用notify()</p></li></ul></section></section><section class="chapter"><h2 id="-ievj07_2498" data-toc="-ievj07_2498">面试题</h2><ul class="list _bullet" id="-ievj07_2499"><li class="list__item" id="-ievj07_2500"><p>实现一个容器,提供两个方法,add,size,写两个线程,线程1添加10个元素到容器钟,线程2实现监控元素的个数,当个数等于5个时,线程2给出提示并结束 </p><ul class="list _bullet" id="-ievj07_2501"><li class="list__item" id="-ievj07_2502"><p>加volatile ,有问题,得加延时,不然观察不到(即使使用Collection.SynchronizedList(new ArrayList())) </p><ul class="list _bullet" id="-ievj07_2503"><li class="list__item" id="-ievj07_2504"><p>解释:在sleep的时候,有观察的动作</p></li></ul></li><li class="list__item" id="-ievj07_2505"><p>wait notify </p><ul class="list _bullet" id="-ievj07_2506"><li class="list__item" id="-ievj07_2507"><p>synchronized: 观察线程wait,notify添加线程,添加线程到了5,notify观察线程,观察线程运行完,notify添加线程</p></li></ul></li><li class="list__item" id="-ievj07_2508"><p>countDownLatch: CountDownLatch(1),到了5,countDown 但是添加线程太快,可能顺序不符合预想 </p><ul class="list _bullet" id="-ievj07_2509"><li class="list__item" id="-ievj07_2510"><p>解决,两个门闩</p></li></ul></li><li class="list__item" id="-ievj07_2511"><p>LockSupport </p><ul class="list _bullet" id="-ievj07_2512"><li class="list__item" id="-ievj07_2513"><p>类似countDownLatch的思路</p></li></ul></li></ul></li><li class="list__item" id="-ievj07_2514"><p>写一个固定容量的同步容器,拥有put和get方法,以及getCount方法,能够支持2个生产者线程和10个消费者线程的的阻塞调用 </p><ul class="list _bullet" id="-ievj07_2515"><li class="list__item" id="-ievj07_2516"><p>synchronized,必须会写 </p><ul class="list _bullet" id="-ievj07_2517"><li class="list__item" id="-ievj07_2518"><p>wait()</p></li><li class="list__item" id="-ievj07_2519"><p>notifyALl()</p></li><li class="list__item" id="-ievj07_2520"><p>为什么用while而不是if </p><ul class="list _bullet" id="-ievj07_2521"><li class="list__item" id="-ievj07_2522"><p>另一个线程++之后,自己线程没有再检查一遍,所以需要while</p></li></ul></li></ul></li><li class="list__item" id="-ievj07_2523"><p>ReentrantLock 的Condition </p><ul class="list _bullet" id="-ievj07_2524"><li class="list__item" id="-ievj07_2525"><p>多个等待队列</p></li></ul></li></ul></li></ul></section><section class="chapter"><h2 id="aqs-locksupport-aqs" data-toc="aqs-locksupport-aqs">AQS源码分析(以上除了LockSupport全是基于AQS)</h2><section class="chapter"><h3 id="-ievj07_2526" data-toc="-ievj07_2526">源码阅读原则</h3><ul class="list _bullet" id="-ievj07_2527"><li class="list__item" id="-ievj07_2528"><p>跑不起来不读</p></li><li class="list__item" id="-ievj07_2529"><p>解决问题就好-目的性</p></li><li class="list__item" id="-ievj07_2530"><p>一条线索到底</p></li><li class="list__item" id="-ievj07_2531"><p>无关细节略过</p></li><li class="list__item" id="-ievj07_2532"><p>一般不读静态</p></li><li class="list__item" id="-ievj07_2533"><p>一般动态读法</p></li></ul></section><section class="chapter"><h3 id="aqs" data-toc="aqs">AQS 核心</h3><ul class="list _bullet" id="-ievj07_2534"><li class="list__item" id="-ievj07_2535"><p>CAS操作替代了锁整条链表的操作</p></li><li class="list__item" id="-ievj07_2536"><p>CAS操作来操作tail</p></li></ul></section><section class="chapter"><h3 id="varhandle" data-toc="varhandle">VarHandle</h3><ul class="list _bullet" id="-ievj07_2537"><li class="list__item" id="-ievj07_2538"><p>指向某个变量的引用</p></li><li class="list__item" id="-ievj07_2539"><p>原子性操作</p></li><li class="list__item" id="-ievj07_2540"><p>native cpu原语</p></li><li class="list__item" id="-ievj07_2541"><p>比反射效率高很多</p></li><li class="list__item" id="-ievj07_2542"><p>直接操纵二进制码</p></li></ul></section></section><section class="chapter"><h2 id="threadlocal" data-toc="threadlocal">ThreadLocal</h2><ul class="list _bullet" id="-ievj07_2543"><li class="list__item" id="-ievj07_2544"><p>set </p><ul class="list _bullet" id="-ievj07_2545"><li class="list__item" id="-ievj07_2546"><p>Thread.currentThread.map(ThreadLocal,person)</p></li></ul></li><li class="list__item" id="-ievj07_2547"><p>用途 </p><ul class="list _bullet" id="-ievj07_2548"><li class="list__item" id="-ievj07_2549"><p>声明式事务,保证同一个Connection</p></li></ul></li></ul><section class="chapter"><h3 id="java" data-toc="java">java引用</h3><ul class="list _bullet" id="-ievj07_2550"><li class="list__item" id="-ievj07_2551"><p>强软弱虚</p></li><li class="list__item" id="-ievj07_2552"><p>强引用 </p><ul class="list _bullet" id="-ievj07_2553"><li class="list__item" id="-ievj07_2554"><p>普通一般用的引用</p></li><li class="list__item" id="-ievj07_2555"><p>特点 </p><ul class="list _bullet" id="-ievj07_2556"><li class="list__item" id="-ievj07_2557"><p>不会被垃圾回收器回收</p></li></ul></li></ul></li><li class="list__item" id="-ievj07_2558"><p>软引用 </p><ul class="list _bullet" id="-ievj07_2559"><li class="list__item" id="-ievj07_2560"><p>内存不够用的时候会回收</p></li><li class="list__item" id="-ievj07_2561"><p>做缓存用</p></li><li class="list__item" id="-ievj07_2562"><p>full gc</p></li></ul></li><li class="list__item" id="-ievj07_2563"><p>弱引用 </p><ul class="list _bullet" id="-ievj07_2564"><li class="list__item" id="-ievj07_2565"><p>只要遭遇到gc就会回收</p></li><li class="list__item" id="-ievj07_2566"><p>作用 </p><ul class="list _bullet" id="-ievj07_2567"><li class="list__item" id="-ievj07_2568"><p>一般用在容器里</p></li><li class="list__item" id="-ievj07_2569"><p>另一个强引用指向引用对象,引用断掉之后可以立即回收这个对象</p></li></ul></li><li class="list__item" id="-ievj07_2570"><p>ThreadLocal </p><ul class="list _bullet" id="-ievj07_2571"><li class="list__item" id="-ievj07_2572"><p>ThreadLocalMap的key弱引用ThreadLocal,然后声明的变量强引用指向ThreadLocal</p></li><li class="list__item" id="-ievj07_2573"><p>如果强引用,则内存泄漏</p></li><li class="list__item" id="-ievj07_2574"><p>无比remove掉,不然还是会内存泄漏,(key值为null,value还存在(map还存在))</p></li></ul></li></ul></li><li class="list__item" id="-ievj07_2575"><p>虚引用(给写jvm的人用的) </p><ul class="list _bullet" id="-ievj07_2576"><li class="list__item" id="-ievj07_2577"><p>管理堆外内存</p></li><li class="list__item" id="-ievj07_2578"><p>gc就被回收</p></li><li class="list__item" id="-ievj07_2579"><p>回收之后可以从QUEUE中观测</p></li><li class="list__item" id="-ievj07_2580"><p>值get不到</p></li><li class="list__item" id="-ievj07_2581"><p>NIO中有个DirectByteBuffer,指向堆外内存,用虚引用的QUEUE来查看堆外内存哪里需要回收</p></li></ul></li></ul></section></section><section class="chapter"><h2 id="-ievj07_2582" data-toc="-ievj07_2582">容器</h2><section class="chapter"><h3 id="collection" data-toc="collection">Collection</h3><aside class="prompt" data-type="tip" data-title="" id="-ievj07_2583"><p id="-ievj07_2584">三大类</p><ul class="list _bullet" id="-ievj07_2585"><li class="list__item" id="-ievj07_2586"><p>List</p></li><li class="list__item" id="-ievj07_2587"><p>Set</p></li><li class="list__item" id="-ievj07_2588"><p>Queue</p></li></ul></aside><ul class="list _bullet" id="-ievj07_2589"><li class="list__item" id="-ievj07_2590"><p>Vector </p><ul class="list _bullet" id="-ievj07_2591"><li class="list__item" id="-ievj07_2592"><p>方法加了synchronized</p></li></ul></li><li class="list__item" id="-ievj07_2593"><p>Queue </p><ul class="list _bullet" id="-ievj07_2594"><li class="list__item" id="-ievj07_2595"><p>ConcurrentQueue </p><ul class="list _bullet" id="-ievj07_2596"><li class="list__item" id="-ievj07_2597"><p>CAS操作</p></li></ul></li></ul></li></ul></section><section class="chapter"><h3 id="map" data-toc="map">Map</h3><ul class="list _bullet" id="-ievj07_2598"><li class="list__item" id="-ievj07_2599"><p>Hashtable </p><ul class="list _bullet" id="-ievj07_2600"><li class="list__item" id="-ievj07_2601"><p>整个方法全加synchronized</p></li></ul></li><li class="list__item" id="-ievj07_2602"><p>HashSet </p><ul class="list _bullet" id="-ievj07_2603"><li class="list__item" id="-ievj07_2604"><p>全不加</p></li></ul></li><li class="list__item" id="-ievj07_2605"><p>SynchronizedHashMap </p><ul class="list _bullet" id="-ievj07_2606"><li class="list__item" id="-ievj07_2607"><p>效率没有比Hashtable高多少</p></li><li class="list__item" id="-ievj07_2608"><p>加synchronized,但粒度比hashtable细</p></li></ul></li><li class="list__item" id="-ievj07_2609"><p>TreeMap </p><ul class="list _bullet" id="-ievj07_2610"><li class="list__item" id="-ievj07_2611"><p>红黑树</p></li></ul></li></ul><section class="chapter"><h4 id="concurrent" data-toc="concurrent">Concurrent容器</h4><ul class="list _bullet" id="-ievj07_2612"><li class="list__item" id="-ievj07_2613"><p>ConcurrentHashMap </p><ul class="list _bullet" id="-ievj07_2614"><li class="list__item" id="-ievj07_2615"><p>CAS操作</p></li><li class="list__item" id="-ievj07_2616"><p>插入效率未必比其他的高</p></li><li class="list__item" id="-ievj07_2617"><p>读取效率非常高</p></li></ul></li><li class="list__item" id="-ievj07_2618"><p>没有ConcurrentTreeMap </p><ul class="list _bullet" id="-ievj07_2619"><li class="list__item" id="-ievj07_2620"><p>CAS操作树结构十分复杂</p></li></ul></li><li class="list__item" id="-ievj07_2621"><p>ConcurrentSkipListMap 跳表Map　　　 </p><ul class="list _bullet" id="-ievj07_2622"><li class="list__item" id="-ievj07_2623"><p>高并发且排序</p></li></ul></li><li class="list__item" id="-ievj07_2624"><p>CopyOnWriteList 写时复制 </p><ul class="list _bullet" id="-ievj07_2625"><li class="list__item" id="-ievj07_2626"><p>加元素的时候复制出来</p></li><li class="list__item" id="-ievj07_2627"><p>读的时候不加锁,写的时候加锁copy一个,然后把元素放上去,老指针指向新容器</p></li><li class="list__item" id="-ievj07_2628"><p>读多写少的情况下用</p></li></ul></li></ul></section><section class="chapter"><h4 id="queue" data-toc="queue">Queue</h4><ul class="list _bullet" id="-ievj07_2629"><li class="list__item" id="-ievj07_2630"><p>相比于vector,添加了对线程友好的API </p><ul class="list _bullet" id="-ievj07_2631"><li class="list__item" id="-ievj07_2632"><p>offer 添加,返回是否成功,add则是失败抛异常</p></li><li class="list__item" id="-ievj07_2633"><p>peek 取,不会remove</p></li><li class="list__item" id="-ievj07_2634"><p>poll 取,并且remove</p></li></ul></li></ul><section class="chapter"><h5 id="blockingqueue" data-toc="blockingqueue">BlockingQueue</h5><ul class="list _bullet" id="-ievj07_2635"><li class="list__item" id="-ievj07_2636"><p>put 添加 ,满了的话,线程阻塞住</p></li><li class="list__item" id="-ievj07_2637"><p>take 取,空了的话,线程阻塞住 </p><ul class="list _bullet" id="-ievj07_2638"><li class="list__item" id="-ievj07_2639"><p>LockSupport的park</p></li></ul></li><li class="list__item" id="-ievj07_2640"><p>生产者消费者模型</p></li><li class="list__item" id="-ievj07_2641"><p>LinkedBlockingQueue </p><ul class="list _bullet" id="-ievj07_2642"><li class="list__item" id="-ievj07_2643"><p>链表实现的BlockingQueue</p></li><li class="list__item" id="-ievj07_2644"><p>有最大数量,Integer.MAX_VALUE</p></li></ul></li></ul><section class="chapter"><h6 id="priorityqueue" data-toc="priorityqueue">PriorityQueue 优先级队列</h6><ul class="list _bullet" id="-ievj07_2645"><li class="list__item" id="-ievj07_2646"><p>内部是二叉树</p></li><li class="list__item" id="-ievj07_2647"><p>继承自AbstractQueue </p><ul class="list _bullet" id="-ievj07_2648"><li class="list__item" id="-ievj07_2649"><p>内部进行排序 </p><ul class="list _bullet" id="-ievj07_2650"><li class="list__item" id="-ievj07_2651"><p>重写compareTo</p></li></ul></li></ul></li></ul></section><section class="chapter"><h6 id="delayqueue" data-toc="delayqueue">DelayQueue</h6><ul class="list _bullet" id="-ievj07_2652"><li class="list__item" id="-ievj07_2653"><p>任务类需要继承Delay接口</p></li><li class="list__item" id="-ievj07_2654"><p>按时间进行任务调度 </p><ul class="list _bullet" id="-ievj07_2655"><li class="list__item" id="-ievj07_2656"><p>new Task(&quot;t&quot;,System.currentTimeMillis()+500) </p><ul class="list _bullet" id="-ievj07_2657"><li class="list__item" id="-ievj07_2658"><p>五秒后运行</p></li></ul></li></ul></li></ul></section><section class="chapter"><h6 id="synchronusqueue" data-toc="synchronusqueue">SynchronusQueue</h6><ul class="list _bullet" id="-ievj07_2659"><li class="list__item" id="-ievj07_2660"><p>容量为0,给另外线程下达任务的,任务调度</p></li><li class="list__item" id="-ievj07_2661"><p>本质上概念类似于Exchanger</p></li><li class="list__item" id="-ievj07_2662"><p>只put </p><ul class="list _bullet" id="-ievj07_2663"><li class="list__item" id="-ievj07_2664"><p>永远阻塞,等待消费(take)</p></li></ul></li><li class="list__item" id="-ievj07_2665"><p>不可以用add </p><ul class="list _bullet" id="-ievj07_2666"><li class="list__item" id="-ievj07_2667"><p>会提示Queue已经满了,即使有take等待</p></li></ul></li></ul></section><section class="chapter"><h6 id="transferqueue" data-toc="transferqueue">TransferQueue</h6><ul class="list _bullet" id="-ievj07_2668"><li class="list__item" id="-ievj07_2669"><p>transfer(entry) </p><ul class="list _bullet" id="-ievj07_2670"><li class="list__item" id="-ievj07_2671"><p>装完,阻塞,等待被取走,取走之后再取消阻塞</p></li></ul></li><li class="list__item" id="-ievj07_2672"><p>类似于接单,有反馈的模型</p></li></ul></section></section><section class="chapter"><h5 id="pipedstream" data-toc="pipedstream">PipedStream</h5></section></section></section></section><section class="chapter"><h2 id="executor" data-toc="executor">Executor</h2><section class="chapter"><h3 id="callable" data-toc="callable">Callable</h3><ul class="list _bullet" id="-ievj07_2673"><li class="list__item" id="-ievj07_2674"><p>一个Task</p></li><li class="list__item" id="-ievj07_2675"><p>类似于Runnable</p></li><li class="list__item" id="-ievj07_2676"><p>call(),有返回值</p></li><li class="list__item" id="-ievj07_2677"><p>返回值存放在Future</p></li></ul></section><section class="chapter"><h3 id="future" data-toc="future">Future</h3><ul class="list _bullet" id="-ievj07_2678"><li class="list__item" id="-ievj07_2679"><p>存储执行的将来才会产生的结果(所以叫Future)</p></li><li class="list__item" id="-ievj07_2680"><p>submit(Task) 提交任务,异步运行,非阻塞</p></li><li class="list__item" id="-ievj07_2681"><p>get()方法取结果,阻塞方法</p></li></ul></section><section class="chapter"><h3 id="futuretask" data-toc="futuretask">FutureTask</h3><ul class="list _bullet" id="-ievj07_2682"><li class="list__item" id="-ievj07_2683"><p>继承于Future和Runnable</p></li><li class="list__item" id="-ievj07_2684"><p>把返回值存在自身</p></li></ul></section><section class="chapter"><h3 id="completablefuture" data-toc="completablefuture">CompletableFuture</h3><ul class="list _bullet" id="-ievj07_2685"><li class="list__item" id="-ievj07_2686"><p>底层用的Fork-Join Pool</p></li><li class="list__item" id="-ievj07_2687"><p>各种任务的管理类</p></li></ul></section><section class="chapter"><h3 id="abstractexecutor" data-toc="abstractexecutor">AbstractExecutor</h3></section><section class="chapter"><h3 id="executorservice" data-toc="executorservice">ExecutorService</h3><ul class="list _bullet" id="-ievj07_2688"><li class="list__item" id="-ievj07_2689"><p>线程池大小调整 </p><ul class="list _bullet" id="-ievj07_2690"><li class="list__item" id="-ievj07_2691"><p>线程数过多,将浪费大量时间在上下文切换上</p></li><li class="list__item" id="-ievj07_2692"><p>线程数过少,则cpu一些核则无法充分利用</p></li><li class="list__item" id="-ievj07_2693"><p>N_Thread = N_CPU * U_CPU * (1+W/C) </p><ul class="list _bullet" id="-ievj07_2694"><li class="list__item" id="-ievj07_2695"><p>N_CPU是处理器核的数目</p></li><li class="list__item" id="-ievj07_2696"><p>U_CPU是期望CPU的利用率</p></li><li class="list__item" id="-ievj07_2697"><p>W/C是等待时间预计算时间的比率</p></li></ul></li></ul></li><li class="list__item" id="-ievj07_2698"><p>Executors </p><ul class="list _bullet" id="-ievj07_2699"><li class="list__item" id="-ievj07_2700"><p id="-ievj07_2701">线程池工厂</p></li><li class="list__item" id="-ievj07_2702"><p id="-ievj07_2703">Executors.newSingleThreadExecutor() 单例线程池</p><ul class="list _bullet" id="-ievj07_2704"><li class="list__item" id="-ievj07_2705"><p>可以保证任务顺序执行</p></li><li class="list__item" id="-ievj07_2706"><p>存在意义: </p><ul class="list _bullet" id="-ievj07_2707"><li class="list__item" id="-ievj07_2708"><p>任务队列</p></li><li class="list__item" id="-ievj07_2709"><p>生命周期管理</p></li></ul></li></ul></li><li class="list__item" id="-ievj07_2710"><p id="-ievj07_2711">CachedPool</p><ul class="list _bullet" id="-ievj07_2712"><li class="list__item" id="-ievj07_2713"><p>0个coreThread,Integer.MAX_VALUE个最大线程数</p></li><li class="list__item" id="-ievj07_2714"><p>队列用的SynchronusQueue</p></li><li class="list__item" id="-ievj07_2715"><p>来了马上使用</p></li></ul></li><li class="list__item" id="-ievj07_2716"><p id="-ievj07_2717">FixedThreadPool</p><ul class="list _bullet" id="-ievj07_2718"><li class="list__item" id="-ievj07_2719"><p>固定线程数的线程池</p></li></ul></li><li class="list__item" id="-ievj07_2720"><p id="-ievj07_2721">Scheduled定时器线程池</p><ul class="list _bullet" id="-ievj07_2722"><li class="list__item" id="-ievj07_2723"><p>队列是delayQueue</p></li><li class="list__item" id="-ievj07_2724"><p>Qutarz</p></li></ul></li><li class="list__item" id="-ievj07_2725"><p id="-ievj07_2726">面试题</p><ul class="list _bullet" id="-ievj07_2727"><li class="list__item" id="-ievj07_2728"><p>加入提供了一个闹钟服务,订阅这个服务的人特别多,10亿,七点钟有10亿并发量 </p><ul class="list _bullet" id="-ievj07_2729"><li class="list__item" id="-ievj07_2730"><p>大的结构上，采用分而治之的思想，主服务器把这些任务同步到边缘服务器上，然后再每一台服务器上，通过线程池+任务队列。首先可以负载均衡分发到多台服务器去执行。然后对于每一台服务器，肯定有一个队列嘛，存着这些任务，然后一个个线程去消费。所以也是要用到线程池的。</p></li></ul></li></ul></li><li class="list__item" id="-ievj07_2731"><p id="-ievj07_2732">concurrent vs parallel</p><ul class="list _bullet" id="-ievj07_2733"><li class="list__item" id="-ievj07_2734"><p>并发是指任务提交</p></li><li class="list__item" id="-ievj07_2735"><p>并行指任务执行</p></li><li class="list__item" id="-ievj07_2736"><p>并行是并发的子集</p></li></ul></li></ul></li></ul><section class="chapter"><h4 id="threadpoolexecutor" data-toc="threadpoolexecutor">ThreadPoolExecutor</h4><ul class="list _bullet" id="-ievj07_2737"><li class="list__item" id="-ievj07_2738"><p>维护着线程的集合和任务的集合</p></li><li class="list__item" id="-ievj07_2739"><p>七个参数 </p><ol class="list _decimal" id="-ievj07_2740" type="1"><li class="list__item" id="-ievj07_2741"><p>corePoolSize 核心线程数</p></li><li class="list__item" id="-ievj07_2742"><p>maximumPoolSize 最大线程数 </p><ul class="list _bullet" id="-ievj07_2743"><li class="list__item" id="-ievj07_2744"><p>算上核心线程数</p></li></ul></li><li class="list__item" id="-ievj07_2745"><p>keepAliveTime 生存时间 </p><ul class="list _bullet" id="-ievj07_2746"><li class="list__item" id="-ievj07_2747"><p>线程空闲时间过长,要回收给OS</p></li><li class="list__item" id="-ievj07_2748"><p>核心线程一直都要活着</p></li></ul></li><li class="list__item" id="-ievj07_2749"><p>生存时间的单位(TimeUnit.Seconds)</p></li><li class="list__item" id="-ievj07_2750"><p>任务队列(new ArrayBlockingQueue()) </p><ul class="list _bullet" id="-ievj07_2751"><li class="list__item" id="-ievj07_2752"><p>可以放各种各样的BlockingQueue</p></li><li class="list__item" id="-ievj07_2753"><p>存任务用的</p></li></ul></li><li class="list__item" id="-ievj07_2754"><p>线程工厂(Executors.defaultThreadFactory)</p></li><li class="list__item" id="-ievj07_2755"><p>拒绝策略 </p><ul class="list _bullet" id="-ievj07_2756"><li class="list__item" id="-ievj07_2757"><p>任务队列满,且线程也都用着,需要拒绝新来的线程</p></li><li class="list__item" id="-ievj07_2758"><p>jdk默认提供四种 </p><ol class="list _decimal" id="-ievj07_2759" type="1"><li class="list__item" id="-ievj07_2760"><p>AbortPolicy:抛异常</p></li><li class="list__item" id="-ievj07_2761"><p>DiscardPolicy:扔掉,不抛异常</p></li><li class="list__item" id="-ievj07_2762"><p>DiscardOldestPolicy:扔掉排队时间最长的</p></li><li class="list__item" id="-ievj07_2763"><p>CallerRunsPolicy:调用者处理任务</p></li></ol></li></ul></li></ol></li><li class="list__item" id="-ievj07_2764"><p>源码分析 </p><ul class="list _bullet" id="-ievj07_2765"><li class="list__item" id="-ievj07_2766"><p>Worker类(类似一个单独的线程类) </p><ul class="list _bullet" id="-ievj07_2767"><li class="list__item" id="-ievj07_2768"><p>Runnable AQS</p></li><li class="list__item" id="-ievj07_2769"><p>记录哪个Thread正在执行这个worker,所以需要AQS(还有加锁)</p></li></ul></li><li class="list__item" id="-ievj07_2770"><p>submit方法</p></li><li class="list__item" id="-ievj07_2771"><p>execute </p><ol class="list _decimal" id="-ievj07_2772" type="1"><li class="list__item" id="-ievj07_2773"><p>核心线程数不满,启核心</p></li><li class="list__item" id="-ievj07_2774"><p>满了,加队列</p></li><li class="list__item" id="-ievj07_2775"><p>两个都满了,非核心线程</p></li></ol></li><li class="list__item" id="-ievj07_2776"><p>addWorker </p><ol class="list _decimal" id="-ievj07_2777" type="1"><li class="list__item" id="-ievj07_2778"><p>count++</p></li><li class="list__item" id="-ievj07_2779"><p>addwork start</p></li></ol></li></ul></li></ul></section></section><section class="chapter"><h3 id="forkjoinpool" data-toc="forkjoinpool">ForkJoinPool</h3><ul class="list _bullet" id="-ievj07_2780"><li class="list__item" id="-ievj07_2781"><p>分解汇总的任务</p></li><li class="list__item" id="-ievj07_2782"><p>用很少的线程可以执行很多的任务(子任务)TPE做不到先执行子任务</p></li><li class="list__item" id="-ievj07_2783"><p>CPU密集型</p></li><li class="list__item" id="-ievj07_2784"><p>Work </p><ul class="list _bullet" id="-ievj07_2785"><li class="list__item" id="-ievj07_2786"><p>继承RecursiveAction </p><ul class="list _bullet" id="-ievj07_2787"><li class="list__item" id="-ievj07_2788"><p>不带返回值</p></li></ul></li><li class="list__item" id="-ievj07_2789"><p>继承RecursiveTask </p><ul class="list _bullet" id="-ievj07_2790"><li class="list__item" id="-ievj07_2791"><p>带返回值</p></li></ul></li></ul></li></ul><section class="chapter"><h4 id="workstealingpool" data-toc="workstealingpool">workStealingPool</h4><ul class="list _bullet" id="-ievj07_2792"><li class="list__item" id="-ievj07_2793"><p>每一个线程都有自己单独的队列</p></li><li class="list__item" id="-ievj07_2794"><p>某一个线程执行完自己任务后,去别的线程上拿未完成的任务</p></li><li class="list__item" id="-ievj07_2795"><p>底层是ForkJoinPool</p></li></ul></section><section class="chapter"><h4 id="parallelstreamapi" data-toc="parallelstreamapi">ParallelStreamAPI 并行流</h4><ul class="list _bullet" id="-ievj07_2796"><li class="list__item" id="-ievj07_2797"><p>任务并行处理</p></li><li class="list__item" id="-ievj07_2798"><p>底层实ForkJoinPool</p></li></ul></section></section></section><section class="chapter"><h2 id="jmh" data-toc="jmh">JMH</h2><ul class="list _bullet" id="-ievj07_2799"><li class="list__item" id="-ievj07_2800"><p>Java Microbenchmark harness </p><ul class="list _bullet" id="-ievj07_2801"><li class="list__item" id="-ievj07_2802"><p>java 微基准测试</p></li></ul></li><li class="list__item" id="-ievj07_2803"><p>量化性能</p></li><li class="list__item" id="-ievj07_2804"><p>注解 </p><ul class="list _bullet" id="-ievj07_2805"><li class="list__item" id="-ievj07_2806"><p>Benchmark 测试哪一段代码</p></li><li class="list__item" id="-ievj07_2807"><p>Warmup 预热 </p><ul class="list _bullet" id="-ievj07_2808"><li class="list__item" id="-ievj07_2809"><p>iterations 迭代,运行几次</p></li><li class="list__item" id="-ievj07_2810"><p>time 等待几秒</p></li></ul></li><li class="list__item" id="-ievj07_2811"><p>Fork </p><ul class="list _bullet" id="-ievj07_2812"><li class="list__item" id="-ievj07_2813"><p>用多少个线程来执行</p></li></ul></li><li class="list__item" id="-ievj07_2814"><p>BenchmarkMode 模式 </p><ul class="list _bullet" id="-ievj07_2815"><li class="list__item" id="-ievj07_2816"><p>Mode.Throughtput 吞吐量 每秒执行多少次</p></li></ul></li><li class="list__item" id="-ievj07_2817"><p>Measurement </p><ul class="list _bullet" id="-ievj07_2818"><li class="list__item" id="-ievj07_2819"><p>iteration调用多少次</p></li><li class="list__item" id="-ievj07_2820"><p>time 时间</p></li></ul></li></ul></li></ul></section><section class="chapter"><h2 id="disruptor" data-toc="disruptor">Disruptor</h2><ul class="list _bullet" id="-ievj07_2821"><li class="list__item" id="-ievj07_2822"><p>分裂,瓦解</p></li><li class="list__item" id="-ievj07_2823"><p>一个线程每秒处理600万个订单</p></li><li class="list__item" id="-ievj07_2824"><p>速度最快的MQ</p></li><li class="list__item" id="-ievj07_2825"><p>性能极高,无锁cas,单机支持高并发</p></li><li class="list__item" id="-ievj07_2826"><p>环形buffer</p></li><li class="list__item" id="-ievj07_2827"><p>实现了ConcurrentArrayQueue</p></li><li class="list__item" id="-ievj07_2828"><p>维护sequence 写到的位置 </p><ul class="list _bullet" id="-ievj07_2829"><li class="list__item" id="-ievj07_2830"><p>position = num&amp;(size-1) --&gt; 取余 12%8 = 12&amp;(8-1)</p></li></ul></li><li class="list__item" id="-ievj07_2831"><p>队列满--&gt;等待策略</p></li></ul><section class="chapter"><h3 id="-ievj07_2832" data-toc="-ievj07_2832">开发步骤</h3><ol class="list _decimal" id="-ievj07_2833" type="1"><li class="list__item" id="-ievj07_2834"><p>定义Event,队列中需要处理的元素</p></li><li class="list__item" id="-ievj07_2835"><p>定义Event工厂,用于填充队列 </p><ul class="list _bullet" id="-ievj07_2836"><li class="list__item" id="-ievj07_2837"><p>牵扯到效率问题:disruptor初始化的时候,会调用Event工厂,对ringBuffer进行内存的提前分配</p></li><li class="list__item" id="-ievj07_2838"><p>gc产生频率会降低,只有最开始分配的时候new</p></li></ul></li><li class="list__item" id="-ievj07_2839"><p>定义EventHandler(消费者) ,处理容器中的元素</p></li></ol><section class="chapter"><h4 id="producertype" data-toc="producertype">ProducerType生产者线程模式</h4><ol class="list _decimal" id="-ievj07_2840" type="1"><li class="list__item" id="-ievj07_2841"><p>Producer.MULTI</p></li><li class="list__item" id="-ievj07_2842"><p>Producer.SINGLE 默认是MULTI,表示在多线程下生产sequence 如果确认是单线程生产者,那么可以指定SINGLE,效率会提升</p></li></ol></section><section class="chapter"><h4 id="-ievj07_2843" data-toc="-ievj07_2843">等待策略</h4><ol class="list _decimal" id="-ievj07_2844" type="1"><li class="list__item" id="-ievj07_2845"><p>(常用)BlockingWaitStrategy:通过线程阻塞的方式,等待生产者唤醒,被唤醒后,再循环检查以来的sequence是否已经消费</p></li><li class="list__item" id="-ievj07_2846"><p>BusySpinWaitStrategy:线程一直自选等待,可能比较耗cpu</p></li><li class="list__item" id="-ievj07_2847"><p>LiteBlockingWaitStrategy:线程阻塞等待生产者唤醒,与BlockingWaitStrategy相比,区别在SignalNeeded.getAndSet,如果两个线程同时访问一个 waitfor,一个访问signalAll时,可以减少lock加锁次数</p></li><li class="list__item" id="-ievj07_2848"><p>LiteTimeoutBlockingWaitStrategy</p></li><li class="list__item" id="-ievj07_2849"><p>PhasedBackoffWaitStrategy</p></li><li class="list__item" id="-ievj07_2850"><p>TimeoutBlockingWaitStrategy</p></li><li class="list__item" id="-ievj07_2851"><p>(常用)YieldingWaitStrategy:尝试100次,然后Thread.yield()让出cpu</p></li><li class="list__item" id="-ievj07_2852"><p>(常用)SleepingWaitStrategy:Sleep</p></li></ol></section><section class="chapter"><h4 id="-ievj07_2853" data-toc="-ievj07_2853">消费者异常处理</h4><ul class="list _bullet" id="-ievj07_2854"><li class="list__item" id="-ievj07_2855"><p>disruptor.handleException</p></li></ul><div class="code-block" data-lang="java">
 disruptor.handleExceptionsFor(longEventHandler).with(new ExceptionHandler&lt;LongEvent&gt;() {
            @Override
            public void handleEventException(Throwable ex, long sequence, LongEvent event) {

            }

            @Override
            public void handleOnStartException(Throwable ex) {

            }

            @Override
            public void handleOnShutdownException(Throwable ex) {

            }
        });
</div></section></section></section><div class="last-modified">Last modified: 30 四月 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="tankwar.html" class="navigation-links__prev">Tank War 设计</a><a href="并发面试底层.html" class="navigation-links__next">JUC</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b259/app.js"></script></body></html>