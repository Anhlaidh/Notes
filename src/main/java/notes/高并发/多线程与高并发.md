# Note
## 基本概念
### 进程 线程 纤程(quasar)
- Java线程,详见Java笔记
    - 补充,可以有lambda表达式写法
    - 三种启动线程方式
        1. Thread
        2. Runnable
        3. Executors.newCachedThread(本质也是调用上两个)
    - sleep ,睡眠多少秒,其他线程可以运行
    - yield,加入等待队列,有可能立马还是自己
    - join , 调用另一个线程,保证顺序
    - interrupt , 抛出异常,处理catch
## 锁
###
####synchronized 
- 可重入锁
- synchronized(this) - > synchronized void m() ,static synchronized锁的是T.class
-保证原子性和可见性 
- 底层实现
    - 锁升级
        1. 偏向锁 标记线程
        2. 自旋锁 自旋十次 消耗cpu,用户态
        3. 重量级锁 - OS,os等待队列,不占cpu,但要跟os交互,内核态
        - 执行时间长,线程数多用系统锁
        - 执行时间段(加锁代码),线程数少,用自旋锁
- 不能阻止指令重排序
- 异常会释放锁
#### Lock
#### volatile(可变的)
- 保证线程可见性
    - MESI
    - 缓存一致性协议
- 禁止指令重排序
    - DCL单例
    - Double Check Lock
    - Mgr06.java 
    - loadfence原语指令
    - storefence原语指令
- 不能保证原子性


- dirty read
    - 锁写不锁读
- 优化,粗化,细化
#### AtomicXXX
- CAS(无锁优化 自选) compare and set/swap (乐观锁)
    - cas(V,Expected,NewValue)
      > if V==E   
        V=New otherwise try again or fail
    - cpu原语支持
    - ABA问题
        - 基础类型无所谓
        - 引用类型,女朋友符合,中间经历了别的...
       1. 不管
       2. 加版本号,检查版本号
    - Unsafe类=c c++指针
        - 直接操作内存
            - allocateMemory putXXX freeMemory pageSize
        - 直接生成实例
            - allocateInstance
        - 直接操作类或者实例变量
            - objectFiledOffset
            - getInt
            - getObject
        - CAS相关操作
            - weakCompareAndSetObject int Long   
#### LongAdder
- 分段锁(CAS操作)
- 分段式锁
## 各种JUC同步锁
### synchronized
- 锁进程调用锁进程
- notify() 不释放锁
### ReentrantLock lock 新型锁
- cas
- 手动上锁解锁
- try lock
    - `lock.tryLock(5,TimeUnit.SECONDS)` 
- lock.lockInterruptibly()
    - 通过打断来加锁
- 公平锁
    - `new ReentrantLock(true)`
    - 尽可能公平
    - 进入等待队列之前会检查队列里有没有人
- 可以有各种等待队列
### CountDownLatch 新型锁
 - cas
 - 计数,到了,放开wait
### CyclicBarrier
 - 人满发车
 - 限流

### Phaser
 - 过滤
 - 重写onAdvance(int phase,int registeredParties) 栅栏推到自动调用
     - phase为阶段数
     - registerParties 推到栅栏需要的数量
 - phaser.arriveAndAwaitAdvance() 到达并执行
 - phaser.arriveAndDeregister() 到达不执行
### ReadWriteLock -StampedLock
- 共享锁
- 排他锁
- ReadLock read = new ReentrantLock().ReadLock()
- WriteLock Write = new ReentrantLock().WriteLock()
### Semaphore
- 允许几个线程同时进行
- 类似红绿灯
- new Semaphore(1)
- s.acquire(),获得锁,将数量减一,归零则停住
- s.release() 归还
- 限流,最多允许多少线程在运行
### Exchanger 交换器
### LockSupport
- LockSupport.park(),当前线程阻塞
- (与锁定线程同时执行)LockSupport.unpark(线程对象名) 相当于在wait()前面调用notify()
## 面试题
- 实现一个容器,提供两个方法,add,size,写两个线程,线程1添加10个元素到容器钟,线程2实现监控元素的个数,当个数等于5个时,线程2给出提示并结束
    - 加volatile ,有问题,得加延时,不然观察不到(即使使用Collection.SynchronizedList(new ArrayList()))
        - 解释:在sleep的时候,有观察的动作
    - wait notify
        - synchronized: 观察线程wait,notify添加线程,添加线程到了5,notify观察线程,观察线程运行完,notify添加线程
    - countDownLatch: CountDownLatch(1),到了5,countDown 但是添加线程太快,可能顺序不符合预想
        - 解决,两个门闩
    - LockSupport
        - 类似countDownLatch的思路
- 写一个固定容量的同步容器,拥有put和get方法,以及getCount方法,能够支持2个生产者线程和10个消费者线程的的阻塞调用
    - synchronized,必须会写
        - wait()
        - notifyALl()
        - 为什么用while而不是if
            - 另一个线程++之后,自己线程没有再检查一遍,所以需要while
    - ReentrantLock 的Condition
        - 多个等待队列

## AQS源码分析(以上除了LockSupport全是基于AQS)
### 源码阅读原则
- 跑不起来不读
- 解决问题就好-目的性
- 一条线索到底
- 无关细节略过
- 一般不读静态
- 一般动态读法
### AQS 核心
- CAS操作替代了锁整条链表的操作
- CAS操作来操作tail
### VarHandle
- 指向某个变量的引用
- 原子性操作
- native cpu原语
- 比反射效率高很多
- 直接操纵二进制码
## ThreadLocal
- set
    - Thread.currentThread.map(ThreadLocal,person)
- 用途
    - 声明式事务,保证同一个Connection
### java引用

- 强软弱虚
- 强引用
    - 普通一般用的引用
    - 特点
        - 不会被垃圾回收器回收
- 软引用
    - 内存不够用的时候会回收
    - 做缓存用
    - full gc
- 弱引用
    - 只要遭遇到gc就会回收 
    - 作用
        - 一般用在容器里
        - 另一个强引用指向引用对象,引用断掉之后可以立即回收这个对象
    - ThreadLocal
        - ThreadLocalMap的key弱引用ThreadLocal,然后声明的变量强引用指向ThreadLocal
        - 如果强引用,则内存泄漏
        - 无比remove掉,不然还是会内存泄漏,(key值为null,value还存在(map还存在))
- 虚引用(给写jvm的人用的)
    - 管理堆外内存
    - gc就被回收
    - 回收之后可以从QUEUE中观测
    - 值get不到
    - NIO中有个DirectByteBuffer,指向堆外内存,用虚引用的QUEUE来查看堆外内存哪里需要回收
## 容器
### Collection
> 三大类
   > - List
   > - Set
   > - Queue
- Vector
    - 方法加了synchronized
- Queue
    - ConcurrentQueue
        - CAS操作
    
### Map
- Hashtable
    - 整个方法全加synchronized
- HashSet
    - 全不加
- SynchronizedHashMap
    - 效率没有比Hashtable高多少
    - 加synchronized,但粒度比hashtable细
- TreeMap
    - 红黑树
    
#### Concurrent容器
- ConcurrentHashMap 
    - CAS操作
    - 插入效率未必比其他的高
    - 读取效率非常高
- 没有ConcurrentTreeMap
    - CAS操作树结构十分复杂
- ConcurrentSkipListMap 跳表Map
    - 高并发且排序
- CopyOnWriteList 写时复制
    - 加元素的时候复制出来
    - 读的时候不加锁,写的时候加锁copy一个,然后把元素放上去,老指针指向新容器
    - 读多写少的情况下用
#### Queue
- 相比于vector,添加了对线程友好的API
    - offer 添加,返回是否成功,add则是失败抛异常
    - peek 取,不会remove
    - poll 取,并且remove
##### BlockingQueue
- put 添加 ,满了的话,线程阻塞住
- take 取,空了的话,线程阻塞住
    - LockSupport的park 
- 生产者消费者模型
- LinkedBlockingQueue
    - 链表实现的BlockingQueue
###### PriorityQueue 优先级队列
- 内部是二叉树
- 继承自AbstractQueue
    - 内部进行排序
        - 重写compareTo
###### DelayQueue
- 任务类需要继承Delay接口
- 按时间进行任务调度
    - new Task("t",System.currentTimeMillis()+500)
        - 五秒后运行
###### SynchronusQueue
- 容量为0,给另外线程下达任务的,任务调度
- 本质上概念类似于Exchanger
- 只put
    - 永远阻塞,等待消费(take)
- 不可以用add
    - 会提示Queue已经满了,即使有take等待
###### TransferQueue
- transfer(entry)
    - 装完,阻塞,等待被取走,取走之后再取消阻塞
- 类似于接单,有反馈的模型