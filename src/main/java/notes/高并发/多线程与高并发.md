# Note
## 基本概念
### 进程 线程 纤程(quasar)
- Java线程,详见Java笔记
    - 补充,可以有lambda表达式写法
    - 三种启动线程方式
        1. Thread
        2. Runnable
        3. Executors.newCachedThread(本质也是调用上两个)
    - sleep ,睡眠多少秒,其他线程可以运行
    - yield,加入等待队列,有可能立马还是自己
    - join , 调用另一个线程,保证顺序
    - interrupt , 抛出异常,处理catch
## 锁
###
####synchronized 
- 可重入锁
- synchronized(this) - > synchronized void m() ,static synchronized锁的是T.class
-保证原子性和可见性 
- 底层实现
    - 锁升级
        1. 偏向锁 标记线程
        2. 自旋锁 自旋十次 消耗cpu,用户态
        3. 重量级锁 - OS,os等待队列,不占cpu,但要跟os交互,内核态
        - 执行时间长,线程数多用系统锁
        - 执行时间段(加锁代码),线程数少,用自旋锁
- 不能阻止指令重排序
- 异常会释放锁
#### Lock
#### volatile(可变的)
- 保证线程可见性
    - MESI
    - 缓存一致性协议
- 禁止指令重排序
    - DCL单例
    - Double Check Lock
    - Mgr06.java 
    - loadfence原语指令
    - storefence原语指令
- 不能保证原子性


- dirty read
    - 锁写不锁读
- 优化,粗化,细化
#### AtomicXXX
- CAS(无锁优化 自选) compare and set/swap (乐观锁)
    - cas(V,Expected,NewValue)
      > if V==E   
        V=New otherwise try again or fail
    - cpu原语支持
    - ABA问题
        - 基础类型无所谓
        - 引用类型,女朋友符合,中间经历了别的...
       1. 不管
       2. 加版本号,检查版本号
    - Unsafe类=c c++指针
        - 直接操作内存
            - allocateMemory putXXX freeMemory pageSize
        - 直接生成实例
            - allocateInstance
        - 直接操作类或者实例变量
            - objectFiledOffset
            - getInt
            - getObject
        - CAS相关操作
            - weakCompareAndSetObject int Long   
#### LongAdder
- 分段锁(CAS操作)
- 分段式锁
## 各种JUC同步锁
### synchronized
- 锁进程调用锁进程
- notify() 不释放锁
### ReentrantLock lock 新型锁
- cas
- 手动上锁解锁
- try lock
    - `lock.tryLock(5,TimeUnit.SECONDS)` 
- lock.lockInterruptibly()
    - 通过打断来加锁
- 公平锁
    - `new ReentrantLock(true)`
    - 尽可能公平
    - 进入等待队列之前会检查队列里有没有人
- 可以有各种等待队列
### CountDownLatch 新型锁
 - cas
 - 计数,到了,放开wait
### CyclicBarrier
 - 人满发车
 - 限流

### Phaser
 - 过滤
 - 重写onAdvance(int phase,int registeredParties) 栅栏推到自动调用
     - phase为阶段数
     - registerParties 推到栅栏需要的数量
 - phaser.arriveAndAwaitAdvance() 到达并执行
 - phaser.arriveAndDeregister() 到达不执行
### ReadWriteLock -StampedLock
- 共享锁
- 排他锁
- ReadLock read = new ReentrantLock().ReadLock()
- WriteLock Write = new ReentrantLock().WriteLock()
### Semaphore
- 允许几个线程同时进行
- 类似红绿灯
- new Semaphore(1)
- s.acquire(),获得锁,将数量减一,归零则停住
- s.release() 归还
- 限流,最多允许多少线程在运行
### Exchanger 交换器
### LockSupport
- LockSupport.park(),当前线程阻塞
- (与锁定线程同时执行)LockSupport.unpark(线程对象名) 相当于在wait()前面调用notify()
## 面试题
- 实现一个容器,提供两个方法,add,size,写两个线程,线程1添加10个元素到容器钟,线程2实现监控元素的个数,当个数等于5个时,线程2给出提示并结束
    - 加volatile ,有问题,得加延时,不然观察不到(即使使用Collection.SynchronizedList(new ArrayList()))
        - 解释:在sleep的时候,有观察的动作
    - wait notify
        - synchronized: 观察线程wait,notify添加线程,添加线程到了5,notify观察线程,观察线程运行完,notify添加线程
    - countDownLatch: CountDownLatch(1),到了5,countDown 但是添加线程太快,可能顺序不符合预想
        - 解决,两个门闩
    - LockSupport
        - 类似countDownLatch的思路
- 写一个固定容量的同步容器,拥有put和get方法,以及getCount方法,能够支持2个生产者线程和10个消费者线程的的阻塞调用
    - synchronized,必须会写
        - wait()
        - notifyALl()
        - 为什么用while而不是if
            - 另一个线程++之后,自己线程没有再检查一遍,所以需要while
    - ReentrantLock 的Condition
        - 多个等待队列

## AQS源码分析(以上除了LockSupport全是基于AQS)
### 源码阅读原则
- 跑不起来不读
- 解决问题就好-目的性
- 一条线索到底
- 无关细节略过
- 一般不读静态
- 一般动态读法
 