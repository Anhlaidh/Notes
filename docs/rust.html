<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2024-04-30T19:18:20.830252"><title>Rust | Notes</title><script type="application/json" id="virtual-toc-data">[{"id":"i67twel_2557","level":0,"title":"特点","anchor":"#i67twel_2557"},{"id":"i67twel_2611","level":0,"title":"入门","anchor":"#i67twel_2611"},{"id":"i67twel_3186","level":0,"title":"问题","anchor":"#i67twel_3186"},{"id":"i67twel_3190","level":0,"title":"附录","anchor":"#i67twel_3190"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b259/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Rust | Notes"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Notes Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/notes/0.1/rust.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Rust | Notes"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/notes/0.1/rust.html#webpage",
    "url": "writerside-documentation/notes/0.1/rust.html",
    "name": "Rust | Notes",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentationnotes/#website",
    "url": "writerside-documentationnotes/",
    "name": "Notes Help"
}</script><!-- End Schema.org --></head><body data-id="Rust" data-main-title="Rust" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="README.md|Notes///Rust"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Notes 0.1 Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Rust" id="Rust.md">Rust</h1><p id="i67twel_2555"><a href="https://kaisery.github.io/trpl-zh-cn/ch05-03-method-syntax.html" id="i67twel_2556" data-external="true" rel="noopener noreferrer">Rust权威指南</a></p><section class="chapter"><h2 id="i67twel_2557" data-toc="i67twel_2557">特点</h2><ul class="list _bullet" id="i67twel_2558"><li class="list__item" id="i67twel_2559"><p>预编译</p></li><li class="list__item" id="i67twel_2560"><p>强类型</p></li><li class="list__item" id="i67twel_2561"><p>类型隐藏</p></li></ul><section class="chapter"><h3 id="java" data-toc="java">与java不同点</h3><ul class="list _bullet" id="i67twel_2562"><li class="list__item" id="i67twel_2563"><p id="i67twel_2564">变量不能二次赋值</p><ul class="list _bullet" id="i67twel_2565"><li class="list__item" id="i67twel_2566"><p id="i67twel_2567">如果需要二次赋值，需声明mut，即 <code class="code" id="i67twel_2568">let mut [var]</code></p><aside class="prompt" data-type="tip" data-title="" id="i67twel_2569"><p id="i67twel_2570">Rust认为，应该显式地区分可变于不可变，声明可变说明允许变量被修改, 默认不可变是因为，根据统计，一般而言不被修改的变量要比被修改的变量多 不可变变量，有利于防止一些傻*修改了本来不应该修改的值，导致发生灾难</p></aside></li></ul></li><li class="list__item" id="i67twel_2571"><p id="i67twel_2572">占位符 {} 类比log4j</p><ul class="list _bullet" id="i67twel_2573"><li class="list__item" id="i67twel_2574"><p>需要实现std::fmt::display</p></li><li class="list__item" id="i67twel_2575"><p>结构体打印可用<code class="code" id="i67twel_2576">{:?}</code>或<code class="code" id="i67twel_2577">{:#?}</code></p><ul class="list _bullet" id="i67twel_2578"><li class="list__item" id="i67twel_2579"><p>需添加std::fmt::Debug</p></li><li class="list__item" id="i67twel_2580"><p><code class="code" id="i67twel_2581">#[derive(Debug)]</code></p></li></ul></li></ul></li><li class="list__item" id="i67twel_2582"><p id="i67twel_2583">在需要类型转换时，可以对同一个变量多次声明</p></li><li class="list__item" id="i67twel_2584"><p id="i67twel_2585">move</p><aside class="prompt" data-type="tip" data-title="" id="i67twel_2586"><p id="i67twel_2587">为了保证内存安全，Rust不会尝试复制被分配的内存</p><p id="i67twel_2588">以string为例，s1=&quot;abc&quot;，s2=s1时，在java中，s2，s1都会指向heap的&quot;abc&quot;，且只有s1，s2都出作用域之后，对&quot;abc&quot;进行gc操作</p><p id="i67twel_2589">某些语言中，会在s1离开作用域后，进行一次drop操作，s2离开时会再重复一次，导致二次回收的bug</p><p id="i67twel_2590">在rust中，为了解决这个问题，在s2=s1之后，s1就失效了，此时调用s1，则会 <code class="code" id="i67twel_2591">value borrowed here after move</code></p></aside><ul class="list _bullet" id="i67twel_2592"><li class="list__item" id="i67twel_2593"><p id="i67twel_2594">在指针传入函数后，相当于进行了move操作，就失效了</p></li><li class="list__item" id="i67twel_2595"><p id="i67twel_2596">返回值也会有所有权转交的性质</p></li><li class="list__item" id="i67twel_2597"><p id="i67twel_2598">一旦struct的实例是可变的，那么实例中所有字段都是可变的</p></li><li class="list__item" id="i67twel_2599"><p id="i67twel_2600">枚举类型变体可以为不同的类型</p><aside class="prompt" data-type="tip" data-title="" id="i67twel_2601"><div class="code-block" data-lang="none">
enum IpAddressKind{
    V4(u8,u8,u8,u8),
    V6(String)
}
</div></aside></li><li class="list__item" id="i67twel_2603"><p id="i67twel_2604">rust没有null</p></li><li class="list__item" id="i67twel_2605"><p id="i67twel_2606">rust 所有条目默认为private</p></li><li class="list__item" id="i67twel_2607"><p id="i67twel_2608">rust UT允许测试私有函数</p></li><li class="list__item" id="i67twel_2609"><p id="i67twel_2610">文档注释支持markdown</p></li></ul></li></ul></section></section><section class="chapter"><h2 id="i67twel_2611" data-toc="i67twel_2611">入门</h2><ul class="list _bullet" id="i67twel_2612"><li class="list__item" id="i67twel_2613"><p>IDE vscode</p></li><li class="list__item" id="i67twel_2614"><p>振奋人心的hello world</p></li><li class="list__item" id="i67twel_2615"><p>编译命令 rustc 生成二进制文件</p></li></ul><section class="chapter"><h3 id="cargo" data-toc="cargo">cargo</h3><div class="code-block" data-lang="none">
[package]
name = &quot;rustLearning&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
rand = &quot;0.8.5&quot;
</div><ul class="list _bullet" id="i67twel_2617"><li class="list__item" id="i67twel_2618"><p>创建项目：cargo new </p><ul class="list _bullet" id="i67twel_2619"><li class="list__item" id="i67twel_2620"><p>Cargo.toml </p><ul class="list _bullet" id="i67twel_2621"><li class="list__item" id="i67twel_2622"><p>Cargo配置文件 </p><ul class="list _bullet" id="i67twel_2623"><li class="list__item" id="i67twel_2624"><p>依赖列表</p></li></ul></li></ul></li><li class="list__item" id="i67twel_2625"><p>src </p><ul class="list _bullet" id="i67twel_2626"><li class="list__item" id="i67twel_2627"><p>源代码</p></li></ul></li><li class="list__item" id="i67twel_2628"><p>Cargo.lock</p></li></ul></li><li class="list__item" id="i67twel_2629"><p>构建项目 </p><ul class="list _bullet" id="i67twel_2630"><li class="list__item" id="i67twel_2631"><p>cargo build </p><ul class="list _bullet" id="i67twel_2632"><li class="list__item" id="i67twel_2633"><p>生成cargo.lock文件 </p><ul class="list _bullet" id="i67twel_2634"><li class="list__item" id="i67twel_2635"><p>精确依赖版本</p></li></ul></li><li class="list__item" id="i67twel_2636"><p>cargo run 编译+执行二进制文件 /target/debug</p></li><li class="list__item" id="i67twel_2637"><p>cargo check 编译（比build快)</p></li><li class="list__item" id="i67twel_2638"><p>cargo build --release 发布构建 /target/release</p></li></ul></li></ul></li><li class="list__item" id="i67twel_2639"><p>依赖管理 </p><ul class="list _bullet" id="i67twel_2640"><li class="list__item" id="i67twel_2641"><p>Cargo.lock</p></li><li class="list__item" id="i67twel_2642"><p>Cargo.toml</p></li><li class="list__item" id="i67twel_2643"><p>Cargo build </p><ul class="list _bullet" id="i67twel_2644"><li class="list__item" id="i67twel_2645"><p>不修改版本号时，则根据Cargo.lock 编译</p></li><li class="list__item" id="i67twel_2646"><p>否则更新依赖</p></li></ul></li><li class="list__item" id="i67twel_2647"><p>Cargo update </p><ul class="list _bullet" id="i67twel_2648"><li class="list__item" id="i67twel_2649"><p>根据 toml编译，并将Cargo.lock更新为当前版本的最新小版本，[0.8.max]</p></li></ul></li></ul></li></ul></section><section class="chapter"><h3 id="demo" data-toc="demo">DEMO</h3><ul class="list _bullet" id="i67twel_2650"><li class="list__item" id="i67twel_2651"><p>生成随机数小游戏</p></li><li class="list__item" id="i67twel_2652"><p>声明变量 let </p><ul class="list _bullet" id="i67twel_2653"><li class="list__item" id="i67twel_2654"><p>显式声明变量类型 <code class="code" id="i67twel_2655">let [var] : [type]</code></p><ul class="list _bullet" id="i67twel_2656"><li class="list__item" id="i67twel_2657"><p>let guess: u32</p></li></ul></li></ul></li><li class="list__item" id="i67twel_2658"><p>io::stdin</p></li><li class="list__item" id="i67twel_2659"><section class="chapter"><h4 id="match" data-toc="match">match</h4></section></li><li class="list__item" id="i67twel_2660"><p>循环 </p><ul class="list _bullet" id="i67twel_2661"><li class="list__item" id="i67twel_2662"><p id="i67twel_2663">loop</p><aside class="prompt" data-type="tip" data-title="" id="i67twel_2664"><p id="i67twel_2665">使用loop进行无限循环，而不是while ture，while在rust中侧重于condition，而不是true，体现了rust的设计哲学：高度一致性 正如match中最后一个ram后面，可选择加逗号，语句一致性</p></aside></li></ul></li></ul></section><section class="chapter"><h3 id="rust" data-toc="rust">Rust</h3><section class="chapter"><h4 id="i67twel_2666" data-toc="i67twel_2666">变量常量</h4><ul class="list _bullet" id="i67twel_2667"><li class="list__item" id="i67twel_2668"><p>变量与可变性 </p><ul class="list _bullet" id="i67twel_2669"><li class="list__item" id="i67twel_2670"><p>声明变量用let</p></li><li class="list__item" id="i67twel_2671"><p>默认情况变量不可变（immutable)</p></li><li class="list__item" id="i67twel_2672"><p><code class="code" id="i67twel_2673">cannot assign twice to immutable variable</code></p></li></ul></li><li class="list__item" id="i67twel_2674"><p>常量 </p><ul class="list _bullet" id="i67twel_2675"><li class="list__item" id="i67twel_2676"><p>不可以用mut</p></li><li class="list__item" id="i67twel_2677"><p>用const关键字，类型必须被标注</p></li><li class="list__item" id="i67twel_2678"><p>可以在任何作用域声明，包括全局作用域</p></li><li class="list__item" id="i67twel_2679"><p>只可以绑定到常量表达式，无法绑定到函数的调用结果或只能在运行时才能计算的值 ==&gt;静态值？</p></li><li class="list__item" id="i67twel_2680"><p>命名规范与java相同</p></li></ul></li><li class="list__item" id="i67twel_2681"><p>shadowing </p><ul class="list _bullet" id="i67twel_2682"><li class="list__item" id="i67twel_2683"><p>可以使用相同的名字声明新的变量，新的变量会shadow之前的变量</p></li><li class="list__item" id="i67twel_2684"><p>后续代码中这个变量名则代表新的变量</p></li></ul></li></ul></section><section class="chapter"><h4 id="i67twel_2685" data-toc="i67twel_2685">数据类型</h4><ul class="list _bullet" id="i67twel_2686"><li class="list__item" id="i67twel_2687"><p>标量类型和复合类型 </p><ul class="list _bullet" id="i67twel_2688"><li class="list__item" id="i67twel_2689"><p>基于使用的值，编译器通常能推断出具体类型</p></li><li class="list__item" id="i67twel_2690"><p>可能的类型比较多，则需要添加类型标注</p></li><li class="list__item" id="i67twel_2691"><p>标量类型 </p><ul class="list _bullet" id="i67twel_2692"><li class="list__item" id="i67twel_2693"><p>一个标量类型表示一个单一的值</p></li><li class="list__item" id="i67twel_2694"><p>四种类型 </p><ul class="list _bullet" id="i67twel_2695"><li class="list__item" id="i67twel_2696"><p>整数类型 </p><ul class="list _bullet" id="i67twel_2697"><li class="list__item" id="i67twel_2698"><p>isize usize</p></li><li class="list__item" id="i67twel_2699"><p>除了byte之外，都允许使用类型后缀，57u8</p></li><li class="list__item" id="i67twel_2700"><p>默认i32</p></li><li class="list__item" id="i67twel_2701"><p>整数溢出 </p><ul class="list _bullet" id="i67twel_2702"><li class="list__item" id="i67twel_2703"><p>把u8的值设为256 </p><ul class="list _bullet" id="i67twel_2704"><li class="list__item" id="i67twel_2705"><p>调试模式下编译：Rust检查整数溢出，如果发生溢出，则程序在运行时会panic</p></li><li class="list__item" id="i67twel_2706"><p>发布模式下（--release）编译，rust不会检查可能导致Panic的整数溢出 </p><ul class="list _bullet" id="i67twel_2707"><li class="list__item" id="i67twel_2708"><p>如果发生溢出，rust会执行&quot;环绕&quot;操作 </p><ul class="list _bullet" id="i67twel_2709"><li class="list__item" id="i67twel_2710"><p>256变成0，257变成1</p></li><li class="list__item" id="i67twel_2711"><p>但程序不回panic</p></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="list__item" id="i67twel_2712"><p>浮点类型 </p><ul class="list _bullet" id="i67twel_2713"><li class="list__item" id="i67twel_2714"><p>f32</p></li><li class="list__item" id="i67twel_2715"><p>f64 默认</p></li></ul></li><li class="list__item" id="i67twel_2716"><p>bool </p><ul class="list _bullet" id="i67twel_2717"><li class="list__item" id="i67twel_2718"><p>true</p></li><li class="list__item" id="i67twel_2719"><p>false</p></li></ul></li><li class="list__item" id="i67twel_2720"><p>字符 </p><ul class="list _bullet" id="i67twel_2721"><li class="list__item" id="i67twel_2722"><p>与java相同</p></li></ul></li></ul></li></ul></li><li class="list__item" id="i67twel_2723"><p>复合类型 </p><ul class="list _bullet" id="i67twel_2724"><li class="list__item" id="i67twel_2725"><p>将多个值放在一个类型里面</p></li><li class="list__item" id="i67twel_2726"><p>rust提供两种基础的复合类型：元组（tuple）、数组 </p><ul class="list _bullet" id="i67twel_2727"><li class="list__item" id="i67twel_2728"><p>Tuple </p><ul class="list _bullet" id="i67twel_2729"><li class="list__item" id="i67twel_2730"><p>Tuple可以将多个类型的值放到一个类型里面</p></li><li class="list__item" id="i67twel_2731"><p>Tuple的长度是固定的，一旦声明无法改变</p></li></ul></li><li class="list__item" id="i67twel_2732"><p>数组 </p><ul class="list _bullet" id="i67twel_2733"><li class="list__item" id="i67twel_2734"><p>数据存放在栈(stack)内存上</p></li><li class="list__item" id="i67twel_2735"><p>没有vector灵活</p></li><li class="list__item" id="i67twel_2736"><p><code class="code" id="i67twel_2737">let [var]:[type;length]</code> 例如： <code class="code" id="i67twel_2738">let a:[i32:5]</code></p><ul class="list _bullet" id="i67twel_2739"><li class="list__item" id="i67twel_2740"><p>设置默认值： <code class="code" id="i67twel_2741">let a=[3;5]</code>即 <code class="code" id="i67twel_2742">let a=[3,3,3,3,3]</code></p></li><li class="list__item" id="i67twel_2743"><p>超出数组范围时，编译不报错，运行时panic</p></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></section><section class="chapter"><h4 id="i67twel_2744" data-toc="i67twel_2744">函数</h4><div class="code-block" data-lang="rust">
fn function(x: i32, y: String) {
}
</div><ul class="list _bullet" id="i67twel_2746"><li class="list__item" id="i67twel_2747"><p>命名规范 python xx_xx</p></li><li class="list__item" id="i67twel_2748"><p>参数</p></li><li class="list__item" id="i67twel_2749"><p>语句与表达式 </p><ul class="list _bullet" id="i67twel_2750"><li class="list__item" id="i67twel_2751"><p>语句无返回值，不能用let将一个语句赋值给一个变量</p></li></ul></li><li class="list__item" id="i67twel_2752"><p>函数返回值 </p><ul class="list _bullet" id="i67twel_2753"><li class="list__item" id="i67twel_2754"><p>在-&gt;符号后面声明函数返回值的类型，但是不能为返回值命名</p></li><li class="list__item" id="i67twel_2755"><p>rust里，返回值就是函数体最后一个表达式的值</p></li><li class="list__item" id="i67twel_2756"><p>若想提前返回，需要return</p></li></ul></li></ul></section><section class="chapter"><h4 id="i67twel_2757" data-toc="i67twel_2757">控制流</h4><section class="chapter"><h5 id="if-else" data-toc="if-else">if else</h5><div class="code-block" data-lang="rust">
if x &gt; 5 {
        return y;
    }else {
        return x.to_string() 
    }
</div><ul class="list _bullet" id="i67twel_2759"><li class="list__item" id="i67twel_2760"><p>if是表达式，可以放在 = 右边，给变量赋值</p></li></ul><div class="code-block" data-lang="rust">
return if x &gt; 5 {
        y
    } else {
        x.to_string()
    }
</div></section><section class="chapter"><h5 id="i67twel_2762" data-toc="i67twel_2762">循环</h5><ul class="list _bullet" id="i67twel_2763"><li class="list__item" id="i67twel_2764"><p>loop</p></li><li class="list__item" id="i67twel_2765"><p>while</p></li><li class="list__item" id="i67twel_2766"><p>for </p><ul class="list _bullet" id="i67twel_2767"><li class="list__item" id="i67twel_2768"><p>遍历集合 </p><ul class="list _bullet" id="i67twel_2769"><li class="list__item" id="i67twel_2770"><p><code class="code" id="i67twel_2771">for element in a.iter(){}</code></p></li></ul></li><li class="list__item" id="i67twel_2772"><p>range </p><ul class="list _bullet" id="i67twel_2773"><li class="list__item" id="i67twel_2774"><p>标准库提供</p></li><li class="list__item" id="i67twel_2775"><p>指定一个开始和结束，range生成他们之间的数字（左闭右开）</p></li><li class="list__item" id="i67twel_2776"><p>rev方法可以反转range</p></li><li class="list__item" id="i67twel_2777"><p><code class="code" id="i67twel_2778">for number in (1..4).rev(){}</code></p></li></ul></li></ul></li></ul></section></section><section class="chapter"><h4 id="i67twel_2779" data-toc="i67twel_2779">所有权</h4><ul class="list _bullet" id="i67twel_2780"><li class="list__item" id="i67twel_2781"><p>rust核心特性</p></li><li class="list__item" id="i67twel_2782"><p>解决垃圾回收，内存释放 </p><ul class="list _bullet" id="i67twel_2783"><li class="list__item" id="i67twel_2784"><p>对于某个值来说，拥有它的变量走出作用范围时，内存会立即自动交还给操作系统</p></li></ul></li><li class="list__item" id="i67twel_2785"><p>内存管理提前到了编译阶段</p></li></ul><section class="chapter"><h5 id="stack-vs-heap" data-toc="stack-vs-heap">Stack vs Heap</h5><ul class="list _bullet" id="i67twel_2786"><li class="list__item" id="i67twel_2787"><p>Stack vs Heap </p><ul class="list _bullet" id="i67twel_2788"><li class="list__item" id="i67twel_2789"><p>写数据 </p><ul class="list _bullet" id="i67twel_2790"><li class="list__item" id="i67twel_2791"><p>把值压到stack上不叫分配</p></li><li class="list__item" id="i67twel_2792"><p>指针在stack上</p></li><li class="list__item" id="i67twel_2793"><p>数据压到stack上比heap快很多</p></li><li class="list__item" id="i67twel_2794"><p>heap上分配空间需要更多工作</p></li></ul></li><li class="list__item" id="i67twel_2795"><p>读数据 </p><ul class="list _bullet" id="i67twel_2796"><li class="list__item" id="i67twel_2797"><p>类比java内存模型</p></li></ul></li></ul></li></ul></section><section class="chapter"><h5 id="i67twel_2798" data-toc="i67twel_2798">所有权规则</h5><ol class="list _decimal" id="i67twel_2799" type="1"><li class="list__item" id="i67twel_2800"><p>每个值都有一个变量，这个变量是这个值的所有者</p></li><li class="list__item" id="i67twel_2801"><p>每个值同时只能有一个所有者</p></li><li class="list__item" id="i67twel_2802"><p>当所有者超出作用域（scope）时，该值将被删除</p></li></ol><ul class="list _bullet" id="i67twel_2803"><li class="list__item" id="i67twel_2804"><p id="i67twel_2805">变量和数据的交互方式 ：move</p><aside class="prompt" data-type="tip" data-title="" id="i67twel_2806"><p id="i67twel_2807">s1=&quot;abc&quot; s2=s1 s1失效</p></aside><ul class="list _bullet" id="i67twel_2808"><li class="list__item" id="i67twel_2809"><p>浅拷贝</p></li><li class="list__item" id="i67twel_2810"><p>深拷贝 clone</p></li><li class="list__item" id="i67twel_2811"><p>rust中在将s2指针指向&quot;abc&quot;后，对s1进行了失效操作，对此称为&quot;move&quot;</p></li></ul></li><li class="list__item" id="i67twel_2812"><p id="i67twel_2813">copy trait 可以用于像整数这样完全存放在stack上面的类型</p><ul class="list _bullet" id="i67twel_2814"><li class="list__item" id="i67twel_2815"><p>除了四种标量类型，tuple如果都是标量，那么也具有copy trait</p></li></ul></li><li class="list__item" id="i67twel_2816"><p id="i67twel_2817">总结： 在一个作用域结束的时候，heap上的值要么被drop掉，要么被转交</p></li><li class="list__item" id="i67twel_2818"><p id="i67twel_2819">那么如何让函数使用某个值，但不获取所有权</p><ol class="list _decimal" id="i67twel_2820" type="1"><li class="list__item" id="i67twel_2821"><p>函数传入自己，再返回元组的时候把自己返回出来（非常麻烦）</p></li><li class="list__item" id="i67twel_2822"><p>引用</p></li></ol></li></ul><section class="chapter"><h6 id="i67twel_2823" data-toc="i67twel_2823">引用 借用</h6><ul class="list _bullet" id="i67twel_2824"><li class="list__item" id="i67twel_2825"><p id="i67twel_2826"><code class="code" id="i67twel_2827">&amp;</code>表示引用</p></li><li class="list__item" id="i67twel_2828"><p id="i67twel_2829">规则</p><ul class="list _bullet" id="i67twel_2830"><li class="list__item" id="i67twel_2831"><p>在任何给定的时刻，只能满足下列条件之一 </p><ul class="list _bullet" id="i67twel_2832"><li class="list__item" id="i67twel_2833"><p>一个可变的引用</p></li><li class="list__item" id="i67twel_2834"><p>任意数量不可变的引用 </p><ul class="list _bullet" id="i67twel_2835"><li class="list__item" id="i67twel_2836"><p>可以通过创建新的作用域，来允许非同时创建多个可变引用</p></li></ul></li></ul></li><li class="list__item" id="i67twel_2837"><p>引用必须一直有效</p></li></ul></li><li class="list__item" id="i67twel_2838"><p id="i67twel_2839">引用跟变量一样，默认是不可变的，同时可以加mut转为可变引用</p></li><li class="list__item" id="i67twel_2840"><p id="i67twel_2841">借用</p><ul class="list _bullet" id="i67twel_2842"><li class="list__item" id="i67twel_2843"><p>把引用作为函数参数的行为叫做借用</p></li></ul></li><li class="list__item" id="i67twel_2844"><p id="i67twel_2845">悬空引用（Dangling pointer）</p><ul class="list _bullet" id="i67twel_2846"><li class="list__item" id="i67twel_2847"><p>一个指针引用了内存中的某个地址，而这块内存可能已经释放并分配给其他人使用了</p></li><li class="list__item" id="i67twel_2848"><p>rust编译器保证引用永远都不是悬空引用 </p><ul class="list _bullet" id="i67twel_2849"><li class="list__item" id="i67twel_2850"><p>如果你引用了某些数据，编译器将保证在引用离开作用域前数据不会离开作用域</p></li></ul></li></ul></li></ul></section><section class="chapter"><h6 id="i67twel_2851" data-toc="i67twel_2851">切片</h6><ul class="list _bullet" id="i67twel_2852"><li class="list__item" id="i67twel_2853"><p>rust的另一种不持有所有权的数据类型：切片</p></li><li class="list__item" id="i67twel_2854"><p>slice 允许你引用集合中一段连续的元素序列，而不用引用整个集合</p></li><li class="list__item" id="i67twel_2855"><p>字符串字面值就是 slice</p></li></ul></section><section class="chapter"><h6 id="struct" data-toc="struct">struct</h6><ul class="list _bullet" id="i67twel_2856"><li class="list__item" id="i67twel_2857"><p>类比thrift</p></li><li class="list__item" id="i67twel_2858"><p>一旦struct的实例是可变的，那么实例中所有字段都是可变的</p></li><li class="list__item" id="i67twel_2859"><p>（语法糖）字段值跟变量名相同时，构造时可以简写</p></li><li class="list__item" id="i67twel_2860"><p>struct更新语法</p></li><li class="list__item" id="i67twel_2861"><p>tuple struct </p><ul class="list _bullet" id="i67twel_2862"><li class="list__item" id="i67twel_2863"><p>整体有名，元素没有名</p></li></ul></li><li class="list__item" id="i67twel_2864"><p>unit-like struct </p><ul class="list _bullet" id="i67twel_2865"><li class="list__item" id="i67twel_2866"><p>没有任何字段</p></li></ul></li><li class="list__item" id="i67twel_2867"><p>默认拥有所有字段所有权 </p><ul class="list _bullet" id="i67twel_2868"><li class="list__item" id="i67twel_2869"><p>也可以拥有引用，需要生命周期保证</p></li></ul></li><li class="list__item" id="i67twel_2870"><p>定义方法 </p><ul class="list _bullet" id="i67twel_2871"><li class="list__item" id="i67twel_2872"><p>impl [struct_name]</p></li></ul></li></ul></section><section class="chapter"><h6 id="i67twel_2873" data-toc="i67twel_2873">枚举</h6><ul class="list _bullet" id="i67twel_2874"><li class="list__item" id="i67twel_2875"><p>枚举类型变体可以为不同的类型</p></li><li class="list__item" id="i67twel_2876"><p>枚举方法</p></li><li class="list__item" id="i67twel_2877"><p>Option </p><ul class="list _bullet" id="i67twel_2878"><li class="list__item" id="i67twel_2879"><p>标准库</p></li><li class="list__item" id="i67twel_2880"><p>某个值可能存在（某种类型）或不存在的情况</p></li><li class="list__item" id="i67twel_2881"><p>内容 </p><ul class="list _bullet" id="i67twel_2882"><li class="list__item" id="i67twel_2883"><p>some</p></li><li class="list__item" id="i67twel_2884"><p>None</p></li></ul></li></ul></li></ul></section><section class="chapter"><h6 id="match" data-toc="match">match</h6><ul class="list _bullet" id="i67twel_2885"><li class="list__item" id="i67twel_2886"><p>必须穷举所有的可能 </p><ul class="list _bullet" id="i67twel_2887"><li class="list__item" id="i67twel_2888"><p><code class="code" id="i67twel_2889">_</code>通配符表示其余的可能，default</p></li></ul></li></ul></section><section class="chapter"><h6 id="if-let" data-toc="if-let">if let</h6><ul class="list _bullet" id="i67twel_2890"><li class="list__item" id="i67twel_2891"><p>match 一个（模式匹配）</p></li></ul></section></section></section><section class="chapter"><h4 id="i67twel_2892" data-toc="i67twel_2892">代码组织</h4><ul class="list _bullet" id="i67twel_2893"><li class="list__item" id="i67twel_2894"><p>lib项目 </p><ul class="list _bullet" id="i67twel_2895"><li class="list__item" id="i67twel_2896"><p>cargo new xxx --lib</p></li></ul></li><li class="list__item" id="i67twel_2897"><p>main项目 </p><ul class="list _bullet" id="i67twel_2898"><li class="list__item" id="i67twel_2899"><p>cargo new xxx</p></li></ul></li></ul><section class="chapter"><h5 id="super-pub-struct-enum" data-toc="super-pub-struct-enum">super pub struct enum</h5><ul class="list _bullet" id="i67twel_2900"><li class="list__item" id="i67twel_2901"><p>默认private，因此需要叫pub关键字</p></li><li class="list__item" id="i67twel_2902"><p>enum加完pub，所有变体都将pub</p></li></ul></section></section><section class="chapter"><h4 id="i67twel_2903" data-toc="i67twel_2903">集合</h4><ul class="list _bullet" id="i67twel_2904"><li class="list__item" id="i67twel_2905"><p>Vector </p><ul class="list _bullet" id="i67twel_2906"><li class="list__item" id="i67twel_2907"><p>Vec</p><p> 类比java new 一个list</p></li><li class="list__item" id="i67twel_2909"><p>初始宏： <code class="code" id="i67twel_2910">let v = vec![1,2,3];</code></p></li><li class="list__item" id="i67twel_2911"><p>写 </p><ul class="list _bullet" id="i67twel_2912"><li class="list__item" id="i67twel_2913"><p>push</p></li></ul></li><li class="list__item" id="i67twel_2914"><p>读 </p><ul class="list _bullet" id="i67twel_2915"><li class="list__item" id="i67twel_2916"><p>索引 编译时会检查索引是否超出，类比数组</p></li><li class="list__item" id="i67twel_2917"><p>get 返回option</p></li></ul></li></ul></li><li class="list__item" id="i67twel_2919"><p>String </p><ul class="list _bullet" id="i67twel_2920"><li class="list__item" id="i67twel_2921"><p>String是对Vec</p><p> 的包装</p></li><li class="list__item" id="i67twel_2923"><p>不能直接索引</p></li><li class="list__item" id="i67twel_2924"><p>bytes for遍历</p></li><li class="list__item" id="i67twel_2925"><p>chars for遍历 字型蔟</p></li><li class="list__item" id="i67twel_2926"><p>默认utf-8</p></li><li class="list__item" id="i67twel_2927"><p>可以切片 对于可变字节切片，遇到边界问题，程序会panic</p></li><li class="list__item" id="i67twel_2928"><p>HashMap &lt;k,v&gt; </p><ul class="list _bullet" id="i67twel_2929"><li class="list__item" id="i67twel_2930"><p id="i67twel_2931">HashMap::new()</p><ul class="list _bullet" id="i67twel_2932"><li class="list__item" id="i67twel_2933"><p>写 </p><ul class="list _bullet" id="i67twel_2934"><li class="list__item" id="i67twel_2935"><p>insert方法会move所有权，当然也可以传引用 </p><ul class="list _bullet" id="i67twel_2936"><li class="list__item" id="i67twel_2937"><p>相同key则覆盖</p></li></ul></li><li class="list__item" id="i67twel_2938"><p>entry or_insert() </p><ul class="list _bullet" id="i67twel_2939"><li class="list__item" id="i67twel_2940"><p>entry方法返回是否存在对应key</p></li></ul></li></ul></li></ul></li><li class="list__item" id="i67twel_2941"><p id="i67twel_2942">zip collect</p></li><li class="list__item" id="i67twel_2943"><div class="code-block" data-lang="rust">
fn main() {
  let teams = vec![&quot;Blue&quot;.to_string(), &quot;Yellow&quot;.to_string()];
  let scores = vec![10, 20];
  let map: HashMap&lt;_, _&gt; = teams.iter().zip(scores.iter()).collect();
  let string = format!(&quot;{:?}&quot;, map);
  print!(&quot;map: {}&quot;, string);
}

</div><aside class="prompt" data-type="tip" data-title="" id="i67twel_2945"><p id="i67twel_2946">zip()接受一个参数，将调用者中的元素与参数中的元素一一对应组成Tuple，若数量不匹配，多的元素会丢掉 collect()方法在形成了一个HashMap，元素的顺序并不固定，每一次run都可能不一样 当然key -&gt; value的顺序是由zip一一对应的，不是有collect决定的，请搞清楚</p></aside></li></ul></li></ul></li></ul></section><section class="chapter"><h4 id="i67twel_2947" data-toc="i67twel_2947">错误处理</h4><ul class="list _bullet" id="i67twel_2948"><li class="list__item" id="i67twel_2949"><p>panic </p><ul class="list _bullet" id="i67twel_2950"><li class="list__item" id="i67twel_2951"><p>自己代码中</p></li><li class="list__item" id="i67twel_2952"><p>依赖中</p></li><li class="list__item" id="i67twel_2953"><p>可以调用panic的回溯信息来定位问题代码</p></li><li class="list__item" id="i67twel_2954"><p>设置环境变量 RUST_BACKTRACE=1可得到回溯信息 </p><ul class="list _bullet" id="i67twel_2955"><li class="list__item" id="i67twel_2956"><p>MacOS使用： RUST_BACKTRACE=1 cargo run</p></li></ul></li></ul></li><li class="list__item" id="i67twel_2957"><p>Result枚举 </p><ul class="list _bullet" id="i67twel_2958"><li class="list__item" id="i67twel_2959"><p>match处理 </p><ul class="list _bullet" id="i67twel_2960"><li class="list__item" id="i67twel_2961"><p>unwrap 成功则返回对应值，否则panic，不能指定panic信息</p></li><li class="list__item" id="i67twel_2962"><p>expect 成功则返回对应值，否则panic，能指定panic信息</p></li></ul></li></ul></li><li class="list__item" id="i67twel_2963"><p>传播错误 （throw e） </p><ul class="list _bullet" id="i67twel_2964"><li class="list__item" id="i67twel_2965"><p>return Result&lt;T,io::Error&gt;</p></li><li class="list__item" id="i67twel_2966"><p>? 运算符 </p><ul class="list _bullet" id="i67twel_2967"><li class="list__item" id="i67twel_2968"><p>只能用于返回Result&lt;T,E&gt;的函数</p></li><li class="list__item" id="i67twel_2969"><p>main函数返回类型也可以为 Result&lt;T,E&gt;, <code class="code" id="i67twel_2970">Result&lt;(),Box&lt;dyn Error&gt;&gt;</code></p><ul class="list _bullet" id="i67twel_2971"><li class="list__item" id="i67twel_2972"><p><code class="code" id="i67twel_2973">Box&lt;dyn Error&gt;&gt;</code>可以简单理解为&quot;任何可能的错误类型&quot;</p></li></ul></li></ul></li><li class="list__item" id="i67twel_2974"><p>?与from</p></li></ul></li><li class="list__item" id="i67twel_2975"><p>什么时候用panic</p></li></ul></section><section class="chapter"><h4 id="trait" data-toc="trait">泛型 trait 生命周期</h4><ul class="list _bullet" id="i67twel_2976"><li class="list__item" id="i67twel_2977"><p>泛型</p></li><li class="list__item" id="i67twel_2978"><p>Trait 把方法签名放在一起来定义实现某种目的所必须的一组行为（类比interface） </p><ul class="list _bullet" id="i67twel_2979"><li class="list__item" id="i67twel_2980"><p>关键字 trait</p></li><li class="list__item" id="i67twel_2981"><p>只有方法签名，没有具体实现（可以有默认实现）</p></li><li class="list__item" id="i67twel_2982"><p>trait可以有多个方法：每个方法签名占一行，以<code class="code" id="i67twel_2983">;</code>结尾</p></li><li class="list__item" id="i67twel_2984"><p>实现trait的类型必须提供具体的方法实现</p></li><li class="list__item" id="i67twel_2985"><p>impl trait_name for struct_name{}</p></li><li class="list__item" id="i67twel_2986"><p>实现trait的约束 </p><ul class="list _bullet" id="i67twel_2987"><li class="list__item" id="i67twel_2988"><p>可以在某个类型上实现某个trait的前提条件是：这个类型或这个trait是在本地crate里定义的</p></li><li class="list__item" id="i67twel_2989"><p>无法为外部类型实现外部的trait </p><ul class="list _bullet" id="i67twel_2990"><li class="list__item" id="i67twel_2991"><p>这个限制是程序属性的一部分：一致性</p></li><li class="list__item" id="i67twel_2992"><p>孤儿规则：之所以这样命名是因为父类型不存在</p></li><li class="list__item" id="i67twel_2993"><p>此规则确保其他人的代码不能破坏你的代码，反之亦然</p></li><li class="list__item" id="i67twel_2994"><p>如果没有这个规则，两个crate可以为同一个</p></li></ul></li><li class="list__item" id="i67twel_2995"><p>作为参数 </p><ul class="list _bullet" id="i67twel_2996"><li class="list__item" id="i67twel_2997"><p><code class="code" id="i67twel_2998">fn a(a: impl trait_name +trait_2_name) -&gt; i32 {}</code></p></li><li class="list__item" id="i67twel_2999"><p>trait bound写法 <code class="code" id="i67twel_3000">fn notify&lt;T: trait_name+trait_2_name &gt;(item: T){}</code></p><ul class="list _bullet" id="i67twel_3001"><li class="list__item" id="i67twel_3002"><p>where写法 <code class="code" id="i67twel_3003">fn notify&lt;T &gt;(item: T) where T:trait_1_name+trait_2_name,...{}</code></p></li></ul></li></ul></li><li class="list__item" id="i67twel_3004"><p>作为返回值 <code class="code" id="i67twel_3005">fn a()-&gt; impl trait_1_name+trait_2_name</code></p><ul class="list _bullet" id="i67twel_3006"><li class="list__item" id="i67twel_3007"><p>impl trait 只能返回确定的同一种类型，返回可能不同的类型的代码会报错</p></li></ul></li></ul></li></ul></li><li class="list__item" id="i67twel_3008"><p>生命周期 </p><ul class="list _bullet" id="i67twel_3009"><li class="list__item" id="i67twel_3010"><p>rust的每个引用都有自己的生命周期</p></li><li class="list__item" id="i67twel_3011"><p>借用检查器</p></li><li class="list__item" id="i67twel_3012"><p>生命周期：引用保持有效的作用域</p></li><li class="list__item" id="i67twel_3013"><p>大多数情况：生命周期是隐式的、可被推断的</p></li><li class="list__item" id="i67twel_3014"><p>当引用的生命周期可能以不同的方式相互关联时：手动标注生命周期</p></li><li class="list__item" id="i67twel_3015"><p>语法 </p><ul class="list _bullet" id="i67twel_3016"><li class="list__item" id="i67twel_3017"><p>形如<code class="code" id="i67twel_3018">'a</code> 以<code class="code" id="i67twel_3019">'</code>开头，</p></li><li class="list__item" id="i67twel_3020"><p>生命周期标注位置（个人理解：以调用出发，先考虑传进去引用的参数的作用范围，再考量函数中生命周期的标注） </p><ul class="list _bullet" id="i67twel_3021"><li class="list__item" id="i67twel_3022"><p>在引用的&amp;后</p></li><li class="list__item" id="i67twel_3023"><p>空格将标注与引用类型分开</p></li></ul></li></ul></li><li class="list__item" id="i67twel_3024"><p>生命周期省略的三个规则（同样适用于fn和impl） </p><ol class="list _decimal" id="i67twel_3025" type="1"><li class="list__item" id="i67twel_3026"><p>每个引用类型的参数都有自己的生命周期</p></li><li class="list__item" id="i67twel_3027"><p>如果只有1个输入生命周期参数，那么该生命周期被赋予给所有的输出生命周期参数</p></li><li class="list__item" id="i67twel_3028"><p>如果有多个输入生命周期参数，但其中一个是&amp;self或&amp;mut self（是方法），那么self的生命周期会被赋予给所有的输出生命周期参数</p></li></ol></li><li class="list__item" id="i67twel_3029"><section class="chapter"><h5 id="i67twel_3030" data-toc="i67twel_3030">结构体方法生命周期语法</h5></section></li><li class="list__item" id="i67twel_3031"><p>静态生命周期 <code class="code" id="i67twel_3032">'static</code></p></li></ul></li></ul></section><section class="chapter"><h4 id="i67twel_3033" data-toc="i67twel_3033">测试</h4><ul class="list _bullet" id="i67twel_3034"><li class="list__item" id="i67twel_3035"><p id="i67twel_3036">cargo test</p><ul class="list _bullet" id="i67twel_3037"><li class="list__item" id="i67twel_3038"><p>会执行 包含<code class="code" id="i67twel_3039">#[Test]</code> attribute的方法 </p><ul class="list _bullet" id="i67twel_3040"><li class="list__item" id="i67twel_3041"><p><code class="code" id="i67twel_3042">#[Ignore]</code></p></li></ul></li><li class="list__item" id="i67twel_3043"><p>默认行为 </p><ul class="list _bullet" id="i67twel_3044"><li class="list__item" id="i67twel_3045"><p>并行运行 </p><ul class="list _bullet" id="i67twel_3046"><li class="list__item" id="i67twel_3047"><p>确保不回相互依赖，不依赖共享状态，或指定单线程</p></li></ul></li><li class="list__item" id="i67twel_3048"><p>所有测试</p></li></ul></li><li class="list__item" id="i67twel_3049"><p>命令行参数 </p><ul class="list _bullet" id="i67twel_3050"><li class="list__item" id="i67twel_3051"><p>--test-threads</p></li><li class="list__item" id="i67twel_3052"><p>cargo test --help</p></li><li class="list__item" id="i67twel_3053"><p>cargo test -- --help</p></li></ul></li></ul></li><li class="list__item" id="i67twel_3054"><p id="i67twel_3055">测试失败</p><ul class="list _bullet" id="i67twel_3056"><li class="list__item" id="i67twel_3057"><p>panic!</p></li><li class="list__item" id="i67twel_3058"><p>Assert </p><ul class="list _bullet" id="i67twel_3059"><li class="list__item" id="i67twel_3060"><p>assert! 判断true，false</p></li><li class="list__item" id="i67twel_3061"><p>assert_eq! &amp; assert_nq!</p></li><li class="list__item" id="i67twel_3062"><p>自定义错误信息，最后一个参数传打印内容，支持format</p></li></ul></li></ul></li><li class="list__item" id="i67twel_3063"><p id="i67twel_3064"><code class="code" id="i67twel_3065">#[should_panic]</code></p><ul class="list _bullet" id="i67twel_3066"><li class="list__item" id="i67twel_3067"><p>发生panic成功，未发生则失败</p></li><li class="list__item" id="i67twel_3068"><p>expected 标注panic的返回信息</p></li></ul></li><li class="list__item" id="i67twel_3069"><p id="i67twel_3070">Result&lt;T,E&gt;</p></li><li class="list__item" id="i67twel_3071"><p id="i67twel_3072">单元测试</p><ul class="list _bullet" id="i67twel_3073"><li class="list__item" id="i67twel_3074"><p>mod标注 <code class="code" id="i67twel_3075">#[cfg(Test)]</code></p></li><li class="list__item" id="i67twel_3076"><p>rust允许测试私有函数</p></li></ul></li><li class="list__item" id="i67twel_3077"><p id="i67twel_3078">集成测试</p><ul class="list _bullet" id="i67twel_3079"><li class="list__item" id="i67twel_3080"><p>tests目录 cargo test时才会编译 </p><ul class="list _bullet" id="i67twel_3081"><li class="list__item" id="i67twel_3082"><p>common 目录 tests的公共目录，不会被视为test crate</p></li></ul></li></ul></li><li class="list__item" id="i67twel_3083"><p id="i67twel_3084">binary crate 的集成测试</p><ul class="list _bullet" id="i67twel_3085"><li class="list__item" id="i67twel_3086"><p>没有lib.rs时 不能 在tests下创建集成测试，无法把main.rs的函数导入作用域</p></li></ul></li></ul></section><section class="chapter"><h4 id="demo" data-toc="demo">命令行程序DEMO</h4></section><section class="chapter"><h4 id="i67twel_3087" data-toc="i67twel_3087">闭包</h4><ul class="list _bullet" id="i67twel_3088"><li class="list__item" id="i67twel_3089"><p>闭包 </p><ul class="list _bullet" id="i67twel_3090"><li class="list__item" id="i67twel_3091"><p>匿名函数</p></li><li class="list__item" id="i67twel_3092"><p>保存为变量、作为参数</p></li><li class="list__item" id="i67twel_3093"><p>可在一个地方创建闭包，然后在另一个上下文中调用闭包来完成运算</p></li><li class="list__item" id="i67twel_3094"><p>可从其定义的作用域捕获值</p></li></ul></li></ul></section><section class="chapter"><h4 id="i67twel_3095" data-toc="i67twel_3095">迭代器</h4><ul class="list _bullet" id="i67twel_3096"><li class="list__item" id="i67twel_3097"><p>类比java函数式编程</p></li></ul></section><section class="chapter"><h4 id="cargo-crates-io" data-toc="cargo-crates-io">cargo crates.io</h4><ul class="list _bullet" id="i67twel_3098"><li class="list__item" id="i67twel_3099"><p>类比maven? </p><ul class="list _bullet" id="i67twel_3100"><li class="list__item" id="i67twel_3101"><p>profile</p></li></ul></li><li class="list__item" id="i67twel_3102"><p>cargo doc</p></li></ul></section><section class="chapter"><h4 id="i67twel_3103" data-toc="i67twel_3103">智能指针</h4><section class="chapter"><h5 id="box" data-toc="box">Box</h5><ul class="list _bullet" id="i67twel_3106"><li class="list__item" id="i67twel_3107"><p>特点 </p><ul class="list _bullet" id="i67twel_3108"><li class="list__item" id="i67twel_3109"><p>允许在heap上存储数据</p></li><li class="list__item" id="i67twel_3110"><p>stack上是指向heap数据的指针</p></li><li class="list__item" id="i67twel_3111"><p>没有性能开销以及其他额外功能</p></li></ul></li><li class="list__item" id="i67twel_3112"><p>场景 </p><ul class="list _bullet" id="i67twel_3113"><li class="list__item" id="i67twel_3114"><p>编译时大小无法确定，上下文需要知道确切大小</p></li><li class="list__item" id="i67twel_3115"><p>大量数据要移交所有权，需要确保操作时数据不会被复制</p></li><li class="list__item" id="i67twel_3116"><p>使用某个值只关心是否实现了特定trait，不用关心具体类型 </p><ul class="list _bullet" id="i67twel_3117"><li class="list__item" id="i67twel_3118"><p>例如&quot;链表&quot; Cons list </p><ul class="list _bullet" id="i67twel_3119"><li class="list__item" id="i67twel_3120"><p>用Box来包装</p></li></ul></li></ul></li></ul></li></ul></section><section class="chapter"><h5 id="deref" data-toc="deref">Deref</h5><ul class="list _bullet" id="i67twel_3121"><li class="list__item" id="i67twel_3122"><p id="i67twel_3123">例如String 和&amp;str?</p><ul class="list _bullet" id="i67twel_3124"><li class="list__item" id="i67twel_3125"><p>在参数判断类型时发生不一致，发生解引用</p></li><li class="list__item" id="i67twel_3126"><p>MyBox实现了deref trait，且MyBox是封装的String，那么MyBox可以被解引用为&amp;str</p></li></ul></li><li class="list__item" id="i67twel_3127"><p id="i67twel_3128">具有解引用的能力</p></li><li class="list__item" id="i67twel_3129"><p id="i67twel_3130">本质上是 *（deref())，所以返回的是引用类型</p></li><li class="list__item" id="i67twel_3131"><p id="i67twel_3132">解引用与可变性</p></li><li class="list__item" id="i67twel_3133"><p id="i67twel_3134">drop trait</p><ul class="list _bullet" id="i67twel_3135"><li class="list__item" id="i67twel_3136"><p>自定义值将要离开作用域时发生的动作</p></li><li class="list__item" id="i67twel_3137"><p>drop(c) 手动清理内存</p></li></ul></li><li class="list__item" id="i67twel_3138"><p id="i67twel_3139">Rc 引用计数</p><ul class="list _bullet" id="i67twel_3141"><li class="list__item" id="i67twel_3142"><p>Rc::clone(&amp;a) 增加引用 不可变引用 </p><ul class="list _bullet" id="i67twel_3143"><li class="list__item" id="i67twel_3144"><p>与clone方法的区别，Rc clone是clone指针，标准拷贝，clone是深拷贝</p></li></ul></li><li class="list__item" id="i67twel_3145"><p>Rc::strong_count(&amp;a) 获得引用计数（强引用） </p><ul class="list _bullet" id="i67twel_3146"><li class="list__item" id="i67twel_3147"><p>weak_count 弱引用</p></li></ul></li></ul></li><li class="list__item" id="i67twel_3148"><p id="i67twel_3149">内部可变性 允许在只持有不可变引用的前提下对数据进行修改，unsafe</p></li><li class="list__item" id="i67twel_3150"><p id="i67twel_3151">RefCell</p></li></ul></section></section><section class="chapter"><h4 id="i67twel_3153" data-toc="i67twel_3153">无畏并发</h4><ul class="list _bullet" id="i67twel_3154"><li class="list__item" id="i67twel_3155"><p>thread::spawn </p><ul class="list _bullet" id="i67twel_3156"><li class="list__item" id="i67twel_3157"><p>返回类型 joinHandle</p></li></ul></li><li class="list__item" id="i67twel_3158"><p>消息传递 </p><ul class="list _bullet" id="i67twel_3159"><li class="list__item" id="i67twel_3160"><p>go：不要用共享内存来通信，要用通信来共享内存</p></li><li class="list__item" id="i67twel_3161"><p>Channel 进行通信，支持多个发送方，一个消费方</p></li><li class="list__item" id="i67twel_3162"><p>也支持共享内存 </p><ul class="list _bullet" id="i67twel_3163"><li class="list__item" id="i67twel_3164"><p>Mutex 相当于多线程中的RefCell,需要先lock，再使用 </p><ul class="list _bullet" id="i67twel_3165"><li class="list__item" id="i67twel_3166"><p>用Arc</p><p> 封装使用，不能用Rc :Rc不支持多线程，需要实现Send方法才可以多线程</p></li></ul></li></ul></li></ul></li><li class="list__item" id="i67twel_3168"><p>Send和 Sync trait </p><ul class="list _bullet" id="i67twel_3169"><li class="list__item" id="i67twel_3170"><p>自己实现并发</p></li><li class="list__item" id="i67twel_3171"><p>Send 允许线程间转移所有权 </p><ul class="list _bullet" id="i67twel_3172"><li class="list__item" id="i67twel_3173"><p>实现Send trait 的类型可在线程间转移所有权</p></li><li class="list__item" id="i67twel_3174"><p>Rust中几乎所有类型都实现了Send，除了Rc</p></li><li class="list__item" id="i67twel_3175"><p>任何完全由Send类型组成的类型也被标记为Send</p></li><li class="list__item" id="i67twel_3176"><p>除了原始指针之外，几乎所有的基础类型都是Send</p></li></ul></li><li class="list__item" id="i67twel_3177"><p>Sync 允许从多线程访问 </p><ul class="list _bullet" id="i67twel_3178"><li class="list__item" id="i67twel_3179"><p>实现Sync的类型可以安全的被多个线程引用</p></li><li class="list__item" id="i67twel_3180"><p>T是Sync 那么&amp;T就是Send </p><ul class="list _bullet" id="i67twel_3181"><li class="list__item" id="i67twel_3182"><p>引用可以被安全的送往另一个县城</p></li></ul></li><li class="list__item" id="i67twel_3183"><p>基础类型都是Sync</p></li><li class="list__item" id="i67twel_3184"><p>完全由Sync类型组成的类型也是Sync</p></li><li class="list__item" id="i67twel_3185"></li></ul></li></ul></li></ul></section></section></section><section class="chapter"><h2 id="i67twel_3186" data-toc="i67twel_3186">问题</h2><div class="code-block" data-lang="rust">
let mut guess = String::new();
loop{
io::stdin().read_line(&amp;mut guess).expect(&quot;无法读取&quot;);
}
</div><p id="i67twel_3188">不能重新read</p><div class="code-block" data-lang="rust">
fn main() {
    let mut v = vec![1, 2, 3, 4, 5];
    let a = &amp;v[0];
    // v.push(6);
    println!(&quot;{}&quot;, a);
}
//如何在取完v[0]引用之后再像v中添加元素
</div></section><section class="chapter"><h2 id="i67twel_3190" data-toc="i67twel_3190">附录</h2><p id="i67twel_3191">vec-&gt;array</p><div class="code-block" data-lang="rust">
 #[test]
fn aes_test() {
  let decode = &amp;base64::decode(&quot;MTIzNDU2Nzg5MDEyMzQ1Ng==&quot;).unwrap()[..];
  let vec = &lt;&amp; [u8;16]&gt;::try_from(decode);
  println!(&quot;{:?}&quot;, vec);
}
</div></section><div class="last-modified">Last modified: 30 四月 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="c-01.html" class="navigation-links__prev">C#基础</a><a href="部署.html" class="navigation-links__next">部署</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b259/app.js"></script></body></html>