# 算法
## 基础
### 工具
- 对数器
    - 一个想要测的方法a
    - 实现复杂度不好但是容易实现的方法b
    - 实现一个随机样本产生器
    - 方法a和方法b相同的随机样本,看看得到的结果是否一样
    - 如果一个随机样本使得比对结果不一致,打印样本进行人工干预,改对方法a和方法b
    - 当样本数量很多时对比测试依然正确,可以确定方法a已经正确

- 比较器
    1. 比较器的实质是重载比较运算符
    2. 比较器可以很好的应用在特殊标准的排序上
    3. 比较器可以很好的应用在根据特殊标准排序的结构上
        - PriorityQueue 小根堆转大根堆
    4. 写代码变得异常容易,还用于泛型编程
### 运算
- 异或运算,二进制无进位相加
    - 性质:0^N=N,N^N=0
    - 满足交换律和结合律(同一批数异或答案一样,无论顺序)
    - ab互换
        1. a = a^b
        2. b = a^b
        3. a = a^b
        - ab必须指向不同内存
    - 提取最右侧1
        - N&((~N)+1)  N与((N取反)+1)
### 排序
- 桶排序
    - 数据状况强相关
    -计数排序
        - 设数组,累加
    - 基数排序
        - 非负十进制
        - 添0,入桶出桶
        - 权重逆着
- 排序算法的稳定性
    - 稳定性是指同样大小的样本再排序之后不会改变相对次序
    - 对基础类型来说,稳定性毫无意义
    - 对非基础类型来说,稳定性有重要意义
    - 有些算法可以实现成稳定的,而有些排序算法无论如何都实现不成稳定的
    - 有稳定性: -处理相等情况时的策略
        - 冒泡排序
        - 插入排序
        - 归并排序
        - 桶排序 十分稳定
            - 基数排序
            - 计数排序
    - 无稳定性:
        - 选择排序
        - 快排
            - partition过程必破坏稳定性
        - 堆排
- 序算法总结
1. 不基于比较的排序,对样本数据有严格的要求,不易改写
2. 基于比较的排序,只要规定好两个样本怎么比大小就可以直接复用
3. 基于比较的排序,时间复杂度的极限是O(NlogN)
4. 时间复杂度O(NlogN),额外空间复杂度低于O(N),且稳定的基于比较的排序是不存在的
5. 为了绝对的速度选快排,为了省空间选堆排,为了稳定选归并
6. 小规模用常数项小的排序,例如插入排序,大规模用调度优秀的排序,如快排
- 常见的坑
    1. 归并排序的额外空间复杂度可以变成O(1),"归并排序 内部缓存法",但是将变得不再稳定 ->直接堆排
    2. "原地归并排序"是垃圾帖,会让时间复杂度变成O(N^2) ->插入排序
    3. 快排稳定性改进,"01 stable sort",但是会对样本数据要求更多 ->桶排序
    4. 在整数数组中,请把奇数放在数组左边,偶数放在数组右边,要求所有奇数之间,偶数之间的原始相对次序不变
                时间复杂度做到O(N).空间复杂度做到O(1)


排序方法|时间复杂度(平均)|时间复杂度(最坏)	|时间复杂度(最好)|空间复杂度|稳定性|复杂性
---|---|---|---|---|---|---|
直接插入排序 |O(n2)|   O(n2)	        |O(n)	    |O(1)	   |     稳定	|简单
希尔排序    |O(nlog2n)|  O(n2)	    |O(n1.3)	|O(1)	   | 不稳定	|较复杂
直接选择排序 |O(n2)|  O(n2)	        |O(n2)	    |O(1)	   |     不稳定	|简单
堆排序      |O(nlog2n)|   O(nlog2n)  |O(nlog2n)  |O(1)	   | 不稳定	|较复杂
冒泡排序    |O(n2)	|  O(n2)	    |O(n)	    |O(1)	   | 稳定 |简单
快速排序    |O(nlog2n)|  O(n2)	    |O(nlog2n)	|O(nlog2n)|	不稳定	|较复杂
归并排序    |O(nlog2n)|  O(nlog2n)	|O(nlog2n)	|O(n)      | 稳定 |较复杂
基数排序    |O(d(n+r))|  O(d(n+r))	|O(d(n+r))	|O(n+r) |	稳定 |较复杂
## 数据结构
### 链表
- 反转链表,定义pre,next避免循环链表
- 笔试 ,不用太在乎空间复杂度,一切为了时间复杂度
- 面试,时间复杂度依然第一位,但一定要找到空间最省的方法
#### 快慢指针
1.输入链表头节点,奇数长度返回中点,偶数长度返回上中点
2.输入链表头节点,奇数长度返回中点,偶数长度返回下中点
3.输入链表头节点,奇数长度返回中点前一个,偶数长度返回上中点前一个
4.输入链表头节点,奇数长度返回中点前一个,偶数长度返回下中点前一个
    - 边界问题
    - 笔试直接arraylist
5. 判断回文链表
    - 笔试 ->压栈   
    - 快慢指针
        - 找中点,后半部分压栈,直到栈空,与前面节点顺序比较
    - 不用容器
        - 中点指向空,后半链表反着指,从两端往中间遍历,直到null
        - 最后要调回来
6. 将单向链表按某值划分成左边小中间相等右边大的形式
    1. 把链表放入数组里,在数组上做partition(笔试用)
    2. 分成小中大三个部分,再把各个部分之间串起来(面试用) ->6个变量,O(N)
        - (练)
7. 一种特殊的单链表类描述如下
        ```java
        
        class Node {
        int value;
        Node next;
        Node rand;
        Node(int val){value = val;}
        }
        ```
    - rand指针是单链表结构中新增的指针,rand可能指向链表中任意一个节点,也可能指向null
    给定一个由Node节点类型组成的无环单链表的头节点head,请实现一个函数完成这个链表的复制,并返回新的链表的头节点
        - 要求时间复杂度O(N)
        - 要求额外空间复杂度O(1)
    1. Hash表<Node,Node> 顺着比对装一遍,再遍历,用cur和get(cur)来进行复制
    2. 构造一个对应关系,例如1'在1后面2'在2后面,3'在3后面,找random找到老节点的random再next
        最后再在next方向分离出来
8. 给定两个可能有环也可能无环的单链表,头节点head1和head2,请实现一个函数,如果两个链表相交,请返回相交的第一个节点,如果不相交,返回null
    - 要求:如果两个长度之和为N,时间复杂度请达到O(N),额外空间复杂度达到O(1)
- 判定有无环,快慢指针,第一次相遇后,慢指针不动,快指针回原点,然后一起一次移动1个,下次相遇则是入环点
    a. 给一个链表,返回入环的节点
    b. 两个无环链表相交,返回第一个相交的节点
    c. 两个有环链表,找到第一个相交的节点
9. 能不能不给单链表头节点,只给删除的节点,就能做到在链表里删掉
    - 借尸还魂,复制下一个节点的值,子节点指向下下个
        a. 只替代了内容
        b. 很大局限
        c. 抖机灵
        d. 无法删除最后一个节点
    - 不行,很大问题,以上问题,必须要给头节点
    
### 栈
- 要求可以立即返回最小值,且pop,push,getMin为O(1)
    - 单调栈(同步弹出省时间费空间)
        - 两个栈,一个栈为普通栈
        - 另一个为单调栈,普通栈压入的时候单调栈压数,小则放,大则放之前最小的
        - 可以同步大小
    - 单调栈不同步压入(费时间省空间)
        - 判断当前两个栈顶是否一样
- 用栈拼队列
    - 两个栈
        - 一个push,一个pop
        - pop的时候倒过来再输出
            - pop栈为空的时候才可输出
            - push一次性倒完
### 队列
- 用队列拼栈
    - 分两个队列,data,help
        - 取的时候把data元素扔到help中,剩一个,输出
        - 然后help为data,data为help
### HashSet&HashMap
    - 增删改查均为O(1)
    - Integer等大类型在HashMap,HashSet中是按值传递
### 有序表 
- TreeMap 
    - firstKey() 最小的
    - lastKey() 最大的
    - 离xx最近且小于的 floorKey(xx)
    - 离xx最近且大于的 ceilingKey(xx)
    - O(logN)
- AVl
- 红黑树
- 跳表
### 堆
- 结构上:完全二叉树
    - 0开始
        - i的左子节点 2*i+1
        - i的右子节点 2*i+2
        - 父节点(i-1)/2
    - 1开始
        - i的左孩子 2*i  
    - 小根堆
        - 父节点是最小的
    - 均不是则不是堆
- 堆排序
    - 有关题目
        - 几乎有序的数组排序,每个数去往的位置不超过k
            - 生成小根堆
            - 前k+1放入小根堆
            - 当前最小的可能性 
- PriorityQueue
    - 小根堆
### 二叉树
- 先序
- 中序
- 后序
#### 递归序
- 递归转迭代
    - 压栈
        - 头右左
            1. 弹
            2. 如果有左,压入左
            3. 如果有右,压入右 
        - 左右节点反着压
        - 输出压栈
#### 序列化反序列化
- 留null 
### 前缀树
- 单个字符串中,字符从前到后的加到一棵多叉树上
- 字符放在路上,节点上又专属的数据项(常见的是pass和end值) 
- 所有样本都这样添加,如果没有就新建,如果有路就复用
- 沿途节点的pass值增加1,每个字符串结束时的节点end增加1

可以完成前缀相关的查询
## 递归
- Master公式
    - T(N) = aT(N/b)+O(N^d)
        - 子问题的规模是一致的(N/b)
        - 子问题调用了a次
        - 除了子问题调用之外,生下的复杂度为O(N^d)
        - log(b)a>d,O(N^log(b)a)
        - log(b)a<d,O(N^d)
        - log(b)a==d,O(N^d(*logN))

- 归并排序 思想
    - 左边数量多少个大,左边数量多少个小,右边数量多少个大,右边数量多少个小(用mergeSort改)
        - 在一个数组中,一个数左边比他小的数的总和,叫数的小和,所有数的小和累加起来,叫数组小和,求数组小和
            - 加返回值,修改merge()
        - 降序对 - 右边有多少个数比它小
- 快排 思想
    - 指定num,将数组分为小于等于num的和大于num的两个区
        - 设定小于等于区从-1开始,然后指针遍历数组直到越界
            - 如果当前数字大于num则不动,cur指针+1
            - 如果当前数字小于等于num,cur指针的数于小于等于区指针的数互换,小于等于区指针++,cur指针++
    - 给定num分成三块,小于区,等于区,大于区 
        - 分三个区,小于区,等于区,大于区,i跟大于区边界撞上的时候停止
            - arr[i]==num,i++
            - arr[i]<num,arr[i]与小于区的右一个交换(有等于的情况,与之前思路不同 ),小于区右扩,i++
            - arr[i]>num,arr[i]与大于区做一个交换,大于区左扩,i不变
    - 荷兰国旗问题
        - 以arr[R]划分
    - 快排1.0 O(n)
        - mid放中间,左右两侧递归
        - 有序的时候效率最低
    - 快排2.0 O(n)
        - 荷兰国旗问题,分为小于区,等于区,大于区,一次可以搞定一批等于的mid  
        - 有序的时候效率最低
    - 快排3.0随机快排 O(N logN)->概率累加期望 额外空间复杂度O(logN)
        - 随机找一个值跟arr[R]交换,然后执行2.0
    

        
        
     
## 预处理
### 前缀和求数组滚动窗口和   
## 问题范围和问题答案是否有线性规律
- 双端队列
    - 最xx优先级队列
    - 滑动窗口问题
- 单调栈
