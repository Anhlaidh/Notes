# 算法
## 基础
### 工具
- 对数器
    - 一个想要测的方法a
    - 实现复杂度不好但是容易实现的方法b
    - 实现一个随机样本产生器
    - 方法a和方法b相同的随机样本,看看得到的结果是否一样
    - 如果一个随机样本使得比对结果不一致,打印样本进行人工干预,改对方法a和方法b
    - 当样本数量很多时对比测试依然正确,可以确定方法a已经正确

- 比较器
    1. 比较器的实质是重载比较运算符
    2. 比较器可以很好的应用在特殊标准的排序上
    3. 比较器可以很好的应用在根据特殊标准排序的结构上
        - PriorityQueue 小根堆转大根堆
    4. 写代码变得异常容易,还用于泛型编程
### 运算
- 异或运算,二进制无进位相加
    - 性质:0^N=N,N^N=0
    - 满足交换律和结合律(同一批数异或答案一样,无论顺序)
    - ab互换
        1. a = a^b
        2. b = a^b
        3. a = a^b
        - ab必须指向不同内存
    - 提取最右侧1
        - N&((~N)+1)  N与((N取反)+1)
### 排序
- 排序算法的稳定性
    - 稳定性是指同样大小的样本再排序之后不会改变相对次序
    - 对基础类型来说,稳定性毫无意义
    - 对非基础类型来说,稳定性有重要意义
    - 有些算法可以实现成稳定的,而有些排序算法无论如何都实现不成稳定的
    - 有稳定性: -处理相等情况时的策略
        - 冒泡排序
        - 插入排序
        - 归并排序
        - 桶排序 十分稳定
            - 基数排序
            - 计数排序
    - 无稳定性:
        - 选择排序
        - 快排
            - partition过程必破坏稳定性
        - 堆排
- 序算法总结
1. 不基于比较的排序,对样本数据有严格的要求,不易改写
2. 基于比较的排序,只要规定好两个样本怎么比大小就可以直接复用
3. 基于比较的排序,时间复杂度的极限是O(NlogN)
4. 时间复杂度O(NlogN),额外空间复杂度低于O(N),且稳定的基于比较的排序是不存在的
5. 为了绝对的速度选快排,为了省空间选堆排,为了稳定选归并
6. 小规模用常数项小的排序,例如插入排序,大规模用调度优秀的排序,如快排
- 常见的坑
    1. 归并排序的额外空间复杂度可以变成O(1),"归并排序 内部缓存法",但是将变得不再稳定 ->直接堆排
    2. "原地归并排序"是垃圾帖,会让时间复杂度变成O(N^2) ->插入排序
    3. 快排稳定性改进,"01 stable sort",但是会对样本数据要求更多 ->桶排序
    4. 在整数数组中,请把奇数放在数组左边,偶数放在数组右边,要求所有奇数之间,偶数之间的原始相对次序不变
                时间复杂度做到O(N).空间复杂度做到O(1)

- 
排序方法|时间复杂度(平均)|时间复杂度(最坏)	|时间复杂度(最好)|空间复杂度|稳定性|复杂性
---|---|---|---|---|---|---|
直接插入排序 |O(n2)|   O(n2)	        |O(n)	    |O(1)	   |     稳定	|简单
希尔排序    |O(nlog2n)|  O(n2)	    |O(n1.3)	|O(1)	   | 不稳定	|较复杂
直接选择排序 |O(n2)|  O(n2)	        |O(n2)	    |O(1)	   |     不稳定	|简单
堆排序      |O(nlog2n)|   O(nlog2n)  |O(nlog2n)  |O(1)	   | 不稳定	|较复杂
冒泡排序    |O(n2)	|  O(n2)	    |O(n)	    |O(1)	   | 稳定 |简单
快速排序    |O(nlog2n)|  O(n2)	    |O(nlog2n)	|O(nlog2n)|	不稳定	|较复杂
归并排序    |O(nlog2n)|  O(nlog2n)	|O(nlog2n)	|O(n)      | 稳定 |较复杂
基数排序    |O(d(n+r))|  O(d(n+r))	|O(d(n+r))	|O(n+r) |	稳定 |较复杂
## 数据结构
- 链表
    - 反转链表,定义pre,next避免循环链表
- 栈
    - 要求可以立即返回最小值,且pop,push,getMin为O(1)
        - 单调栈(同步弹出省时间费空间)
            - 两个栈,一个栈为普通栈
            - 另一个为单调栈,普通栈压入的时候单调栈压数,小则放,大则放之前最小的
            - 可以同步大小
        - 单调栈不同步压入(费时间省空间)
            - 判断当前两个栈顶是否一样
    - 用栈拼队列
        - 两个栈
            - 一个push,一个pop
            - pop的时候倒过来再输出
                - pop栈为空的时候才可输出
                - push一次性倒完
- 队列
    - 用队列拼栈
        - 分两个队列,data,help
            - 取的时候把data元素扔到help中,剩一个,输出
            - 然后help为data,data为help
- HashSet&HashMap
    - 增删改查均为O(1)
    - Integer等大类型在HashMap,HashSet中是按值传递
- 有序表 
    - TreeMap 
        - firstKey() 最小的
        - lastKey() 最大的
        - 离xx最近且小于的 floorKey(xx)
        - 离xx最近且大于的 ceilingKey(xx)
        - O(logN)
    - AVl
    - 红黑树
    - 跳表
- 堆
    - 结构上:完全二叉树
        - 0开始
            - i的左子节点 2*i+1
            - i的右子节点 2*i+2
            - 父节点(i-1)/2
        - 1开始
            - i的左孩子 2*i i<<1
            - i的右孩子 2*i+1 i<<1|1
            - 父节点 i/2   i>>1
        - 大根堆
            - 父节点是最大的
        - 小根堆
            - 父节点是最小的
        - 均不是则不是堆
    - 堆排序
        - 有关题目
            - 几乎有序的数组排序,每个数去往的位置不超过k
                - 生成小根堆
                - 前k+1放入小根堆
                - 当前最小的可能性 
    - PriorityQueue
        - 小根堆
- 前缀树
    - 单个字符串中,字符从前到后的加到一棵多叉树上
    - 字符放在路上,节点上又专属的数据项(常见的是pass和end值) 
    - 所有样本都这样添加,如果没有就新建,如果有路就复用
    - 沿途节点的pass值增加1,每个字符串结束时的节点end增加1
    
    可以完成前缀相关的查询
- 桶排序
    - 数据状况强相关
    -计数排序
        - 设数组,累加
    - 基数排序
        - 非负十进制
        - 添0,入桶出桶
        - 权重逆着

### 递归
- Master公式
    - T(N) = aT(N/b)+O(N^d)
        - 子问题的规模是一致的(N/b)
        - 子问题调用了a次
        - 除了子问题调用之外,生下的复杂度为O(N^d)
        - log(b)a>d,O(N^log(b)a)
        - log(b)a<d,O(N^d)
        - log(b)a==d,O(N^d(*logN))

- 归并排序 思想
    - 左边数量多少个大,左边数量多少个小,右边数量多少个大,右边数量多少个小(用mergeSort改)
        - 在一个数组中,一个数左边比他小的数的总和,叫数的小和,所有数的小和累加起来,叫数组小和,求数组小和
            - 加返回值,修改merge()
        - 降序对 - 右边有多少个数比它小
- 快排 思想
    - 指定num,将数组分为小于等于num的和大于num的两个区
        - 设定小于等于区从-1开始,然后指针遍历数组直到越界
            - 如果当前数字大于num则不动,cur指针+1
            - 如果当前数字小于等于num,cur指针的数于小于等于区指针的数互换,小于等于区指针++,cur指针++
    - 给定num分成三块,小于区,等于区,大于区 
        - 分三个区,小于区,等于区,大于区,i跟大于区边界撞上的时候停止
            - arr[i]==num,i++
            - arr[i]<num,arr[i]与小于区的右一个交换(有等于的情况,与之前思路不同 ),小于区右扩,i++
            - arr[i]>num,arr[i]与大于区做一个交换,大于区左扩,i不变
    - 荷兰国旗问题
        - 以arr[R]划分
    - 快排1.0 O(n)
        - mid放中间,左右两侧递归
        - 有序的时候效率最低
    - 快排2.0 O(n)
        - 荷兰国旗问题,分为小于区,等于区,大于区,一次可以搞定一批等于的mid  
        - 有序的时候效率最低
    - 快排3.0随机快排 O(N logN)->概率累加期望 额外空间复杂度O(logN)
        - 随机找一个值跟arr[R]交换,然后执行2.0
    

        
        
     
## 预处理
### 前缀和求数组滚动窗口和   
## 问题范围和问题答案是否有线性规律
- 双端队列
    - 最xx优先级队列
    - 滑动窗口问题
- 单调栈
