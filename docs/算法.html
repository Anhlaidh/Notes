<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2024-04-30T19:18:20.869263"><title>Table of Contents | Notes</title><script type="application/json" id="virtual-toc-data">[{"id":"-ola9fq_2173","level":0,"title":"算法","anchor":"#-ola9fq_2173"},{"id":"-ola9fq_2174","level":0,"title":"数据结构","anchor":"#-ola9fq_2174"},{"id":"-ola9fq_2214","level":0,"title":"排序","anchor":"#-ola9fq_2214"},{"id":"-ola9fq_2216","level":0,"title":"分治","anchor":"#-ola9fq_2216"},{"id":"o-n-m","level":0,"title":"动态规划 O(n*m)","anchor":"#o-n-m"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b259/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Table of Contents | Notes"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Notes Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/notes/0.1/算法.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Table of Contents | Notes"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/notes/0.1/算法.html#webpage",
    "url": "writerside-documentation/notes/0.1/算法.html",
    "name": "Table of Contents | Notes",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentationnotes/#website",
    "url": "writerside-documentationnotes/",
    "name": "Notes Help"
}</script><!-- End Schema.org --></head><body data-id="算法" data-main-title="Table of Contents" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="README.md|Notes///java///notes///Java"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Notes 0.1 Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="算法" id="算法.md">Table of Contents</h1><ul class="list _bullet" id="-ola9fq_2133"><li class="list__item" id="-ola9fq_2134"><p><span id="-ola9fq_2135">算法</span></p><ul class="list _bullet" id="-ola9fq_2136"><li class="list__item" id="-ola9fq_2137"><p><span id="-ola9fq_2138">数据结构</span></p><ul class="list _bullet" id="-ola9fq_2139"><li class="list__item" id="-ola9fq_2140"><p><span id="-ola9fq_2141">队列(Queue)</span></p></li><li class="list__item" id="-ola9fq_2142"><p><span id="-ola9fq_2143">栈(Stack)</span></p></li><li class="list__item" id="-ola9fq_2144"><p><span id="-ola9fq_2145">树(Tree)</span></p><ul class="list _bullet" id="-ola9fq_2146"><li class="list__item" id="-ola9fq_2147"><p><span id="-ola9fq_2148">二叉树(BinaryTree)</span></p><ul class="list _bullet" id="-ola9fq_2149"><li class="list__item" id="-ola9fq_2150"><p><span id="-ola9fq_2151">BST</span></p></li><li class="list__item" id="-ola9fq_2152"><p><span id="-ola9fq_2153">AVL</span></p></li><li class="list__item" id="-ola9fq_2154"><p><span id="-ola9fq_2155">红黑树</span></p></li></ul></li></ul></li><li class="list__item" id="-ola9fq_2156"><p><span id="-ola9fq_2157">图(Map)</span></p></li></ul></li><li class="list__item" id="-ola9fq_2158"><p><span id="-ola9fq_2159">排序</span></p></li><li class="list__item" id="-ola9fq_2160"><p><span id="-ola9fq_2161">分治</span></p></li><li class="list__item" id="-ola9fq_2162"><p><span id="-ola9fq_2163">动态规划 O(n*m)</span></p><ul class="list _bullet" id="-ola9fq_2164"><li class="list__item" id="-ola9fq_2165"><p><span id="-ola9fq_2166">题目特点</span></p></li><li class="list__item" id="-ola9fq_2167"><p><span id="-ola9fq_2168">解题步骤</span></p></li><li class="list__item" id="-ola9fq_2169"><p><span id="-ola9fq_2170">动态规划初探</span></p></li><li class="list__item" id="-ola9fq_2171"><p><span id="-ola9fq_2172">优化</span></p></li></ul></li></ul></li></ul><section class="chapter"><h2 id="-ola9fq_2173" data-toc="-ola9fq_2173">算法</h2></section><section class="chapter"><h2 id="-ola9fq_2174" data-toc="-ola9fq_2174">数据结构</h2><section class="chapter"><h3 id="queue" data-toc="queue">队列(Queue)</h3></section><section class="chapter"><h3 id="stack" data-toc="stack">栈(Stack)</h3></section><section class="chapter"><h3 id="tree" data-toc="tree">树(Tree)</h3><section class="chapter"><h4 id="-ola9fq_2175" data-toc="-ola9fq_2175">遍历</h4><p id="-ola9fq_2176">前序遍历 PreOrderTraversal<br> - 根左右 - 树状结构展示（注意左右子树的顺序） 中序遍历 InorderTraversal - 左根右 - 二叉搜索树的中序遍历按升序或降序处理节点 后序遍历 postOrderTraversal<br> - 左右根 - 适用于一些先子后父的操作 层次遍历<br> - 层级遍历 - 计算二叉树的高度 - 判断是否为完全二叉树</p></section><section class="chapter"><h4 id="-ola9fq_2180" data-toc="-ola9fq_2180">二叉搜索树</h4><ul class="list _bullet" id="-ola9fq_2181"><li class="list__item" id="-ola9fq_2182"><p>任意一个节点的值都大于左子树所有结点的值</p></li><li class="list__item" id="-ola9fq_2183"><p>任意一个节点的值都小于右子树所有节点的值</p></li><li class="list__item" id="-ola9fq_2184"><p>他的左右子树也是一颗二叉搜索树</p></li><li class="list__item" id="-ola9fq_2185"><p>二叉搜索树可以大大提高搜索数据的效率</p></li><li class="list__item" id="-ola9fq_2186"><p>元素必须剧有可比较性</p></li></ul></section><section class="chapter"><h4 id="-ola9fq_2187" data-toc="-ola9fq_2187">接口设计</h4><p id="-ola9fq_2188">int size() //元素的数量<br> boolean isEmpty() //是否为空<br> void clear() //清空所有元素<br> void add(E element) //添加元素<br> void remove(E element) //删除元素<br> boolean contains(E element )//是否包含元素</p><ul class="list _bullet" id="-ola9fq_2194"><li class="list__item" id="-ola9fq_2195"><p>元素没有索引的概念</p></li></ul></section><section class="chapter"><h4 id="-ola9fq_2196" data-toc="-ola9fq_2196">前驱节点</h4><ul class="list _bullet" id="-ola9fq_2197"><li class="list__item" id="-ola9fq_2198"><p>中序遍历的前一个节点</p></li></ul></section><section class="chapter"><h4 id="-ola9fq_2199" data-toc="-ola9fq_2199">后继节点</h4><ul class="list _bullet" id="-ola9fq_2200"><li class="list__item" id="-ola9fq_2201"><p>中序遍历的后一个节点</p></li></ul><section class="chapter"><h5 id="binarytree" data-toc="binarytree">二叉树(BinaryTree)</h5><div class="code-block" data-lang="java">
package notes.Java.JavaLearning_Advanced.Tree;

import notes.Java.JavaLearning_Advanced.Tree.Util.TreePrinter;

import java.util.LinkedList;
import java.util.Queue;

/**
 * @Description:
 * @author: Anhlaidh
 * @date: 2020/4/5 0005 22:44
 */
public class BinaryTree&lt;E&gt; {
    protected int size;
    Node&lt;E&gt; root;
    public Node&lt;E&gt; getRoot() {
        return root;
    }
    public int size() {
        return 0;
    }
    public boolean isEmpty() {
        return size == 0;
    }
    public void clear() {
        size = 0;
        root = null;

    }
    /*
     * 中序遍历
     * 左根右
     * 因为是二叉搜索树，所以中序遍历为有序
     * */
    public void inOrderTraversal(Visitor&lt;E&gt; visitor) {
        inOrderTraversal(root,visitor);
    }
    private void inOrderTraversal(Node&lt;E&gt; node,Visitor&lt;E&gt; visitor) {
        if (visitor==null||node==null) {
return;}
        inOrderTraversal(node.left,visitor);
        visitor.visit(node.element);
        inOrderTraversal(node.right,visitor);
    }
    /*
     * 前序遍历
     * 根左右
     * */
    public void preOrderTraversal(Visitor&lt;E&gt; visitor) {
        preOrderTraversal(root,visitor);
    }
    private void preOrderTraversal(Node&lt;E&gt; node,Visitor&lt;E&gt; visitor) {
        if (visitor==null||node==null) {
return;}
        visitor.visit(node.element);
        preOrderTraversal(node.left,visitor);
        preOrderTraversal(node.right,visitor);
    }
    /*
     * 后序遍历
     * 左右根
     * */
    public void postOderTraversal(Visitor&lt;E&gt; visitor) {
        postOderTraversal(root,visitor);
    }
    private void postOderTraversal(Node&lt;E&gt; node,Visitor&lt;E&gt; visitor) {
        if (visitor==null||node==null) {
return;}
        postOderTraversal(node.left,visitor);
        postOderTraversal(node.right,visitor);
        visitor.visit(node.element);
    }
    /*
     * 层序遍历
     *
     * */
    public void levelOrderTraversal(Visitor visitor) {
        if (root==null) {
return;}
        Queue&lt;Node&lt;E&gt;&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(root);
        while (!queue.isEmpty()) {
            Node&lt;E&gt; node = queue.poll();
            visitor.visit(node.element);
            if (node.left != null) {
                queue.offer(node.left);
            }
            if (node.right != null) {
                queue.offer(node.right);
            }

        }
    }
    private Node&lt;E&gt; predecessor(Node&lt;E&gt; node) {
        if (node==null) {
return null;}
        //前驱节点在左子树中
        Node&lt;E&gt; p = node.left;
        if (p != null) {
            while (p.right != null) {
                p = p.right;
            }
            return p;
        }
        //从父节点，祖父节点中寻找前驱节点
        while (node.parent != null &amp;&amp; node == node.parent.left) {
            node = node.parent;
        }
        return node.parent;
    }
    protected Node&lt;E&gt; successor(Node&lt;E&gt; node) {
        if (node==null) {
return null;}
        //前驱节点在左子树中
        Node&lt;E&gt; p = node.right;
        if (p != null) {
            while (p.left != null) {
                p = p.left;
            }
            return p;
        }
        //从父节点，祖父节点中寻找前驱节点
        while (node.parent != null &amp;&amp; node == node.parent.right) {
            node = node.parent;
        }
        return node.parent;
    }

    /*
     *
     * 计算高度
     * 递归
     * */
    public int height() {
        return height(root);
    }
    private int height(Node&lt;E&gt; node) {
        if (node == null) {
            return 0;
        }
        return 1 + Math.max(height(node.left), height(node.right));

    }
    public boolean isComplete() {
        if (root==null) {
return false;}
        Queue&lt;Node&lt;E&gt;&gt; queue = new LinkedList&lt;&gt;();
        queue.add(root);
        boolean leaf = false;
        while (!queue.isEmpty()) {
            Node&lt;E&gt; node = queue.poll();
            if (leaf &amp;&amp; !node.isLeaf()) {
                return false;
            }
            if (node.left != null) {
                queue.offer(node.left);
            } else if (node.right != null) {
                return false;
            }
            if (node.right != null) {
                queue.offer(node.right);
            } else {
                leaf = true;
            }

        }
        return true;
    }
    protected static class Node&lt;E&gt; implements TreePrinter.PrintableNode {
        E element;
        Node&lt;E&gt; left;
        Node&lt;E&gt; right;
        Node&lt;E&gt; parent;

        public Node(E element, Node&lt;E&gt; parent) {
            this.element = element;
            this.parent = parent;
        }

        @Override
        public String toString() {
            if (parent==null) {
return element+&quot;&quot;;}
            return element + &quot;_P(&quot; + parent.element + &quot;)&quot;;
        }

        public boolean isLeaf() {
            return left == null &amp;&amp; right == null;
        }

        public boolean hasTwoChildren() {
            return left != null &amp;&amp; right != null;
        }

        public boolean isLeftChild() {
            return parent != null &amp;&amp; this == parent.left;
        }
        public boolean isRightChild() {
            return parent != null &amp;&amp; this == parent.right;
        }

        @Override
        public TreePrinter.PrintableNode getLeft() {
            return left;
        }

        @Override
        public TreePrinter.PrintableNode getRight() {
            return right;
        }

        @Override
        public String getText() {
            return element.toString();
        }


    }
    public interface Visitor&lt;E&gt; {
        void visit(E element);
    }

    protected Node&lt;E&gt; createNode(E element, Node&lt;E&gt; parent) {
        return new Node&lt;&gt;(element, parent);
    }
}

</div><section class="chapter"><h6 id="bst" data-toc="bst">BST</h6><div class="code-block" data-lang="java">
package notes.Java.JavaLearning_Advanced.Tree;

import java.util.Comparator;

/**
 * @Description:
 * @author: Anhlaidh
 * @date: 2020/4/3 0003 21:19
 */
public class BST&lt;E&gt; extends BinaryTree implements IBinarySearchTree&lt;E&gt;{
    Comparator&lt;E&gt; comparator;


    public BST(Comparator&lt;E&gt; comparator) {
        this.comparator = comparator;
    }

    public BST() {
        comparator = null;
    }


    private void elementNotNullCheck(E element) {
        if (element == null) {
            throw new IllegalArgumentException(&quot;element must not be null&quot;);
        }
    }

    public void add(E element) {
        if (root == null) {//添加第一个节点
            root = createNode(element, null);
            size++;
            afterAdd(root);
            return;
        }
        //添加的不是第一个节点
        //找到父节点
        Node&lt;E&gt; parent = null;
        Node&lt;E&gt; node = root;
        int cmp = 0;
        while (node != null) {
            cmp = compare(element, node.element);
            parent = node;
            if (cmp &gt; 0) {
                node = node.right;
            } else if (cmp &lt; 0) {
                node = node.left;
            } else {
                node.element = element;
                return;//两个数字相同时
            }
        }
        //看看插入到父节点的哪个位置
        Node&lt;E&gt; newNode = createNode(element, parent);
        if (cmp &gt; 0) {
            parent.right = newNode;
        } else {
            parent.left = newNode;
        }
        size++;
        afterAdd(newNode);

    }

    protected void afterAdd(Node&lt;E&gt; node) { }

    public void remove(E element) {
        remove(node(element));

    }

    private void remove(Node&lt;E&gt; node) {
        if (node==null) {
return;}
        size--;
        //度为2的节点
        if (node.hasTwoChildren()) {
         //找到后继节点
            Node&lt;E&gt; p = successor(node);
            //用后继节点覆盖度为2的节点的值
            node.element = p.element;
            //删除后继节点
            node = p;//TODO 我认为不是很妥

        }
        //删除node节点(node的度必然是0或1)
        Node&lt;E&gt; replacement = node.left != null ? node.left : node.right;
        //node是度为1 的节点
        if (replacement != null) {
            //更改parent
            replacement.parent = node.parent;
            //更改parent的left、right指向
            if (node.parent != null) {
                root = replacement;
            } else if (node == node.parent.left) {
                node.parent.left = replacement;
            } else {// node = node.parent.right
                node.parent.right = replacement;
            }
        } else if (node.parent == null) {//node是叶子节点并且是根节点
            root = null;
        } else {//node是叶子节点，但不是根节点
            if (node == node.parent.left) {
                node.parent.left = null;
            } else {
                node.parent.right = null;
            }

        }

    }

    private Node&lt;E&gt; node(E element) {
        Node&lt;E&gt; p = root;

        while (p != null) {
            int cmp = compare(element, p.element);
            if (cmp &lt; 0) {
                p = p.left;
            }
            if (cmp==0) {
return p;}
            if (cmp &gt; 0) {
                p = p.right;
            }
        }
        return null;
    }

    public boolean contains(E element) {
        return node(element) != null;
    }

    private int compare(E e1, E e2) {
        if (comparator != null) {
           return comparator.compare(e1, e2);
        }
        return ((Comparable&lt;E&gt;) e1).compareTo(e2);
    }


}

</div></section><section class="chapter"><h6 id="avl" data-toc="avl">AVL</h6><ul class="list _bullet" id="-ola9fq_2204"><li class="list__item" id="-ola9fq_2205"><p>平衡因子(Balance Factor)：某节点的左右子树高度</p></li><li class="list__item" id="-ola9fq_2206"><p>AVL树的特点 </p><ul class="list _bullet" id="-ola9fq_2207"><li class="list__item" id="-ola9fq_2208"><p>每个节点的平衡因子只可能是1、0、-1(绝对值&lt;=1，如果超过1，称之为 &quot;失衡&quot;)</p></li><li class="list__item" id="-ola9fq_2209"><p>每个节点的左右子树高度差不超过1</p></li><li class="list__item" id="-ola9fq_2210"><p>搜索添加删除的时间复杂度是O(Logn)</p></li></ul></li></ul><div class="code-block" data-lang="java">
package notes.Java.JavaLearning_Advanced.Tree;

import java.util.Comparator;

/**
 * @Description:
 * @author: Anhlaidh
 * @date: 2020/4/5 0005 23:07
 */
public class AVLTree&lt;E&gt; extends BST&lt;E&gt; {
    public AVLTree(Comparator&lt;E&gt; comparator) {
        super(comparator);
    }

    public AVLTree() {
        this(null);
    }

    @Override
    protected void afterAdd(Node&lt;E&gt; node) {
        do {
            if (isBalanced(node)) {
                //更新高度
                updateHeight(node);
            } else {
                //恢复平衡
                reBalance(node);
                //整棵树恢复平衡
                break;
            }
        } while ((node = node.parent) != null);

    }

    private void reBalance(Node&lt;E&gt; grand) {
        Node&lt;E&gt; parent = ((AVLNode&lt;E&gt;) grand).tallerChild();
        Node&lt;E&gt; node = ((AVLNode) parent).tallerChild();
        if (parent.isLeftChild()) {
            if (node.isLeftChild()) {//LL
                rotateRight(grand);
            } else {//LR
                rotateLeft(parent);
                rotateRight(grand);
            }
        } else {
            if (node.isLeftChild()) {//RL
                rotateRight(parent);
                rotateLeft(grand);
            } else {//RR
                rotateLeft(grand);

            }
        }


    }

    private void rotateLeft(Node&lt;E&gt; grand) {
        Node&lt;E&gt; parent = grand.right;
        Node&lt;E&gt; child = parent.left;
        grand.right = child;
        parent.left = grand;
        afterRotate(grand, parent, child);
    }

    private void rotateRight(Node&lt;E&gt; grand) {
        Node&lt;E&gt; parent = grand.left;
        Node&lt;E&gt; child = parent.right;
        grand.left = child;
        parent.right = grand;
        afterRotate(grand, parent, child);

    }

    private void afterRotate(Node&lt;E&gt; grand, Node&lt;E&gt; parent, Node&lt;E&gt; child) {

        parent.parent = grand.parent;

        // 让parent成为子树的根节点
        if (grand.isLeftChild()) {
            grand.parent.left = parent;
        } else if (grand.isRightChild()) {
            grand.parent.right = parent;
        }else {
            root = parent;
        }

        if (child != null) {
            child.parent = grand;
        }
        grand.parent = parent;
        updateHeight(grand);
        updateHeight(parent);

    }

    class AVLNode&lt;E&gt; extends Node&lt;E&gt; {
        int height;

        public AVLNode(E element, Node&lt;E&gt; parent) {
            super(element, parent);
        }

        public int balanceFactor() {
            int leftHeight = left==null?0:((AVLNode&lt;E&gt;)left).height;
            int rightHeight = right == null ? 0 : ((AVLNode&lt;E&gt;) right).height;
            return leftHeight - rightHeight;
        }
        public void updateHeight() {
            int leftHeight = left == null ? 0 : ((AVLNode&lt;E&gt;) left).height;
            int rightHeight = right == null ? 0 : ((AVLNode&lt;E&gt;) right).height;
            height = 1 + Math.max(leftHeight, rightHeight);
        }

        public Node&lt;E&gt; tallerChild() {
            int leftHeight = left==null?0:((AVLNode&lt;E&gt;)left).height;
            int rightHeight = right == null ? 0 : ((AVLNode&lt;E&gt;) right).height;
            if (leftHeight &gt; rightHeight) {
return left;}
            if (leftHeight &lt; rightHeight)  {
return right;}
            return isLeftChild() ? left : right;

        }
    }

    private boolean isBalanced(Node&lt;E&gt; node) {
        return Math.abs(((AVLNode&lt;E&gt;) node).balanceFactor()) &lt;= 1;
    }

    private void updateHeight(Node&lt;E&gt; node) {
        ((AVLNode&lt;E&gt;) node).updateHeight();
    }



    @Override
    protected Node createNode(Object element, Node parent) {
        return new AVLNode(element, parent);
    }
}

</div><div class="code-block" data-lang="java"></div></section><section class="chapter"><h6 id="-ola9fq_2213" data-toc="-ola9fq_2213">红黑树</h6></section></section></section></section><section class="chapter"><h3 id="map" data-toc="map">图(Map)</h3></section></section><section class="chapter"><h2 id="-ola9fq_2214" data-toc="-ola9fq_2214">排序</h2><div class="code-block" data-lang="java">
package HomeWork.sort;

import java.util.*;

/**
 * @Description:
 * @author: Anhlaidh
 * @date: 2020/3/13 0013 15:36
 */
public class SortImpl implements ISort {


    /**
     * 快速排序  O(nLog2n)
     * 一分为三,第一个数字为mid,分成比mid小,比mid大两个数组
     * 可知左边的一定比mid小,右边的一定比mid大
     * 递归拆分,合并即可获得有序数组
     * @param array 数组
     * @return 有序数组
     */
    @Override
    public int[] QuickSort(int[] array) {
        if (array.length&lt;=1) {
return array;}
        int mid = array[0];
        int left=1;
        int current=0;
        int right=array.length-1;
       while (left!=right){
           while (left!=right){
               if (array[right]&gt;=mid) {
right--;}else {
                   array[current] = array[right];
                   current = right;
                   right--;
                   break;
               }
           }
          while (left!=right){

              if (array[left]&lt;mid) {
left++;}else {
                  array[current] = array[left];
                  current = left;
                  left++;
                  break;
              }
          }

       }
        int[] l = Arrays.copyOfRange(array, 0, current);
        int[] r = Arrays.copyOfRange(array, current + 1, array.length);
        int[] l_sort = QuickSort(l);
        int[] r_sort = QuickSort(r);
        array[current] = mid;
        System.arraycopy(l_sort,0,array,0,l_sort.length);
        System.arraycopy(r_sort,0,array,current+1,r_sort.length);
        return array;

    }

    /**
     * 归并排序O(nLog2n)
     * 将数组一分为二一分为二,递归拆分成只有一个数字
     * 根据大小,来组合成有序数组
     * @param array 无序数组
     */

    @Override
    public void MergeSort(int[] array) {
        int mid = array.length/2;
        int[] left = null;
        int[] right=null;
        if (array.length&gt;1){
            //TODO 分成两个数组
            left = Arrays.copyOfRange(array, 0, mid);
             right = Arrays.copyOfRange(array, mid , array.length);
            MergeSort(left);
            MergeSort(right);
        }
        Merge(array,left,right);

    }

    private void Merge(int[] array, int[] left, int[] right) {
        if (left==null||right==null) {
array=array;}else {
           int l=0;
           int r=0;
           int i=0;
           while (i&lt;array.length){
               if (left[l]&lt;right[r]){
                   array[i] = left[l];
                   l++;
                   i++;
                   if (l&gt;=left.length){
                       while (r&lt;right.length){
                           array[i] = right[r];
                           r++;
                           i++;
                       }
                   }
               }
               else{
                   array[i] = right[r];
                   r++;
                   i++;
                   if (r&gt;=right.length){
                       while (l&lt;left.length){
                           array[i] = left[l];
                           i++;
                           l++;
                       }

                   }

               }
           }
        }
    }

    /**
     * 冒泡排序O(n2)
     * 依次比较,当前数字大于比较数字则交换,否则不变,将大数冒到最右
     * 循环冒泡,得到有序数组
     * @param array 无序数组
     */
    @Override
    public void BubbleSort(int[] array) {
        for (int j = array.length; j &gt; 0; j--) {
            for (int i = 0; i &lt; j - 1; i++) {
                if (array[i] &gt; array[i + 1]) {
                    int temp = array[i];
                    array[i] = array[i + 1];
                    array[i + 1] = temp;
                }
            }
        }
    }

    /**
     * 选择排序O(n2)
     * 遍历数组,找到最小值,与array[i]交换,以此类推
     * @param array
     */
    @Override
    public void SelectSort(int[] array) {
        for (int i =0;i&lt;array.length;i++){
            int min=i;
            for (int j=i ;j &lt;array.length;j++){

                if (array[j] &lt;array[min]){
                    min = j;
                }
            }
            if (min!=i){
                int temp = array[min];
                array[min] = array[i];
                array[i] = temp;
            }

        }

    }

    /**
     * 直接插入排序O(n2)
     * 依次遍历剩余数组,与当前尾节点比较,决定插入位置,循环插入
     * @param array
     */
    @Override
    public void InsertionSort(int[] array) {
        int index = 0;//当前排好序的尾节点


        while (index &lt; array.length) {
            int minIndex = index; // 遍历列表最小值坐标
            for (int i = index; i &lt; array.length; i++) {
                minIndex = array[i] &lt; array[minIndex] ? i : minIndex;
                //找到最小值并记录坐标

            }
            {
                int temp = array[minIndex];
                array[minIndex] = array[index];
                array[index] = temp;
            }
            //交换位置
            for (int i = index-1; i &gt;= 0; i--) {
                if (array[i] &gt;= array[i + 1]) {
                    int temp = array[i];
                    array[i] = array[i + 1];
                    array[i + 1] = temp;
                }
            }
            index++;
        }
    }
}

</div></section><section class="chapter"><h2 id="-ola9fq_2216" data-toc="-ola9fq_2216">分治</h2><p id="-ola9fq_2217">分而治之</p></section><section class="chapter"><h2 id="o-n-m" data-toc="o-n-m">动态规划 O(n*m)</h2><section class="chapter"><h3 id="-ola9fq_2218" data-toc="-ola9fq_2218">题目特点</h3><ol class="list _decimal" id="-ola9fq_2219" type="1"><li class="list__item" id="-ola9fq_2220"><p>计数 </p><ul class="list _bullet" id="-ola9fq_2221"><li class="list__item" id="-ola9fq_2222"><p>有多少种方式走到右下角</p></li><li class="list__item" id="-ola9fq_2223"><p>有多少种方法选出k个数使得和是sum</p></li></ul></li><li class="list__item" id="-ola9fq_2224"><p>求最大最小值 </p><ul class="list _bullet" id="-ola9fq_2225"><li class="list__item" id="-ola9fq_2226"><p>从左上角走到右小角路径的最大数字和</p></li><li class="list__item" id="-ola9fq_2227"><p>最长上升子序列长度</p></li></ul></li><li class="list__item" id="-ola9fq_2228"><p>求存在性 </p><ul class="list _bullet" id="-ola9fq_2229"><li class="list__item" id="-ola9fq_2230"><p>取石子游戏,先手是否必胜</p></li><li class="list__item" id="-ola9fq_2231"><p>能不能选出k个数使得和是sum</p></li></ul></li></ol></section><section class="chapter"><h3 id="-ola9fq_2232" data-toc="-ola9fq_2232">解题步骤</h3><ol class="list _decimal" id="-ola9fq_2233" type="1"><li class="list__item" id="-ola9fq_2234"><p id="-ola9fq_2235">确定状态</p><ul class="list _bullet" id="-ola9fq_2236"><li class="list__item" id="-ola9fq_2237"><p>知到f[i][j]代表什么</p></li><li class="list__item" id="-ola9fq_2238"><p>两个意识 </p><ul class="list _bullet" id="-ola9fq_2239"><li class="list__item" id="-ola9fq_2240"><p>最后一步(最优策略中使用的最后一枚硬币a[k])</p></li><li class="list__item" id="-ola9fq_2241"><p>化成子问题(最少的硬币拼出更小的面值27-a[k])</p></li></ul></li></ul></li><li class="list__item" id="-ola9fq_2242"><p id="-ola9fq_2243">转移方程</p><ul class="list _bullet" id="-ola9fq_2244"><li class="list__item" id="-ola9fq_2245"><p>f[X] = min{f[X-2]+1,f[X-5]+1,f[X-7]+1}</p></li></ul></li><li class="list__item" id="-ola9fq_2246"><p id="-ola9fq_2247">初始条件和边界情况</p><ul class="list _bullet" id="-ola9fq_2248"><li class="list__item" id="-ola9fq_2249"><p>初始条件:用转移方程算不出来,却又理所应当的值,需要手工定义(F[0]=0)</p></li><li class="list__item" id="-ola9fq_2250"><p>设定边界,例如不存在小于零的可能,定义小于零为正无穷(不要数组越界)</p></li></ul></li><li class="list__item" id="-ola9fq_2251"><p id="-ola9fq_2252">计算顺序</p><ul class="list _bullet" id="-ola9fq_2253"><li class="list__item" id="-ola9fq_2254"><p>当我们计算到F[X]时,F[X-2],f[X-5],F[X-7]都已经得到结果了</p></li></ul></li></ol><div class="code-block" data-lang="java">
class Solution {
    public int coinChange(int[] coins, int amount) {
        int n = coins.length;
        int M = amount + 1;
        int[] f = new int[M];
//初始化        
        f[0] = 0;
        for (int i = 1; i &lt; M; i++) {
            f[i] = Integer.MAX_VALUE;
            for (int j = 0; j &lt; n; j++) {
                if (i - coins[j] &gt;= 0 &amp;&amp; f[i - coins[j]] != Integer.MAX_VALUE) {
//                    转移方程
                    f[i] = Math.min(f[i - coins[j]] + 1, f[i]);
                }
            }
        }
        if (f[amount] == Integer.MAX_VALUE) {
            return -1;
        }
        return f[amount];
    }
}
</div><p id="-ola9fq_2256">二维: <a href="https://leetcode-cn.com/problems/unique-paths/comments/" id="-ola9fq_2257" data-external="true" rel="noopener noreferrer">不同路径</a></p><div class="code-block" data-lang="java">
public class q62 {
    public static void main(String[] args) {
        System.out.println(uniquePaths(3, 2));

    }

    public static int uniquePaths(int m, int n) {
        int[][] f = new int[m][n];
        f[0][0] = 0;
        for (int i = 0; i &lt; m; i++) {
            for (int j = 0; j &lt; n; j++) {
                if (i == 0 || j == 0) {
                    f[i][j] = 1;
                    continue;
                }
                f[i][j] = f[i - 1][j] + f[i][j - 1];

            }
        }
        return f[m - 1][n - 1];

    }
}
</div></section><section class="chapter"><h3 id="-ola9fq_2259" data-toc="-ola9fq_2259">动态规划初探</h3><ul class="list _bullet" id="-ola9fq_2260"><li class="list__item" id="-ola9fq_2261"><p>坐标型动态规划 </p><ul class="list _bullet" id="-ola9fq_2262"><li class="list__item" id="-ola9fq_2263"><p>给定坐标,怎么走</p></li><li class="list__item" id="-ola9fq_2264"><p>给定一个序列或网格</p></li><li class="list__item" id="-ola9fq_2265"><p>需要找到序列中某个/些子序列或网格中的某条路径 </p><ul class="list _bullet" id="-ola9fq_2266"><li class="list__item" id="-ola9fq_2267"><p>某种性质最大/最小</p></li><li class="list__item" id="-ola9fq_2268"><p>计数</p></li><li class="list__item" id="-ola9fq_2269"><p>存在性</p></li></ul></li><li class="list__item" id="-ola9fq_2270"><p>动态规划方程f[i]中的下表i表示以a[i]为结尾的满足条件的子序列,f[i][j]中的下表i,j代表以格子(i,j)为结尾的满足条件的路径的性质 </p><ul class="list _bullet" id="-ola9fq_2271"><li class="list__item" id="-ola9fq_2272"><p>最大值/最小值</p></li><li class="list__item" id="-ola9fq_2273"><p>个数</p></li><li class="list__item" id="-ola9fq_2274"><p>是否存在</p></li></ul></li><li class="list__item" id="-ola9fq_2275"><p>坐标型动态规划的初始条件f[0]就是指以a[0]为结尾的子序列的性质</p></li></ul></li><li class="list__item" id="-ola9fq_2276"><p>序列型动态规划 : 前i个...最小/方式数/可行性 </p><ul class="list _bullet" id="-ola9fq_2277"><li class="list__item" id="-ola9fq_2278"><p>在设计动态规划的过程中,发现需要知道油漆钱N-1栋房子的最优策略中,房子N-2的颜色</p></li><li class="list__item" id="-ola9fq_2279"><p>如果只用f[N-1],将无法区分</p></li><li class="list__item" id="-ola9fq_2280"><p>解决方法:记录下房子N-2的颜色 </p><ul class="list _bullet" id="-ola9fq_2281"><li class="list__item" id="-ola9fq_2282"><p>在房子N-2是红/蓝/绿的情况下,前N-1栋房子的最小花费</p></li></ul></li><li class="list__item" id="-ola9fq_2283"><p>序列+状态</p></li></ul></li><li class="list__item" id="-ola9fq_2284"><p>划分型动态规划</p></li></ul></section><section class="chapter"><h3 id="-ola9fq_2285" data-toc="-ola9fq_2285">优化</h3><ul class="list _bullet" id="-ola9fq_2286"><li class="list__item" id="-ola9fq_2287"><p>空间优化 </p><ul class="list _bullet" id="-ola9fq_2288"><li class="list__item" id="-ola9fq_2289"><p>滚动数组 </p><ul class="list _bullet" id="-ola9fq_2290"><li class="list__item" id="-ola9fq_2291"><p>计算dp[0][0],......dp[0][n-1],计算dp[1][0].......dp[1][n-1]</p></li><li class="list__item" id="-ola9fq_2292"><p>计算dp[2][0],......dp[2][n-1],把值写在f[0][0].......dp[0][n-1]的数组里</p></li><li class="list__item" id="-ola9fq_2293"><p>同理,dp[3][0],......dp[3][n-1],写在dp[1][0].......dp[1][n-1]的数组里</p></li><li class="list__item" id="-ola9fq_2294"><p>最后dp[m-1][n-1]存在dp[0][n-1]\(或者f[1][n-1]里),直接输出</p></li></ul></li></ul></li></ul></section></section><div class="last-modified">Last modified: 30 四月 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="jvm-1.html" class="navigation-links__prev">JVM</a><a href="java.html" class="navigation-links__next">Java-1</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b259/app.js"></script></body></html>