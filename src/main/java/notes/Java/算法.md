# 算法
## 基础
- 对数器
    - 一个想要测的方法a
    - 实现复杂度不好但是容易实现的方法b
    - 实现一个随机样本产生器
    - 方法a和方法b相同的随机样本,看看得到的结果是否一样
    - 如果一个随机样本使得比对结果不一致,打印样本进行人工干预,改对方法a和方法b
    - 当样本数量很多时对比测试依然正确,可以确定方法a已经正确
- 异或运算,二进制无进位相加
    - 性质:0^N=N,N^N=0
    - 满足交换律和结合律(同一批数异或答案一样,无论顺序)
    - ab互换
        1. a = a^b
        2. b = a^b
        3. a = a^b
        - ab必须指向不同内存
    - 提取最右侧1
        - N&((~N)+1)  N与((N取反)+1)
        
### 数据结构
- 链表
    - 反转链表,定义pre,next避免循环链表
- 栈
    - 要求可以立即返回最小值,且pop,push,getMin为O(1)
        - 单调栈(同步弹出省时间费空间)
            - 两个栈,一个栈为普通栈
            - 另一个为单调栈,普通栈压入的时候单调栈压数,小则放,大则放之前最小的
            - 可以同步大小
        - 单调栈不同步压入(费时间省空间)
            - 判断当前两个栈顶是否一样
    - 用栈拼队列
        - 两个栈
            - 一个push,一个pop
            - pop的时候倒过来再输出
                - pop栈为空的时候才可输出
                - push一次性倒完
- 队列
    - 用队列拼栈
        - 分两个队列,data,help
            - 取的时候把data元素扔到help中,剩一个,输出
            - 然后help为data,data为help
- HashSet&HashMap
    - 增删改查均为O(1)
    - Integer等大类型在HashMap,HashSet中是按值传递
- 有序表 
    - TreeMap
        - firstKey() 最小的
        - lastKey() 最大的
        - 离xx最近且小于的 floorKey(xx)
        - 离xx最近且大于的 ceilingKey(xx)
        - O(logN)
    - AVl
    - 红黑树
    - 跳表
    
    
- 
### 递归
- Master公式
    - T(N) = aT(N/b)+O(N^d)
        - 子问题的规模是一致的(N/b)
        - 子问题调用了a次
        - 除了子问题调用之外,生下的复杂度为O(N^d)
        - log(b)a>d,O(N^log(b)a)
        - log(b)a<d,O(N^d)
        - log(b)a==d,O(N^(d*logN))

        
        
        
     
## 预处理
### 前缀和求数组滚动窗口和   
## 问题范围和问题答案是否有线性规律
- 双端队列
    - 最xx优先级队列
    - 滑动窗口问题
- 单调栈
