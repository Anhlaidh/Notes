# 算法
## 基础
- 对数器
    - 一个想要测的方法a
    - 实现复杂度不好但是容易实现的方法b
    - 实现一个随机样本产生器
    - 方法a和方法b相同的随机样本,看看得到的结果是否一样
    - 如果一个随机样本使得比对结果不一致,打印样本进行人工干预,改对方法a和方法b
    - 当样本数量很多时对比测试依然正确,可以确定方法a已经正确
- 异或运算,二进制无进位相加
    - 性质:0^N=N,N^N=0
    - 满足交换律和结合律(同一批数异或答案一样,无论顺序)
    - ab互换
        1. a = a^b
        2. b = a^b
        3. a = a^b
        - ab必须指向不同内存
    - 提取最右侧1
        - N&((~N)+1)  N与((N取反)+1)
        
### 数据结构
- 链表
    - 反转链表,定义pre,next避免循环链表
- 栈
    - 要求可以立即返回最小值,且pop,push,getMin为O(1)
        - 单调栈(同步弹出省时间费空间)
            - 两个栈,一个栈为普通栈
            - 另一个为单调栈,普通栈压入的时候单调栈压数,小则放,大则放之前最小的
            - 可以同步大小
        - 单调栈不同步压入(费时间省空间)
            - 判断当前两个栈顶是否一样
    - 用栈拼队列
        - 两个栈
            - 一个push,一个pop
            - pop的时候倒过来再输出
                - pop栈为空的时候才可输出
                - push一次性倒完
- 队列
    - 用队列拼栈
        - 分两个队列,data,help
            - 取的时候把data元素扔到help中,剩一个,输出
            - 然后help为data,data为help
- HashSet&HashMap
    - 增删改查均为O(1)
    - Integer等大类型在HashMap,HashSet中是按值传递
- 有序表 
    - TreeMap
        - firstKey() 最小的
        - lastKey() 最大的
        - 离xx最近且小于的 floorKey(xx)
        - 离xx最近且大于的 ceilingKey(xx)
        - O(logN)
    - AVl
    - 红黑树
    - 跳表
- 堆
    - 结构上:完全二叉树
        - 0开始
            - i的左子节点 2*i+1
            - i的右子节点 2*i+2
            - 父节点(i-1)/2
        - 1开始
            - i的左孩子 2*i i<<1
            - i的右孩子 2*i+1 i<<1|1
            - 父节点 i/2   i>>1
        - 大根堆
            - 父节点是最大的
        - 小根堆
            - 父节点是最小的
        - 均不是则不是堆
        
- 
### 递归
- Master公式
    - T(N) = aT(N/b)+O(N^d)
        - 子问题的规模是一致的(N/b)
        - 子问题调用了a次
        - 除了子问题调用之外,生下的复杂度为O(N^d)
        - log(b)a>d,O(N^log(b)a)
        - log(b)a<d,O(N^d)
        - log(b)a==d,O(N^d(*logN))

- 归并排序 思想
    - 左边数量多少个大,左边数量多少个小,右边数量多少个大,右边数量多少个小(用mergeSort改)
        - 在一个数组中,一个数左边比他小的数的总和,叫数的小和,所有数的小和累加起来,叫数组小和,求数组小和
            - 加返回值,修改merge()
        - 降序对 - 右边有多少个数比它小
- 快排 思想
    - 指定num,将数组分为小于等于num的和大于num的两个区
        - 设定小于等于区从-1开始,然后指针遍历数组直到越界
            - 如果当前数字大于num则不动,cur指针+1
            - 如果当前数字小于等于num,cur指针的数于小于等于区指针的数互换,小于等于区指针++,cur指针++
    - 给定num分成三块,小于区,等于区,大于区 
        - 分三个区,小于区,等于区,大于区,i跟大于区边界撞上的时候停止
            - arr[i]==num,i++
            - arr[i]<num,arr[i]与小于区的右一个交换(有等于的情况,与之前思路不同 ),小于区右扩,i++
            - arr[i]>num,arr[i]与大于区做一个交换,大于区左扩,i不变
    - 荷兰国旗问题
        - 以arr[R]划分
    - 快排1.0 O(n)
        - mid放中间,左右两侧递归
        - 有序的时候效率最低
    - 快排2.0 O(n)
        - 荷兰国旗问题,分为小于区,等于区,大于区,一次可以搞定一批等于的mid  
        - 有序的时候效率最低
    - 快排3.0随机快排 O(N logN)->概率累加期望 额外空间复杂度O(logN)
        - 随机找一个值跟arr[R]交换,然后执行2.0
    

        
        
     
## 预处理
### 前缀和求数组滚动窗口和   
## 问题范围和问题答案是否有线性规律
- 双端队列
    - 最xx优先级队列
    - 滑动窗口问题
- 单调栈
